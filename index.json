[{"categories":["算法"],"content":"参考 「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。 递归之后需要做和递归之前相同的逆向操作 问题1 给定一个 没有重复 数字的序列，返回其所有可能的全排列。 我们尝试在纸上写 333 个数字、444 个数字、555 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。 先写以 111 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）； 再写以 222 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列； 最后写以 333 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。 总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。 每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」； 使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」； 深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈； 深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。 设计状态变量(重要，必须明确状态变量) 首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构； 递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少； 布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。 这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。 状态变量：表示求解一个问题所处的阶段 depth:表示当前递归到了第几层,用于判断递归是否可以终止 used:表示哪几个数被使用过；初始化都为false,表示这些数都没有被选择过，当选定一个数的时候就将这个数组的相应位置设置为true path:使用栈，往下走一层的时候，在末尾添加一个数，往回走的时候，撤销上一次的操作。 class Solution { public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums){ int len= nums.length; List\u003cList\u003cInteger\u003e\u003e res=new ArrayList\u003c\u003e(); if (len==0) return res; Deque\u003cInteger\u003e path=new ArrayDeque\u003c\u003e(len); boolean[] used=new boolean[len];//boolean数组初始化为false dfs(nums,len,0,path,used,res); return res; } /* 状态变量：表示求解一个问题所处的阶段 * depth:表示当前递归到了第几层,用于判断递归是否可以终止 * used:表示哪几个数被使用过；初始化都为false,表示这些数都没有被选择过，当选定一个数的时候就将这个数组的相应位置设置为true * path:使用栈，往下走一层的时候，在末尾添加一个数，往回走的时候，撤销上一次的操作。 * */ private void dfs(int[] nums, int len, int depth, Deque\u003cInteger\u003e path, boolean[] used, List\u003cList\u003cInteger\u003e\u003e res) { if (depth==len) {//当depth==len表示此时递归可以终止，将路径添加当res中然后返回。 res.add(new ArrayList\u003c\u003e(path));//注意变量 path 所指向的列表 在深度优先遍历的过程中只有一份 //在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6空的列表对象 return; } // 在非叶子节点处产生不同的分支；即在还未选择的数中选择一个元素作为下一个元素 for (int i=0;i\u003clen;i++){ if (!used[i]){//如果当前数字还未被选择 path.add(nums[i]);//则将该数字添加入路径中,即添加在栈的尾部 used[i]=true;//将该数字的状态设置为true，表示该数字已经被使用过了 dfs(nums, len, depth+1, path, used, res);//往下一层进行搜索，直到depth==len used[i]=false;//状态[回溯]，将尾部的数字设置为未被使用 //这一部分与往尾部添加元素的形式是对称的 path.removeLast();//将尾部数字移除 } } } } 问题2 参考 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 注意这里与问题1的不同之处在于，给定的数组是可能包含重复数字的。因此还需要考虑如何将重复的排列消除 class Solution { public List\u003cList\u003cInteger\u003e\u003e permuteUnique(int[] nums) { int len= nums.length; List\u003cList\u003cInteger\u003e\u003e res=new ArrayList\u003c\u003e();//保存最终结果的变量 if (len==0) return res; Deque\u003cInteger\u003e path=new ArrayDeque\u003c\u003e();//保存路径的状态变量 boolean[] used=new boolean[len];//表示该数字是否被使用过 Arrays.sort(nums);//先对数组进行排序，以便判断是否重复的排列 dfs(nums,len,0,path,used,res); return res; } private void dfs(int[] nums, int len, int depth, Deque\u003cInteger\u003e path, boolean[] used, List\u003cList\u003cInteger\u003e\u003e res) { //终止条件 if (depth==len){ res.add(new ArrayList\u003c\u003e(path)); return; } for (int i=0;i\u003clen;i++){ if (!used[i]){ if (i\u003e0\u0026\u0026nums[i]==nums[i-1]\u0026\u0026!used[i-1]){//用于排除重复排序 continue; } used[i]=true; path.add(nums[i]); dfs(nums, len, depth+1, path, used, res); path.removeLast(); used[i]=false; } } } } 问题3 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { LinkedList\u003cList\u003cInteger\u003e\u003e result = new LinkedList\u003c\u003e(); Deque\u003cInteger\u003e path=new ArrayDeque\u003c\u003e();//path,使用栈结构保存状态变量 public List\u003cList\u003cInteger\u003e\u003e pathSum(TreeNode root, int sum) { recur(root, sum); return result; } void recur(TreeNode root, int target) { //采用先序遍历的方式计算-\u003e根左右 //采用减法的方式，每一次减去root.val， if (root == null) return; path.add(root.val); target = target - root.val; //使用target","date":"2021-02-04","objectID":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"回溯算法","uri":"/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"},{"categories":["Java学习笔记"],"content":"NoSQL(Not Only SQL)，泛指非关系型数据库用于解决大规模数据存储。这些类型的数据存储不需要固定的模式，无需多余的操作就可以横向扩展。 优点： 易拓展;数据之间没有关系。 大数据量高性能 ；NoSQL数据库具有非常高的读写性能，在大数据量下同样表现优秀 多样灵活的数据模型 ； NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式 RDBMS(关系型数据库) vs. NoSQL 传统的ACID: A: （Atomicity）原子性 C:（Consistency）一致性 I：（Isolation）独立性 D:（Durability）持久性 CAP： C：（Consistency）强一致性 A：（Availability）高可用性 P:（Partition tolerance） 分区容错性 CAP的3进2： CAP的核心理论是：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性，最多只能较好的满足其中的两个。 CA:单点集群，满足一致性，可用性的系统，通常在拓展性上不太强大–\u003e传统Oracle数据库 CP:满足一致性，分区容错性的系统，通常性能不是特别高–\u003eRedis AP:满足可用性，分区容错性的系统，通常对一直性要求低一些 分布式 VS 集群 分布式：不同的多台服务器上部署不同的服务模块他们之间通过RPC/Rmi之间通信和调用，对外提供服务和组内协作。 集群：不同的多台服务器上部署相同的服务模块，通过分布式调度软件j进行统一的调度，对外提供服务和访问。 票】、4 ","date":"2021-02-01","objectID":"/redis/:0:0","tags":null,"title":"Redis","uri":"/redis/"},{"categories":["算法"],"content":"在这里，复制的意思是指 深拷贝（Deep Copy），类似我们常用的“复制粘贴”，事实上，与此对应的还有 浅拷贝，它们的区别是： 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 1.普通单向链表的定义 // Definition for a Node. class Node { int val; Node next; public Node(int val) { this.val = val; this.next = null; } } 给定链表的头结点head，复制链表需要遍历链表，每一轮建立新节点+构建前驱结点pre和当前结点node的引用指向即可 class Solution{ public Node copy(Node head){ Node cur=head; Node dum=new Node(0);//随意初始化一个结点 Node pre=dum; while(cur!=null){ Node node=new Node(cur.val);//复制当前结点，进行深拷贝 pre.next=node;//前驱结点 cur=cur.next;//遍历下一个结点 pre=node;//保存当前结点 } return dum.next//dum的下一个结点即为头结点。 } } 2.复制一个复杂的链表 https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/ 复杂链表的定义： /* // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } */ 解法1：利用哈希表的特性，构建原链表结点和新链表结点的对应关系，再遍历构建新链表各节点的next和random class Solution{ public Node copy(Node head){ if (head==null) return null; Node cur=head; Map\u003cNode,Node\u003e map=new HashMap\u003c\u003e(); //复制结点，并建立原结点和新节点的键值对 while(cur!=null){ map.put(cur,new Node(cur.val)); cur=cur.next; } cur=head; //构建链表的next和random指向 while(cur!=null){ map.get(cur).next=map.get(cur.next);//map.get(cur)对应value，即新链表,新链表的next等于map.get(cur.next)，即原链表的next map.get(cur).random=map.get(cur.random); cur=cur.next; } return map.get(head);//返回新链表的头结点 } } ","date":"2021-01-28","objectID":"/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/:0:0","tags":null,"title":"链表的复制","uri":"/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"categories":["算法"],"content":"机器人的运动范围 ### 解题思路 采用广度优先搜索的方式 广度优先通常采用队列的方式，以一种平铺的方式进行计算 移动方向：我们可以只定义向下和向右进行移动 class Solution { public int movingCount(int m, int n, int k) { Deque\u003cint[]\u003e deque = new ArrayDeque\u003c\u003e();//定义一个队列，由于添加删除状态 int[] dx = {1, 0};//右移一位 int[] dy = {0, 1};//下移一位 boolean[][] vis = new boolean[m][n];//定义一个boolean二维数组用于确定该坐标是否被添加 vis[0][0] = true;//坐标[0][0]一定会被使用的，因此将其初始化为true deque.offer(new int[]{0, 0});//添加坐标[0][0] int ans = 1; while (!deque.isEmpty()) { int[] c = deque.poll();//将对头的元素poll int cx = c[0];//获得其x坐标 int cy = c[1];//获得其y坐标 for (int i = 0; i \u003c 2; i++) {//分别向右和向下进行查询 int tx = dx[i] + cx;//下一步的x坐标 int ty = dy[i] + cy;//下一步的y坐标 if (tx \u003c 0 || tx \u003e= m || ty \u003c 0 || ty \u003e= n || vis[tx][ty] == true || getsum(tx) + getsum(ty) \u003e k) { // 特例情况的判断，包括了越界：tx\u003c0||tx\u003em||ty\u003c0||ty\u003en // 该坐标已经被添加了 // 该坐标的数位和大于k continue; } deque.offer(new int[]{tx, ty}); vis[tx][ty] = true; ans++; } } return ans; } private int getsum(int s) {//求数字位数和,例45 --\u003e 位数和为4+5=9 int res = 0; while (s != 0) { res += s % 10;//求个位数 s = s / 10;//将数字右移一位 } return res; } } ","date":"2021-01-25","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"广度优先问题问题","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"n件物品，它们装入背包所占的容量分别为w1、w2……wn;它们所拥有的价值分别为p1、p2 ……p n； 有一个总容量为C的背包； 在装满背包的情况下，如何使得包内的总价值最大？ 该问题的特点是：每个物品仅有一个，可以选择放或者不放，也就是说每个物品只能使用一次。 首先我们定义一个变量$B(i,j)$表示当背包容量为j，前i个物品（第1个到第i个）的情况下包内的最大价值。 即有i个物品，背包的容量为j，此时的包内的最大价值。 我们对每一件物品进行编号，可以列出以下表格： 行表示背包的容量，列表时背包的编号；为了便于操作，我们将0也加入了表格之中。 现在来分析$B(i,j)$的情况，首先明确一点，为了求出$B(i,j)$，我们可以利用之前的状态。 $$ B(i,j)=\\left{ \\begin{array}{lcl} B(i-1,j) \u0026if \u0026w[i]\u003ej \\ max{ [B(i-1,j)]; [B(i-1,j-w(i))+p(i)] } \u0026if \u0026w[i]\u003c=j \\end{array}\\right. $$ 对于情况$w[i]\u003ej$表示第i个物品的重量大于背包容量，所以此时不能够放入第i个物品进背包内，只能够放弃，因此这种情况下只能够考虑前i-1个物品，即：$B(i-1,j)$ 对于第二种情况，当前背包能够放入第i个物品。这时我们需要考虑两种情况：1.放入第i个物品；2.不放入第i个物品；因此我们需要在这两种情况中选出一个最大值； public class pack { public static void main(String[] args) { int[] w={0,2,3,4,5};//各物品体积 int[] p={0,1,2,5,6};//各物品价值 int c=8;//背包总容量 int x=w.length-1; int[][] B=new int[x+1][c+1]; for (int i=1;i\u003cx+1;i++){ for (int j=1;j\u003cc+1;j++){ if (w[i]\u003ej){ B[i][j]=B[i-1][j]; } else{ B[i][j]=Math.max(B[i-1][j],(B[i-1][j-w[i]])+p[i]); } } System.out.println(Arrays.toString(B[i])); } } } /* [0, 0, 1, 1, 1, 1, 1, 1, 1] [0, 0, 1, 2, 2, 3, 3, 3, 3] [0, 0, 1, 2, 5, 5, 6, 7, 7] [0, 0, 1, 2, 5, 6, 6, 7, 8] */ ","date":"2021-01-11","objectID":"/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"01背包问题","uri":"/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"动态规划解题的4个步骤 定义子问题(重叠子问题) 写出子问题的递推关系 确定DP数组的计算顺序 空间优化（可选） 打家劫舍 采用一维数组的动态规划 // 问题转化为：给定长度为n的数组，如何取最大的和（在满足条件的情况下） class Solution { public int rob(int[] nums) { int len=nums.length; if(len==0) return 0; if(len==1) return nums[0]; int[] dp=new int[len]; dp[0]=nums[0]; dp[1]=Math.max(nums[0],nums[1]); for(int i=2;i\u003clen;i++){ dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); } return dp[len-1]; } } 打家劫舍 II 采用两个一维数组的动态规划 class Solution { public int rob(int[] nums) { int len = nums.length; if (len == 0) return 0;//表示没有屋子可偷 if (len == 1) return nums[0]; //表示只有一间屋子可偷 if (len==2) return Math.max(nums[0],nums[1]);//只有两件屋子可以偷，直接返回大者即可 //此时房子的数量大于等于3；因为首尾不能够相接，我们将其分为两种情况： // 情况1：不偷第一家的情况下可以得到的最大值 // 情况2：不偷最后一家的情况下可以得到的最大值 // 将情况1与情况2中的大者即为所求的答案 int[] dp = new int[len - 1];//表示不偷最后一家时可以通到的最大值 dp[0] = nums[0];//偷第一家 dp[1] = Math.max(nums[0], nums[1]);//初始状态 for (int i = 2; i \u003c len-1; i++) { dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); } // int[] dq = new int[len - 1]; dq[0] = nums[1];//不偷第一家 dq[1] = Math.max(nums[1], nums[2]);//初始状态 for (int i = 2; i \u003c len-1; i++) { dq[i] = Math.max(dq[i - 1], dq[i - 2] + nums[i+1]); } return Math.max(dp[len - 2], dq[len - 2]); } } 打家劫舍 III 采用树型结构的动态规划 零钱兑换 class Solution { public int coinChange(int[] coins, int amount) { /* * 采用动态规划的方式 * dp[i]表示目标为i时所用的最小硬币数 * dp[i]=min(dp[i],1+dp[i-coin] for coin in coins ) * */ int[] dp = new int[amount + 1]; //新状态的值要参考的值以前计算出来的「有效」状态值。 // 因此，不妨先假设凑不出来，因为求的是小，所以设置一个不可能的数。 Arrays.fill(dp, amount + 1);//将数组元素全部填充为amount+1 dp[0] = 0; for (int i = 1; i \u003c= amount; i++) { for (int coin : coins) { //单枚硬币的面值首先要小于等于 -\u003ei - coin \u003e= 0 if (i - coin \u003e= 0 \u0026\u0026 dp[i - coin] != amount + 1) {// dp[i] = Math.min(dp[i], 1 + dp[i - coin]); } } } if (dp[amount] == amount + 1) { return -1; } return dp[amount]; } } n个骰子的个数 设共有n个骰子，每一个骰子共有6面，则总共的次数为$6^n$，设$F(n,s)$表示n个骰子出现点数为s的次数 当n=1时，$F(1,s)=1$，其中s=1,2,3,4,5,6 当$n\\geq 2 $时，$F(n,s)=F(n-1,s-1)+F(n-1,s-2)+F(n-1,s-3)+F(n-1,s-4)+F(n-1,s-5)，F(n-1,s-6)$，即当第n个骰子分别为1,2,3,4,5,6时，分别计算前n-1个骰子出现的s-1,s-2,,s-3,s-4,s-5,s-6的次数，然后进行相加。 可以看出，当计算n个骰子出现和为s的情况时，是依赖与前n-1个骰子的情况的，这就存在着重叠子问题，因此可以采用动态规划的方式进行解决。 第一步：定义dp数组：设dp [i] [s] 为i个骰子出现点数s 的次数 第二步：dp [i] [s] = dp [i] [s-1]+ dp [i] [s-2]+ dp [i] [s-3]+ dp [i] [s-4]+ dp [i] [s-5] … 当s-j\u003e=i-1时 ，j表示第i个骰子的数字；因为 dp[i-1][s-j]表示i-1个骰子出现和为s-j的次数 i-1个骰子的最小和为i-1,最大和为(i-1)*6 因此(s-j)\u003e=(i-1) 所以当(s-j)\u003c(i-1)会出错 class Solution{ public double[] dicesProbability(int n) { int[][] dp =new int[n+1][6*n+1]; for (int i=1;i\u003c=6;i++){//初始化 dp[1][i]=1; } for (int i =2;i\u003c=n;i++){//表示骰子的个数 for (int s=i;s\u003c=6*i;s++){//可能出现的点数之和;假设骰子的个数为i,那么最小的点数之和为i(即每个骰子出现的点数都为1)，最大的点数和为6*i(即每一个骰子出现的点数都为6) for (int j=1;j\u003c=6;j++){//表示当前这个骰子出现的点数 if (s\u003ci-1+j){ //dp[i-1][s-j]表示i-1个骰子出现和为s-j的次数 //i-1个骰子的最小和为i-1,最大和为(i-1)*6 //因此(s-j)\u003e=(i-1) //所以当(s-j)\u003c(i-1)会出错 break; } dp[i][s]+=dp[i-1][s-j]; } } } double total= Math.pow((double)6,(double)n); double[] ans=new double[5*n+1]; for (int i=n;i\u003c=6*n;i++){ ans[i-n]=((double)dp[n][i])/total; } return ans; } } 把数字翻译成字符串 假设有i个数字$x_1,x_2,…,x_{(i-1)},x_{(i)}$ 假设$f(i)$表示有i个数字时的翻译方法数的表达式为： $$ f(i)=\\left{ \\begin{array}{lcl} f(i-1)+f(i-2) \u002610\\times x_{(i-1)} +x_{(i)} \\in [10,25]\\ f(i-1) \u0026 else \\end{array}\\right. $$ 解释如下，有两种情况： 最后两个数字的组合的和在[10,25]时，有两种翻译方法，一种为最后一个数字单独翻译，此时的f(i)=f(i-1)，另一种为最后两个数字组合在一起翻译，此时的f(i)=f(i-2)，所以这种情况的翻译方法数为$f(i)=f(i-1)+f(i-2)$ 当最后两个数字的的组合的和不在[10,25]时，因为最后两个数字不能够组合在一起翻译，只能够最后一个数字单独翻译，所以这种情况的翻译数为$f(i)=f(i-1)$ 通过以上的分析可以得出，这个问题是存在重叠子问题的，所以可以采用动态规划的方式进行解决 定义dp[i] 表示 有i个数字时的翻译数量 注意将dp[0]初始化为1，因为很显然当i=1式只有一种翻译方法即dp[1]=1，当i=2时有两种翻译方法,即dp[2]=dp[0]+dp[1]，由此可以反推出dp[0]应该初始化为1. 代码如下： class Solution { public int translateNum(int num) { String s=String.valueOf(num); int[] dp=new int[s.length()+1]; dp[0]=1;//初始化，这里将其初始化为0 dp[1]=1;//初始化 for (int i=2;i\u003c=s.length();i++){ String temp=s.substring(i-2,i); if (temp.compareTo(\"10\")\u003e=0\u0026\u0026temp.compareTo(\"25\")\u003c=0){ dp[i]=dp[i-1]+dp[i-2]; } else { dp[i]=dp[i-1]; } } return dp[s.length()]; } } 末尾 ","date":"2021-01-11","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"动态规划问题","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"},{"categories":["Java学习笔记"],"content":"什么是设计模式 设计模式是软件设计中常见问题的典型解决方案。 每个设计模式就像是一张蓝图，你可以对其进行定制来解决代码中的特定设计问题。 设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。 模式是针对软件设计中常见问题的解 决方案工具箱， 它们定义了一种让你的团队能更高效沟通的通用语言。 简单工厂方法 定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类 //定义一个接口 public interface Product { } //CreateProduct1,CreateProduct2,CreateProduct3都是接口的实现类 class CreateProduct1 implements Product{ } class CreateProduct2 implements Product{ } class CreateProduct3 implements Product{ } //定义简单工厂类 //可以通过参数（type）的选择返回不同的实例(CreateProduct1,CreateProduct2,CreateProduct3) public class SampleFactoryMode { public Product creatrProduct(int type){ if (type==1){ return new CreateProduct1(); } else if(type==2){ return new CreateProduct2(); } else { return new CreateProduct3(); } } } //主方法通过直接调用简单工厂类，来得到不同的实例（通过不同的参数），而不需要知道实例中的具体实现 public class main { public static void main(String[] args) { SampleFactoryMode sampleFactoryMode=new SampleFactoryMode(); Product product=sampleFactoryMode.creatrProduct(1); } } SampleFactoryMode(工厂):核心部分，负责实现创建所有产品的内部逻辑，工厂类可以被外界直接调用，创建所需对象 Product(抽象类产品)：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象 CreateProduct(具体产品)：简单工厂模式的创建目标，所有被创建的对象都是某个具体类的实例。它要实现抽象产品中声明的抽象方法(有关抽象类) 工厂方法 参考 考虑这样一个系统,使用简单工厂模式设计的按钮工厂类可以返回一个具体类型的 按钮实例,例如圆形按钮矩形按钮、菱形按钮等。 在这个系统中如果需要增加一种新类型的按钮,例如椭圆形按钮,那么除了增加一个新的具体产品类之外还需要修改工厂类的代码,这就使得整个设计在一定程度上违反了开闭原则。 现在对该系统进行修改,不再提供一个按钮工厂类来统一负责所有产品的创建,而是将具体按钮的创建过程交给专门的工厂子类去完成。 先定义一个抽象的按钮工厂类 再定义具体的工厂类来生产圆形按钮、矩形按钮、菱形按钮等,它们实现了在抽象按钮工厂类中声明的方法 这种抽象化的结果是使得这种结构可以在不修改具体工厂类的情况下引进新的产品,如果出现新的按钮类型,只需要为这种新类型的按钮定义一个具体的工厂类就可以创建该新按钮的实例,这种改进的设计方案即为工厂方法模式 在工厂方法模式中不再提供一个统一的工厂类来创建所有的产品对象,而是针对不同的产品提供不同的工厂 工厂方法模式:定义一个用于创建对象的工厂接口/或抽象类,但是让工厂实现类决定将哪一个产品类实例化。工厂方法模式让一个类的实例化延迟到其子类 public interface Product { } class CreateProduct1 implements Product { } class CreateProduct2 implements Product{ } class CreateProduct3 implements Product{ } //创建抽象工厂类 public abstract class FactoryMode { abstract public Product factorymethod(); } //创建具体工厂类，每一个具体工厂类负责实例化一个产品 class CreateFactory1 extends FactoryMode { @Override public Product factorymethod() { return new CreateProduct1(); } } class CreateFactort2 extends FactoryMode { @Override public Product factorymethod() { return new CreateProduct2(); } } class CreateFactory3 extends FactoryMode { @Override public Product factorymethod() { return new CreateProduct3(); } } public class main { public static void main(String[] args) { FactoryMode factoryMode=new CreateFactory1();//主方法可以通过选择具体工厂类来确定返回的实例化的产品 Product product=factoryMode.factorymethod();//这时可以得到特定的实例化产品 //do something } } 抽象工厂方法 同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。 抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。 抽象工厂方法可以创建出多个产品等级的对象，例如[海尔空调，TCL空调] ; [海尔电视机，TCL电视机] 抽象工厂模式的主要角色如下。 ​ 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 ​ 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。有多个具体工厂，每一个具体工厂负责创建同一等级的具体产品（这些具体产品是相关的，必须同时创建） ​ 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。有多个种类的抽象产品 ​ 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 //创建两个不同的产品接口，代表两类不同的产品 public interface ProductA { } public interface ProductB { } //为每一个产品接口创建具体的产品类 //产品A有两个具体产品A1，A2；/产品A有两个具体产品B1，B2 public class CreateProductA1 implements ProductA { } public class CreateProductA2 implements ProductA { } public class CreateProductB1 implements ProductB { } public class CreateProductB2 implements ProductB { } //创建抽象工厂类,其中有两个抽象方法 public abstract class AbstarctFactory { abstract ProductA CreateFactoryA(); abstract ProductB CreateFactoryB(); } //具体工厂类,每一个具体工厂类负责创建属于不同产品但是属于同一等级的产品（注意此处与上述有出入，） public class ConcreteFactory1 extends AbstarctFactory { @Override ProductA CreateFactoryA() { return new CreateProductA1(); } @Override ProductB CreateFactoryB() { return new CreateProductB1(); } } public class ConcreteFactory2 extends AbstarctFactory { @Override ProductA CreateFactoryA()","date":"2021-01-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:0","tags":null,"title":"设计模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"第 1 种：懒汉式单例 该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下： public class LazySingleton { private static volatile LazySingleton instance = null; //保证 instance 在所有线程中同步 private LazySingleton() { } //private 避免类在外部被实例化 public static synchronized LazySingleton getInstance() { //getInstance 方法前加同步，属于类方法，可以通过类名直接调用 if (instance == null) { instance = new LazySingleton();//实例由类自行创建 } return instance;//提供一个全局访问点 } } 注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。 ","date":"2021-01-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":null,"title":"设计模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"第 2 种：饿汉式单例 该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 public class HungrySingleton { private static final HungrySingleton instance = new HungrySingleton();//单例对象由单例类自行创建 private HungrySingleton() { } public static HungrySingleton getInstance() { return instance; } } 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。 ","date":"2021-01-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":null,"title":"设计模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"单例模式的应用实例 【例1】用懒汉式单例模式模拟产生美国当今总统对象。 分析：在每一届任期内，美国的总统只有一人，所以本实例适合用单例模式实现，图 2 所示是用懒汉式单例实现的结构图 /* * 用懒汉式单例模式模拟产生美国当今总统对象。 * */ public class President { private static volatile President instance = null;//保证instance在所有线程中同步 //private避免类在外部被实例化 private President() { System.out.println(\"产生一个总统！\"); } public static synchronized President getInstance() {//getInstance是静态方法，属于类 // 在getInstance方法上加上同步 if (instance == null) { instance = new President();//单例对象由单例类自行创建，且单例类自有一个单例对象 } else { System.out.println(\"已经有一个总统，不能产生新的总统！\"); } return instance;//单例类提供一个对外的全局访问点 } public void getname() { System.out.println(\"我是美国总统，奥巴马！\"); } } public class main { public static void main(String[] args) { President a=President.getInstance();//只有当调用getInstance方法会创建一个单例对象；getInstance是静态方法，属于类，所以可以直接通过类名直接调用。 a.getname(); President b=President.getInstance(); b.getname(); if (a==b){ System.out.println(\"他们是同一个人！\"); } else { System.out.println(\"他们不是同一个人！\"); } } } //产生一个总统！ //我是美国总统，奥巴马！ //已经有一个总统，不能产生新的总统！ //我是美国总统，奥巴马！ //他们是同一个人！ 建造者模式（Bulider模式） 建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 生活中这样的例子很多，如汽车中的方向盘、发动机、车架、轮胎等部件多种多样； 以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。（即组装汽车的组成部件是一样的，但是每个部件可以可以选择不同的款式。） 该模式的主要优点如下： ​ 封装性好，构建和表示分离。 ​ 扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 ​ 客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。 其缺点如下： ​ 产品的组成部分必须相同，这限制了其使用范围。 ​ 如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。 建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 建造者（Builder）模式的主要角色如下。 ​ 产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。 ​ 抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。 ​ 具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。 ​ 指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。 /* * 产品角色：包含多个组成部件的复杂对象。 * */ public class Product { private String A; private String B; private String C; public void setA(String a){ this.A=a; } public void setB(String b) { B = b; } public void setC(String c) { C = c; } } /* * 抽象建造者：包含创建产品各个子部件的抽象方法。 * */ public abstract class Builder { // 创建产品对象 protected Product product = new Product(); public abstract void buildA(); public abstract void buildB(); public abstract void buildC(); public Product getProduct() { return product; } } /* * 具体建造者：实现了抽象建造者。 * */ public class ConcreteBuilder extends Builder { @Override public void buildA() { product.setA(\"build A\"); } @Override public void buildB() { product.setA(\"build B\"); } @Override public void buildC() { product.setC(\"build C\"); } } /* * 指挥者：调用建造者中的方法完成复杂对象的创建。 * */ public class Director { private Builder builder; public Director (Builder builder){ this.builder=builder; } //产品构建与组装方法 public Product construct(){ builder.buildA(); builder.buildB(); builder.buildC(); return builder.getProduct(); } } public class main { public static void main(String[] args) { Builder builder=new ConcreteBuilder(); Director director=new Director(builder); Product product= director.construct(); //do something with product } } 原型模式 原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。 原型模式包含以下主要角色。 ​ 抽象原型类：规定了具体原型对象必须实现的接口。 ​ 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 ​ 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 原型模式的克隆分为浅克隆和深克隆。 ​ 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 ​ 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 //定义抽象原型类， public abstract class Prototype { abstract Prototype myclone(); } //定义具体原型类，实现抽象原型类中的clone方法 public class ConcreatePrototype extends Prototype { private String filed; public ConcreatePrototype (String filed){ this.filed=filed; } @Override Prototype myclone() { return new ConcreatePrototype(filed); } @Override public String toString() { return \"ConcreatePrototype{\" + \"filed='\" + filed + '\\'' + '}'; } } //主方法，使用具体原型类中的clone方法来复制新对象 public class main { public static void main(String[] args) { Prototype prototype=new ConcreatePrototype(\"abc\"); Prototype clone=prototype.myclone(); System.out.println(clone.toString()); } } Ja","date":"2021-01-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:0","tags":null,"title":"设计模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"原型模式的应用实例 【例】用原型模式生成“三好学生”奖状。 分析：同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，属于相似对象的复制，同样可以用原型模式创建，然后再做简单修改就可以了。奖状类是具体原型类，而 Java 中的 Cloneable 接口是抽象原型类。 //具体原型类 public class Citation implements Cloneable { private String name; private String info; private String college; public Citation(String name,String info,String college){ this.name=name; this.info=info; this.college=college; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void display(){ System.out.println(name+info+college); } public Object clone() throws CloneNotSupportedException { System.out.println(\"奖状拷贝成功！\"); return (Citation)super.clone(); } } public class ProtoTypeCitation { public static void main(String[] args) throws CloneNotSupportedException { Citation t1=new Citation(\"张三\", \"同学：在2016学年第一学期中表现优秀，被评为三好学生。\", \"韶关学院\"); t1.display(); Citation t2=(Citation) t1.clone(); t2.setName(\"李四\"); t2.display(); } } /* 张三同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院 奖状拷贝成功！ 李四同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院 */ 责任链模式 责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。所以责任链将请求的发送者和请求的处理者解耦了。 职责链模式主要包含以下角色。 ​ 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 ​ 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请 求转给它的后继者。 ​ 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。 可以采用链表的方式来实现责任链 //抽象处理者 public abstract class Handler { private Handler next; public void setNext(Handler next){ this.next=next; } public Handler getNext(){ return next; } public abstract void handRequest(String s); } //具体处理者1 public class ConcreateHandler1 extends Handler { @Override public void handRequest(String s) { if (s.equals(\"one\")){ System.out.println(\"1进行处理\"); } else { if (getNext()!=null){ getNext().handRequest(s); } else { System.out.println(\"无法进行处理\"); } } } } //具体处理者2 public class ConcreateHandler2 extends Handler { @Override public void handRequest(String s) { if (s.equals(\"two\")){ System.out.println(\"2进行处理\"); } else { if (getNext()!=null){ getNext().handRequest(s); } else { System.out.println(\"无法进行处理\"); } } } } public class main { public static void main(String[] args) { // 组装责任链 Handler handler1=new ConcreateHandler1(); Handler handler2=new ConcreateHandler2(); handler1.setNext(handler2); // 提交请求 handler1.handRequest(\"two\"); } } 命令模式 如何将方法的请求者与实现者解耦？命令模式就能很好地解决这个问题。 在现实生活中，命令模式的例子也很多。比如看电视时，我们只需要轻轻一按遥控器就能完成频道的切换，这就是命令模式，将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。 命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。 命令模式包含以下主要角色。 ​ 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。 ​ 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 ​ 实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 ​ 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 //命令调用者 --\u003e调用命令 public class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void setCommand(Command command) { this.command = command; } public void call() { System.out.println(\"调用者执行命令command\"); command.execute(); } } //抽象命令 public interface Command { void execute(); } //具体命令---\u003e命令的接收者 public class ConcreteCommand implements Command { private Receiver receiver; public ConcreteCommand() { receiver = new Receiver(); } @Override public void execute() { receiver.action(); } } //命令的接受者 public class Receiver { public void action(){ System.out.println(\"接受者的action方法被调用\"); } } public class main { public static void main(String[] args) { Command cmd=new ConcreteCommand();//具体命令 Invoker invoker=new Invoker(cmd);//调用者 System.out.println(\"客户访问调用者的call方法\"); invoker.call(); } } /* 客户访问调用者的call方法 调用者执行命令command 接受者的action方法被调用 */ 【例1】用命令模式实现客户去餐馆吃早餐的实例。 分析：客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”","date":"2021-01-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:0","tags":null,"title":"设计模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["算法"],"content":"date: 2021-02-04T09:17:30+08:00 参考 可以采用动态规划的想法！ 第n个丑数$x_n$，它必然为一下三种情况之一: $$ x_n= \\left{ \\begin{array}{rcl} x_a \\times 2 \\ x_b \\times 3 \\ x_c \\times 5\\ \\end{array}\\right. $$ 其中$x_a , x_b ,x_c $是未知数。 为了保证不会遗漏某个丑数，$x_n$必然等于： $$ x_n=min{x_a \\times 2,x_b \\times 3,x_c \\times 5 } $$ 这里我们需要明确的是一个丑数乘上2或3或5还是一个丑数 这里因为我们要在${x_a \\times 2,x_b \\times 3, x_c \\times 5}$中挑选出最小的一个丑数，我们可以这样考虑，假设存在三个数组，分别用第一个丑数乘上2,3,5 nums2={1*2,2*2,3*2,4*2,5*2,6*2,8*2...} nums3={1*3,2*3,3*3,4*3,5*3,6*3,8*3...} nums5={1*5,2*5,3*5,4*5,5*5,6*5,8*5...} # 注意 7 不是丑数. # 2, 3, 5 这前 3 个丑数一定要乘以其它的丑数， 所得的结果才是新的丑数， 所以上例中没有出现 7*2, 7*3, 7*5 那么， 最终的丑数序列实际上就是这 3 个有序序列对的合并结果， 计算丑数序列也就是相当于 合并 3 个有序序列。 合并 3 个有序序列 合并 3 个有序序列， 最简单的方法就是每一个序列都各自维护一个指针， 然后比较指针指向的元素的值， 将最小的放入最终的合并数组中， 并将相应指针向后移动一个元素。 这也就是： class Solution { public: int nthUglyNumber(int n) { // .... dp[i] = min(min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);//将最小的放入最终的合并数组中 if (dp[i] == dp[p2] * 2) p2++; if (dp[i] == dp[p3] * 3) p3++; if (dp[i] == dp[p5] * 5) p5++; // ...... }; 合并过程中重复解的处理 nums2, nums3, nums5 中是存在重复的解的， 例如 nums2[2] == 32, nums3[1] == 23 都计算出了 6 这个结果， 所以在合并 3 个有序数组的过程中， 还需要跳过相同的结果， 这也就是为什么在比较的时候， 需要使用 3 个并列的 if… if… if… 而不是 if… else if… else 这种结构的原因。 当比较到元素 6 时， if (dp[i] == dp[p2] * 2)…if (dp[i] == dp[p3] * 3)… 可以同时指向 nums2, nums3 中 元素 6 的下一个元素。 最终的代码： class Solution { public int nthUglyNumber(int n) { int[] dp=new int[n];//设定一个动态数组 dp[0]=1;//初始化 int p2=0,p3=0,p5=0; for(int i=1;i\u003cn;i++){ dp[i]=Math.min(Math.min(dp[p2]*2,dp[p3]*3),dp[p5]*5); if(dp[i]==dp[p2]*2){ p2++; } if(dp[i]==dp[p3]*3){ p3++; } if(dp[i]==dp[p5]*5){ p5++; } } return dp[n-1]; } } ","date":"2021-01-02","objectID":"/%E4%B8%91%E6%95%B0/:0:0","tags":null,"title":"丑数","uri":"/%E4%B8%91%E6%95%B0/"},{"categories":["算法"],"content":"参考 \u003e\u003e\u003e 运算符会用0填充高位，这与 \u003e\u003e 不同，其会用符号位填充高位。不存在 \u003c\u003c\u003c 运算符 例1 class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { /* * 采用位运算的方式 * 利用n与1进行与操作，即可判定n的最后一位是否为1，如果为1，res加1，否则不加 * 然后将n右移一位，知道n=0 * */ int res=0; while (n!=0){ res+=(n\u00261); n=n\u003e\u003e\u003e1; } return res; } } 例2 class Solution { public int[] countBits(int num) { int[] res=new int[num+1]; for(int i=0;i\u003c=num;i++){ int n=i; while(n!=0){ res[i]+=(n\u00261); n=n\u003e\u003e\u003e1; } } return res; } } ","date":"2020-12-30","objectID":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/:0:0","tags":null,"title":"位运算的基本知识","uri":"/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},{"categories":["Java学习笔记"],"content":"Linux中tty是什么 tty：终端设备的统称。 tty一词源于Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘与显示器取代，所以现在叫终端比较合适。终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。 tty1～6是文本型控制台，tty7是X Window图形显示管理器。 在本地机器上可以通过Ctrl+Alt+F1（F1-F7键）切换到对应的登录控制台。 所谓的窗口环境就是：文字界面加上X窗口软件！文字界面一定是存在的，只是窗口界面软件看你要不要启动而已 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"快捷键 Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"帮助 1. –help 指令的基本用法与选项介绍。 2. man man 是 manual 的缩写，将指令的具体信息显示出来。 当执行 man date 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下： 代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. info info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。 4. doc /usr/share/doc 存放着软件的一整套说明文件。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:3","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"关机 1. who 在关机前需要先使用 who 命令查看有没有其它用户在线。 2. sync 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。 3. shutdown ## shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown halt #关机 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:4","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"PATH 可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:5","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"sudo sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。 ubuntu有以下方式切换到root身份 sudo+命令，输入当前用户密码后以root权限执行命令，有时间限制且仅限当前命令。 sudo -i，输入当前用户密码后以root权限登录shell，无时间限制。使用exit或logout退出。 su，输入root账户的密码后切换到root身份，无时间限制。su 用户名切换其它用户。 sudo su，效果同su，只是不需要root的密码，而需要当前用户的密码 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:6","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"包管理工具 RPM 和 DPKG 为最常见的两类软件包管理工具： RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。 与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:7","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"发行版 Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 RPM Red Hat Fedora / CentOS DPKG Ubuntu Debian ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:8","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"VIM VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 vi显示行号 按下 冒号 ： 输入set number 磁盘 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:0:9","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"磁盘结构 盘面（Platter）：一个磁盘有多个盘面 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道 扇区(Track Sector)：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理存储单位，目前主要有512bytes和4K两种大小 磁头（Head）：与盘面非常接近，能够将判别上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写） 制动手臂（Actuator arm）:用于在磁道中移动磁头 主轴（Spindle）：使得整个盘面转动。 下面将分别介绍 磁道（Track）如下图，数据存储在磁道上 扇区： 如何确定数据存储在硬盘上的哪一个位置，实现快速读写数据（这么多文件存在磁盘上该如何快速的找到需要读写的数据呢？） 有两种方式： ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:2:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"分区表 在写数据时，再将数据存储到磁道后，会将分区表中记录数据存储位置对应的扇区和簇，这能够大致的定位数据的位置 在读数据时，首先查找分区表，找到数据对应的存储位置并进行读取（通过移动磁头）。 磁盘的分区有两种方式：一种是限制较多的MBR分区，一种是较新且限制较少的GPT分区 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:3:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"MBR分区 MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 分区表：记录整个硬盘的分区状态，仅有4个分区，每个区段记录了该区段的驱动与结束的磁柱号码 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 假设上面的硬盘装置文件名为/dev/sda 时,那么这四个分区槽在 Linux 系统中的装置文件名如下所示, 重点在于档名后面会再接一个数字,这个数字与该分区槽所在的位置有关。 P1：/dev/sda1 P2: /dev/sda2 P3: /dev/sda3 P4: /dev/sda4 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:3:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"GPT分区 扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。 GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。 GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。 MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:3:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"开机检测程序 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:4:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"BIOS BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件或称为韧体,（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。 BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。 主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。（即双系统安装） ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:4:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"UEFI BIOS 不可以读取 GPT 分区表，而 UEFI 可以。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:4:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"磁盘的文件名 Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下： IDE 磁盘：/dev/hd[a-d] SATA/SCSI/SAS 磁盘：/dev/sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 假设上面的硬盘装置文件名为/dev/sda 时,那么这四个分区槽在 Linux 系统中的装置文件名如下所示, 重点在于档名后面会再接一个数字,这个数字与该分区槽所在的位置有关。 P1：/dev/sda1 P2: /dev/sda2 P3: /dev/sda3 P4: /dev/sda4 文件系统 在磁盘分区完毕后需要进行格式化，之后操作系统才能够使用这个文件系统。 为什么需要进行“格式化”？ ​ 因为每种操作系统所设定的文件属性/权限并不相同，为了存放这些文件所需的数据，因此需要将分区槽进行格式化，以成为操作系统能够利用的“文件系统格式” Linux的正统文件系统格式为Ext2；默认情况下windows操作系统是不会认识Linux的Ext2的。 一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:5:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"组成 Q：文件系统是如何运作的？（以Ext2为例） A：操作系统的文件数据除了文件实际内容外，通常具有非常多的属性，例如Linux操作系统的文件权限 （rwx）与文件属性（拥有者，群组，时间参数等）。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放置到inode中，至于实际数据则放置在data block区块中。另外还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。 文件系统一开始就将inode和block规划好了，除非重新格式化，否则inode和block固定后就不再变动。 Linux文件系统Ext2就是使用这种inode为基础的文件系统 inode: 记录权限和属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码； block ：实际数据，若文件太大，会占用多个block superblock：整个文件系统的整体信息 每个inode与block都有编号。同时inode内有文件数据放置的block号码。因此，如果能够找到文件的inode的话，就可以知道这个文件所放置数据的block号码，也就可以读到该文件的实际数据了。这能够提高文件读写的效率。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:6:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件读取 对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。这种数据读取的方式我们称为索引式文件系统。 而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。文件系统没有办法一下得知需要读取的block号码，因此需要一个一个将block读出后，才会知道下一个block在处。如果同一个文件写入的block过于分散，读取的效率就比较低。 碎片整理：需要碎片整理的原因就是同一个文件写入的block太过于离散，此时文件读取的效率很低，这个时候就可以通过碎片整理将同一个文件的block汇整到一起，这样数据的读取就会比较容易。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:7:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"碎片整理 指一个文件内容所在的 block 过于分散。 碎片整理：需要碎片整理的原因就是同一个文件写入的block太过于离散，此时文件读取的效率很低，这个时候就可以通过碎片整理将同一个文件的block汇整到一起，这样数据的读取就会比较容易。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:8:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"block 在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。 大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:9:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"inode inode 具体包含以下信息： 权限 (read/write/excute)； 拥有者与群组 (owner/group)； 容量； 建立或状态改变的时间 (ctime)； 最近读取时间 (atime)； 最近修改时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 inode 具有以下特点： 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 文件系统能够建立的文件数量与inode的数量相关 系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否相符，若符合才能够开始实际读取block的内容 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:10:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"superblock superblock是记录整个文件系统相关信息的地方，其记录的主要信息有： block与inode的总量 未使用与已使用的inode/block数量 block与inode的大小（block为1,2,4K,inode为128bytes或256bytes） 文件系统的挂载时间、最近一次写入数据的时间、最近一次检验磁盘的时间等相关信息 一个vaild bit数值，若此文件系统已被挂载，则vaild bit为0，若未被挂载则vaild bit为1. superblock的大小为1024bytes，可以通过dumoe2fs来查看 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:11:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"block bitmap 记录 block 是否被使用的位图。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:12:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"inode bitmap 记录inode 是否被使用的位图。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:13:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"目录的权限 建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。 可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。 文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:14:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"日志 如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。 ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:15:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"挂载 将文件系统与目录树结合的动作称为挂载 挂载点一定是目录 挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:16:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"链接 通过前面的学习可以得知： 每个文件都会占用一个inode，文件内容有inode的记录来指向 想要读取该文件，必须要经过目录记录的文件名来指向到正确的inode号码 即文件名只于目录有关，文件内容则和inode有关。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:17:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"实体链接（hard link） 在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 ## ln /etc/crontab . ## ll -i /etc/crontab crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 上图说明：我们可以通过inode 1或inode 2 找到对应的目录block，目录block中存储的文件名虽然不相同，但是存储的inode是相同的，所以都是指向同一个文件。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:17:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"符号链接(symbolic link) 符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 因为记录的是路径，所以可以为目录建立符号链接。 ## ll -i /etc/crontab /root/crontab2 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -\u003e /etc/crontab ln [-sf] 源文件 目标文件 -s ： 如果不加任何参数就进行链接，那就是hard link，而加上-s后就是symbolic link -f ： 如果目标文件存在时，就主动将目标文件直接移除后再建立 文件权限与目录配置 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:17:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件属性 Linux一般将文件可存取的身份分为三个类别，分别是Owner/group/others，且这三种身份各有read/write/execute等权限。 对于文件来说： r(read): 可以读取此文件的实际内容 w(write): 可以编辑、新增或修改文件内容（但是不可以删除） x(eXecute): 该文件具有可以被系统执行的权限 对于目录来说： r(read): 具有读取目录结构列表的权限；可以通过ls将该目录的内容列表显示出来 w(write): 具有异变该目录结构列表的权限； 创建文件与目录 删除文件和目录（无论该文件的权限是什么） 将文件和目录进行重命名 移动该目录中的文件、目录位置 x(eXecute): 表示用户能否进入该目录成为工作目录 我们以王三毛为例，王三毛这个“文件”的拥有者为王三毛，他属于王大毛这个群组，而张小猪相对于王三毛，则是一个“其他人（others）” 天神为“root”，可以到达任何想去的地方 使用ls -al查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小（默认单位为bytes） May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。（如果没有权限就用-表示） 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 再来一个例子： drwxrwxrwx 6 root root 4096 1月 1 15:13 ssl 目录名：ssl 最后修改时间1月 1 15:13 文件大小4096 所属群组：root 文件拥有者：root d表示这是个目录 rwxrwxrwx：表示文件拥有者，所属群组，其他都可对该目录进行读、写、执行操作 再来一个例子： 进入本目录要具备X权限 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:18:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"修改文件属性和权限 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"常用指令 chgrp : 改变文件所在群组 chown : 改变文件所有者 chmod : 改变文件的权限，SUID,SGID,SBIT等特性 注意：chown的使用 1.如果要连目录下的所有次目录或文件同时更改文件拥有者的话，直接加上 -R 的选项即可 2.可以同时修改文件拥有者和群组，使用‘ : ’ 3.可以单独修改群组，使用’ . ' chown -R ssl 12 root@ssl-H310M-S2:/home/ssl/桌面/12# ll 总用量 8 drwxr-xr-x 2 ssl ssl 4096 1月 2 14:16 ./ drwxr-xr-x 4 ssl ssl 4096 1月 2 14:16 ../ -rw-rw-r-- 1 ssl ssl 0 1月 2 14:00 12.txt chown root:root 12.txt -rw-rw-r-- 1 root root 0 1月 2 14:00 12.txt chown .ssl 12.txt -rw-rw-r-- 1 root ssl 0 1月 2 14:00 12.txt ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"使用数字来修改文件权限 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 。 r : 4 w : 2 x : 1 每种身份（owner/group/others）各自的三个权限(r/w/x)分数是需要累加的，例如当权限为-rwxrwx---分数为： owner = rwx = 4+2+1 =7 group = rwx = 4+2+1 =7 others = — =0+0+0 = 0 所以我们更改权限时： 之前的文件属性为：-rw-r--r-- 1 root ssl 0 1月 2 14:25 123.txt 变更文件属性： chmod 770 123.txt 变更后的文件属性： -rwxrwx--- 1 root ssl 0 1月 2 14:25 123.txt* ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"使用符号来设定权限 用符号表示 u : user –文件拥有者 g : group –群组 o : others –其他 a : all –全部的身份 例如当权限为-rwxrw----时： chmod u=rwx,g=rw 123.txt -rwxrw---- 1 root ssl 7 1月 2 14:38 123.txt* #使文件的每一个人均可写入 chmod a=w 123.txt --w--w--w- 1 root ssl 7 1月 2 14:38 123.txt #注意到使用'='会将其他的权限改变 #将文件的权限去掉而不改变其他的权限 chmod o-w 123.txt --w--w---- 1 root ssl 7 1月 2 14:38 123.txt #将文件的权限加上而不改变其他的权限 chmod o+w 123.txt --w--w--w- 1 root ssl 7 1月 2 14:38 123.txt ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:3","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件预设权限umask umask 0007 umask -R u=rwx,g=rwx,o= 注意umask的分数是该默认值需要减掉的权限。以上面为例子，因为umask为007所以权限为u=rwx,g=rwx,o=— 。 创建时，文件 默认666，目录默认777，减去umask的位就是结果。 umask用于当前用户在建立文件或目录时候的权限默认值。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:4","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件隐藏属性chattr chattr [+-] [选项] 选项： i:让文件无法被删除、改名、无法写入或新增数据 a:只能增加数据，不能删除页不能修改数据 root@ssl-H310M-S2:/home/ssl/桌面/12# chattr +i test44 #添加i隐藏属性 root@ssl-H310M-S2:/home/ssl/桌面/12# rm test44 #root也无法删除 rm: 无法删除'test44': 不允许的操作 root@ssl-H310M-S2:/home/ssl/桌面/12# chattr -i test44 #解除i隐藏属性 root@ssl-H310M-S2:/home/ssl/桌面/12# rm test44 root@ssl-H310M-S2:/home/ssl/桌面/12# lsattr（显示文件隐藏属性） ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:5","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件的特殊权限SUID，SGID，SBIT SUID： SUID权限仅对于二进制程序有效 执行者对于该程序需要具有X的可执行权限 本权限仅在执行该程序的过程中有效 执行者将具有该程序拥有者的权限 (base) ssl@ssl-H310M-S2:~/PycharmProjects$ ll /usr/bin/passwd -rwsr-xr-x 1 root root 54256 3月 27 2019 /usr/bin/passwd* 当s标志在文件拥有者的x位置时为SUID，当s在群组的x时为SGID 与SUID不同，SGID可以针对文件或目录来设定 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:19:6","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"目录配置 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： （FHS的重点在于规范每个目录下应该要放置什么样的数据） / (root, 根目录)：与开机系统有关 /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 所有目录都由根目录衍生出来，同时根目录也与开机/还原/系统修复等动作有关。 文件和目录管理 . 表示当前目录 .. 表示上层目录 所有目录底下都会有两个目录，分别是 . 与 .. 分别表示此层目录与上层目录 绝对路径和相对路径 绝对路径：一定从根目录/开始写起，例如/usr/share/local 相对路径：不是有/开始写起,例如cd ../man ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:20:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件与目录的基本操作 1. ls 列出文件或者目录的信息，目录的信息就是其中包含的文件。 ## ls [-aAdfFhilnrRSt] file|dir -a ：列出全部的文件 -d ：仅列出目录本身 -l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd 更换当前目录。 cd [相对路径或绝对路径] cd .. :返回上层目录 cd - :返回之前的目录 3. mkdir 创建目录。 ## mkdir [-mp] 目录名称 -m ：配置目录权限 -p ：递归创建目录 4. rmdir 删除目录，目录必须为空。 rmdir [-p] 目录名称 -p ：递归删除目录 5. touch 更新文件时间或者建立新文件。 ## touch [-acdmt] filename -a ： 更新 atime -c ： 更新 ctime，若该文件不存在则不建立新文件 -m ： 更新 mtime -d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\"日期或时间\" -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp 复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。 cp [-adfilprsu] source destination -a ：相当于 -dr --preserve=all -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身 -i ：若目标文件已经存在时，在覆盖前会先询问 -p ：连同文件的属性一起复制过去 -r ：递归复制 -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制 --preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm 删除文件。 ## rm [-fir] 文件或目录 -r ：递归删除 8. mv 移动文件。或重命名 ## mv [-fiu] source destination ## mv [options] source1 source2 source3 .... directory -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 mv 12.txt 45.txt #将文件12.txt重命名为45.txt 9.df df -h #查看目录挂载点 (base) wag@wag-SYS-7049GP-TRT:/home$ df -h 文件系统 容量 已用 可用 已用% 挂载点 udev 63G 0 63G 0% /dev tmpfs 13G 235M 13G 2% /run /dev/nvme0n1p2 916G 699G 171G 81% / tmpfs 63G 6.0G 57G 10% /dev/shm tmpfs 5.0M 4.0K 5.0M 1% /run/lock tmpfs 63G 0 63G 0% /sys/fs/cgroup /dev/nvme0n1p1 511M 3.7M 508M 1% /boot/efi tmpfs 13G 108K 13G 1% /run/user/1000 /dev/sda 3.6T 422G 3.0T 13% /home/ssl df -h [目录名] #查看目录挂载点 (base) wag@wag-SYS-7049GP-TRT:/home$ df -h ./wag 文件系统 容量 已用 可用 已用% 挂载点 /dev/nvme0n1p2 916G 699G 171G 81% / 10.du du -sh [目录或文件] #查看目录或文件的大小 (base) wag@wag-SYS-7049GP-TRT:/home$ du -sh ./wag du: 无法读取目录'./wag/.cache/dconf': 权限不够 237G ./wag ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:20:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"文件内容查阅 1. cat 从第一行开始显示文件内容。 ## cat [-AbEnTv] filename -n ：打印出行号，连同空白行也会有行号，-b 不会 cat 45.txt asdas asdas #附加打印行号 cat -n 45.txt 1 asdas 2 asdas 3 aasdas 2. tac 是 cat 的反向操作，从最后一行开始开始显示文件内容。 3. more 和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 more linux命令速查.md # 文件和目录 ~~~ cd /home #进入 '/ home' 目录' cd .. #返回上一级目录 cd ../.. #返回上两级目录 cd #进入个人的主目录 cd ~user1 #进入个人的主目录 cd - #返回上次所在的目录 pwd #显示工作路径 ls #查看目录中的文件 ls -F #查看目录中的文件 ls -l #显示文件和目录的详细资料 ls -a #显示隐藏文件 --更多--(4%) #此时可以使用的几个快捷键： 1.space ： 向下翻一页 2.enter : 向下翻一行 3. q : 离开 4. b : 往回翻页 4. less 和 more 类似，但是多了一个向前翻页的功能。 less linux命令速查.md # 文件和目录 ~~~ cd /home #进入 '/ home' 目录' cd .. #返回上一级目录 cd ../.. #返回上两级目录 cd #进入个人的主目录 cd ~user1 #进入个人的主目录 cd - #返回上次所在的目录 pwd #显示工作路径 ls #查看目录中的文件 ls -F #查看目录中的文件 ls -l #显示文件和目录的详细资料 ls -a #显示隐藏文件 linux命令速查.md #此时可以使用的几个快捷键 1. space ： 向下翻一页 2. pageup : 向上翻一页 3. pagedown : 向下翻一页 4. q : 离开 5. head 只看文件前几行。 ## head [-n number] filename -n ：后面接数字，代表显示几行的意思 head linux命令速查.md # 文件和目录 ~~~ cd /home #进入 '/ home' 目录' cd .. #返回上一级目录 cd ../.. #返回上两级目录 cd #进入个人的主目录 cd ~user1 #进入个人的主目录 cd - #返回上次所在的目录 #默认显示前10行，但是可以通过-n来修改,例如head -2 linux命令速查.md 只显示前两行 6. tail 是 head 的反向操作，只看文件的后几行。 7. od 以字符或者十六进制的形式显示二进制文件。 8.nl 显示的时候同时输出行号 nl 45.txt 1 asdas 2 asdas 3 aasdas ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:20:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"指令与文件搜索 1. which 指令搜索。 ## which [-a] command -a ：将所有指令列出，而不是只列第一个 root@ssl-H310M-S2:/home/ssl/桌面/12# which ls /bin/ls 2. whereis 文件搜索。速度比较快，因为它只搜索几个特定的目录。 whereis主要针对/bin/sbin底下的执行档，以及/usr/share/man底下的man page文件，跟几个比较特定的目录来处理。 ## whereis [-bmsu] dirname/filename root@ssl-H310M-S2:/home/ssl/桌面/12# whereis ifconfig ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz 3. locate 文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 ## locate [-ir] keyword -r：正则表达式 root@ssl-H310M-S2:/home/ssl/桌面/12# locate -l 5 passwd /etc/passwd /etc/passwd- /etc/cron.daily/passwd /etc/init/passwd.conf /etc/pam.d/chpasswd 4. find 文件搜索。可以使用文件的属性和权限进行搜索。 ## find [basedir] [option] example: find . -name \"shadow*\" ① 与时间有关的选项 -mtime n ：列出在 n 天前的那一天修改过内容的文件 -mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件 -mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件 -newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下： ② 与文件拥有者和所属群组有关的选项 -uid n #用户的账号ID -gid n #组名ID -user name #用户名 -group name #组名 -nouser ：搜索拥有者不存在 /etc/passwd 的文件 -nogroup：搜索所属群组不存在于 /etc/group 的文件 ③ 与文件权限和名称有关的选项 -name filename -size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k -type TYPE -perm mode ：搜索权限等于 mode 的文件 -perm -mode ：搜索权限包含 mode 的文件 -perm /mode ：搜索权限包含任一 mode 的文件 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:20:3","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"观察文件类型：file 了解文件的基本类型，例如是ASCII或者是data文件，或者是binary (base) ssl@ssl-H310M-S2:~/PycharmProjects$ file ~/.bashrc /home/ssl/.bashrc: ASCII text 文件的压缩和打包 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:20:4","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"压缩文件名 Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:21:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"压缩指令 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:22:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"1. gzip gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 $ gzip [-cdtv#] filename # -c ：将压缩的数据输出到屏幕上 -d ：解压缩 -t ：检验压缩文件是否出错 -v ：显示压缩比等信息 -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:22:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"2. bzip2 提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 $ bzip2 [-cdkzv#] filename -k ：保留源文件 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:22:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"3. xz 提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 $ xz [-dtlkc#] filename ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:22:3","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"打包 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。 $ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z ：使用 zip； -j ：使用 bzip2； -J ：使用 xz； -c ：新建打包文件； -t ：查看打包文件里面有哪些文件； -x ：解打包或解压缩的功能； -v ：在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename：要处理的文件； -C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 bash Linux中的命令行界面称为shell （图形界面称为GUI）。 bash shell（bash）是大多数Linux系统的默认shell，还用很多其他的shell ,例如ksh和csh。 文本模式登录后所取得的程序被称为壳（shell），这是因为这只程序负责最外面跟使用者（我们）打交道，所以被戏称为“壳” 在Linux中的shell为bash shell也只是一个普通的用户程序。它仅仅需要从键盘读取数据、向显示器输出数据和运行其他程序的能力。 可以将一系列shell命令放到一个文件中，然后将此文件作为shell的输入来运行。包含shell命令的文件称为shell脚本。 Linux的命令行用户界面（shell）中包含大量的标准应用程序。这些程序大致可以分为以下6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:23:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"内核结构 运行在硬件之上的为操作系统，其作用为控制硬件并且为其他程序提供系统调用接口。这些系统调用允许用户创立并管理进程、文件以及其他资源。 Linux具有三种不同的接口：真正的系统调用接口，库函数接口，由标准应用程序构成的接口。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:24:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"特性 命令历史：记录使用过的命令，快捷键：history 命令与文件补全：快捷键：tab 命名别名：例如 ll 是 ls -al 的别名 ，快捷键：alias shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:25:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"变量操作 对一个变量赋值直接使用 =。 对变量取用需要在变量前加上\"$” 也可以用 “​${}” 的形式； 输出变量使用 echo 命令。 $ x=abc $ echo $x $ echo ${x} 变量内容如果有空格，必须使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 x=\"lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG’，则 x 的值为 lang is $LANG。 可以使用 指令 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 (base) ssl@ssl-H310M-S2:~/桌面/12$ bash (base) ssl@ssl-H310M-S2:~/桌面/12$ exit exit (base) ssl@ssl-H310M-S2:~/桌面/12$ 可以通过env查看环境变量，也可以通过export来查看 (base) ssl@ssl-H310M-S2:~/桌面/12$ env XDG_VTNR=7 LC_PAPER=zh_CN.UTF-8 LC_ADDRESS=zh_CN.UTF-8 XDG_SESSION_ID=c2 XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/ssl LC_MONETARY=zh_CN.UTF-8 CLUTTER_IM_MODULE=xim ... 通过set观察所有变量（包括环境变量和自定义变量） 使用 export 命令将自定义变量转成环境变量 子程序仅会继承父程序的环境变量，子程序不会继承父程序的自定义变量。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： $ declare [-aixr] variable -a ： 定义为数组类型 -i ： 定义为整数类型 -x ： 定义为环境变量 -r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作： $ array[1]=a $ array[2]=b $ echo ${array[1]} ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:26:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"历史命令history history ：查看所有历史命令 ！num : 运行第[num]个命令 (base) ssl@ssl-H310M-S2:~/桌面/12$ history ... 2075 cat /bin/shells 2076 cat /etc/shells (base) ssl@ssl-H310M-S2:~/桌面/12$ !2076 cat /etc/shells # /etc/shells: valid login shells /bin/sh /bin/dash /bin/bash /bin/rbash ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:27:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内置的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:28:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"数据流重定向 重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 \u003c 或 « 标准输出 (stdout) 1 \u003e 或 » 标准错误输出 (stderr) 2 2\u003e 或 2» 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2\u003e\u00261 表示将标准错误输出转换为标准输出。 $ find /home -name .bashrc \u003e list 2\u003e\u00261 (base) ssl@ssl-H310M-S2:~/桌面/12$ cat 45link.txt #标注输出是直接输出到屏幕上的 asdas asdas aasdas (base) ssl@ssl-H310M-S2:~/桌面/12$ cat 45link.txt \u003e 56.txt #通过输出重定向操作可以将输出输出到指定位置 (base) ssl@ssl-H310M-S2:~/桌面/12$ cat 56.txt asdas asdas aasdas ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:29:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"双向输出重定向 输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 $ tee [-a] file ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:30:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"管道指令 管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。 在命令之间使用 | 分隔各个管道命令。 $ ls -al /etc | less ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:31:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"提取指令 cut 对数据进行切分，取出想要的部分。 切分过程一行一行地进行。 $ cut -d ：分隔符 -f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间 -c ：以字符为单位取出区间 示例 1：last 显示登入者的信息，取出用户名。 $ last root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33) root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16) $ last | cut -d ' ' -f 1 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。 $ export declare -x HISTCONTROL=\"ignoredups\" declare -x HISTSIZE=\"1000\" declare -x HOME=\"/home/dmtsai\" declare -x HOSTNAME=\"study.centos.vbird\" .....(其他省略)..... $ export | cut -c 12- ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:32:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"排序指令 sort 用于排序。 $ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。 $ cat /etc/passwd | sort -t ':' -k 3 root:x:0:0:root:/root:/bin/bash dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash alex:x:1001:1002::/home/alex:/bin/bash arod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。 $ uniq [-ic] -i ：忽略大小写 -c ：进行计数 示例：取得每个人的登录总次数 $ last | cut -d ' ' -f 1 | sort | uniq -c 1 6 (unknown 47 dmtsai 4 reboot 7 root 1 wtmp ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:33:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"字符转换指令 tr 用来删除一行中的字符，或者对字符进行替换。 $ tr [-ds] SET1 ... -d ： 删除行中 SET1 这个字符串 示例，将 last 输出的信息所有小写转换为大写。 $ last | tr '[a-z]' '[A-Z]' col 将 tab 字符转为空格字符。 $ col [-xb] -x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。 $ expand [-t] file -t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。 $ join [-ti12] file1 file2 -t ：分隔符，默认为空格 -i ：忽略大小写的差异 -1 ：第一个文件所用的比较字段 -2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。 $ paste [-d] file1 file2 -d ：分隔符，默认为 tab ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:34:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"分区指令 split 将一个文件划分成多个文件。 $ split [-bl] file PREFIX -b ：以大小来进行分区，可加单位，例如 b, k, m 等 -l ：以行数来进行分区。 - PREFIX ：分区文件的前导名称 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:35:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"grep 简单来说，正则表达式就是处理字符串的方法，他以行为单位来进行字符串的处理行为，可以让使用者轻易的达到“搜寻/删除/取代”某个特定字符串。 g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 $ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计匹配到行的个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） $ grep -n 'the' regular_express.txt 8:I can't finish the test. 12:the symbol '*' is represented as start. 15:You are the best is mean you are the no. 1. 16:The world Happy is the same with \"glad\". 18:google is the best tools for search keyword 示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。 $ grep -n 'a\\{2,5\\}' regular_express.txt ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:36:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"printf 用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 $ printf '%10s %5i %5i %5i %8.2f \\n' $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:37:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"awk 是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。 $ last -n 5 dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) $ last -n 5 | awk '{print $1 \"\\t\" $3}' dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai Fri 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 $ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 $ cat /etc/passwd | awk 'BEGIN {FS=\":\"} $3 \u003c 10 {print $1 \"\\t \" $3}' root 0 bin 1 daemon 2 awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段 $ last -n 5 | awk '{print $1 \"\\t lines: \" NR \"\\t columns: \" NF}' dmtsai lines: 1 columns: 10 dmtsai lines: 2 columns: 10 dmtsai lines: 3 columns: 10 dmtsai lines: 4 columns: 10 dmtsai lines: 5 columns: 9 进程管理 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:38:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"查看进程 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:39:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"1. ps 查看某个时间点的进程信息。 示例：查看自己的进程 ## ps -l 示例：查看系统所有进程 ## ps aux 示例：查看特定的进程 ## ps aux | grep threadx ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:39:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"2. pstree 查看进程树。 示例：查看所有进程树 ## pstree -A ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:39:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"3. top 实时显示进程信息。 示例：两秒钟刷新一次 ## top -d 2 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:39:3","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"4. netstat 查看占用端口的进程 示例：查看特定端口的进程 ## netstat -anp | grep port ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:39:4","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"进程状态 状态 说明 R running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。 D uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。 S interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。 Z zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。 T stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:40:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"SIGCHLD 当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:40:1","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"wait() pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:40:2","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"waitpid() pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:40:4","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:41:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"僵尸进程 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 账户管理 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:42:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"新建只能在控制台下登录的用户 使用此方法无法在图像界面看到自己的家目录 useradd [-u UID] [-g 初始群组] [-c 说明栏] [-d 家目录绝对路径] 使用者账号名 # -u ： UID，是一组数字 # -d : 制定某个目录成为家目录，使用绝对路径 psaawd [账号名称] #设定密码 userdel [账号名称] #删除账号 cat /etc/passwd #查看用户属性 test4:x:1003:1003:,,,:/home/test4:/bin/bash 用户名:[密码口令]:用户标识号:组标识号:注释性描述:用户主目录:命令解释程序 su test4 #切换用户 root@ssl-H310M-S2:/home# su test4 test4@ssl-H310M-S2:/home$ cd ~ test4@ssl-H310M-S2:~$ pwd /home/test4 test4@ssl-H310M-S2:~$ 可以看到登陆以后的用户test4当前所在目录仍为“/home”;这种方式只能在控制台中互相切换用户，一旦重启系统，用该用户还是无法登陆（只能用原来的用户或root登陆）。 ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:43:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":"新建可登录图形用户界面的用户 adduser [账号名] --- adduser [--home DIR] [--shell SHELL] [--no-create-home] [--uid ID] [--firstuid ID] [--lastuid ID] [--gecos GECOS] [--ingroup GROUP | --gid ID] [--disabled-password] [--disabled-login] [--encrypt-home] USER 添加普通用户 --- root@ssl-H310M-S2:/home# adduser test4 正在添加用户\"test4\"... 正在添加新组\"test4\" (1003)... 正在添加新用户\"test4\" (1003) 到组\"test4\"... 创建主目录\"/home/test4\"... 正在从\"/etc/skel\"复制文件... 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 正在改变 test4 的用户信息 请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y 两种方式最大的差别在于新建用户的命令不同，第一种是useradd, 第二种是adduser。相对应的，如果要删除用户，第一种的命令为userdel, 第二种是deluser. adduser：会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。 /etc/passwd - 使 用 者 帐 号 资 讯，可以查看用户信息 /etc/shadow - 使 用 者 帐 号 资 讯 加 密 /etc/group - 群 组 资 讯 /etc/default/useradd - 定 义 资 讯 /etc/login.defs - 系 统 广 义 设 定 /etc/skel - 内 含 定 义 档 的 目 录 参考 https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#linux 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 四 版 常见问题 Linux执行ls，会引起哪些系统调用（B,C,D） A.nmap B.read C.execve D.fork 任何shell都会执行 exec 和 fork, 而 ls会执行read cat -n file1file2 命令的意思是？ 把文件file1和file2连在一起，然后输出到屏幕上。 使用vi编辑某文件时，要将第7到10行的内容一次性删除，可以在命令模式下先将光标移到第7行，再使用（ B）命令 A.dd #删除光标所在的行 B.4dd # C.de D.4de ndd： 删除当前行开始的连续 n 行。 dd：删除光标所在行， n1,n2d： 删除n1到n2行，例如删除1到10行1,10d n，$d：删除从某行开始至文本末尾，例如删除第8行至末尾 8,$d linux命令执行成功后会返回 0 成功返回0，不成功返回不同的值 以下哪一个命令只查找源代码、二进制文件和帮助文件，而不是所以类型的文件？此命令查找的目录是由环境变量$PATH指定的 A.whereis B.whatis C.which D.apropos whereis 可查询二进制文件(-b)、帮助文档(-m)、源程序（-s），无选项时，返回所有结果，-u(除上述三种的其它文件) which 查看可执行文件的位置 whatis 查询命令有什么功能 apropos 搜索指定关键字的命令 有一个文件ip.txt，每行一条ip记录，共若干行，已排好序，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？（ B ） A.uniq -c ip.txt B.uniq -c ip.txt | sort -nr | head -n 3 C.cat ip.txt | count -n | sort -rn | head -n 3 D.cat ip.txt | count -n uniq命令：报告或删去重复行，加上`-c参数可以统计重复行出现的次数（放在每行开头）。 sort命令：对文本按行进行排序，-n参数表示根据数字大小排序；-r，对应英文单词是reverse，意思是反转排序结果，sort默认是从小到大排序，加上这个参数可以实现从大到小排序。 head命令：取文件的前一部分（默认输出前10行）。加-n [数字]可以指定到底是前几行。 把这三个命令的作用都搞懂，再加上一点 Linux管道符 的知识，这道题目也就很容易解决了。最好是自己动手在命令行下实践几次，加深印象，容易记牢。 假设一个文件ip,其中的内容为 10.249 10.249 10.249 10.249 10.249 10.249 10.256 10.256 10.126 10.126 10.126 10.126 10.555 (base) ssl@ssl-H310M-S2:~/桌面/12$ uniq -c ip #统计重复出现行的次数 6 10.249 2 10.256 4 10.126 1 10.555 (base) ssl@ssl-H310M-S2:~/桌面/12$ uniq -c ip | sort -nr #按照出现的次数降序排序 6 10.249 4 10.126 2 10.256 1 10.555 (base) ssl@ssl-H310M-S2:~/桌面/12$ uniq -c ip | sort -nr | head -n 3 #去除前三行 6 10.249 4 10.126 2 10.256 如何查看当前Linux系统的状态,如CPU使用,内存使用,负载情况，下列描述正确的是（A,B,C）？ A.可以使用top命令分析CPU使用，内存使用，负载等情况 B.可以使用free查看内存整体的使用情况 C.可以使用cat /proc/meminfo查看内存更详细的情况 top命令： Linux下常用的性能分析工具。能够实时显示系统中各个进程对资源的占用状况。 free命令： 可以显示Linux系统中空闲的、已用的物理内存及swap内存，及被内核使用的buffer。 df命令： 用于显示当前在Linux系统上的文件系统的磁盘使用情况的统计信息。 进程之间通信都有哪些方式？(A.B.C) A.共享内存 B.消息传递 C.系统管道 D.临界区 写出完成以下功能的Linux命令: 将文件xyz中的单词AAA全部替换为BBB (C) A.sed 's/AAA/BBB' xyz B.sed 's/AAA/BBB/g' xyz C.replace 's/AAA/BBB/p' xyz D.replace 's/AAA/BBB/d' xyz s表示替换命令，/AAA/表示匹配AAA，/BBB/表示把匹配替换成BBB，/g 表示一行上的替换所有的匹配。 sed ‘s/aaa/bbb/’ filea 将filea中的第一个aaa替换为bbb sed ‘s/aaa/bbb/g’ filea 将filea中的所有的aaa替换为bbb 这里有一点需要指出的是，这条命令并不能修改源文件的内容，而只是把替换后的文件内容输出，如若想改变原来文件的内容的话，可以使用如下命令： sed ‘s/AAA/BBB/g’ xyz \u003e xyz.tmp 如果系统的umask设置为244，创建一个新文件后，它的权限：（） -r---w--w- umask是从权限中“拿走”相应的位,且文件创建时不能赋予执行权限. 创建时，文件 默认666，目录默认777，减去umask的位就是结果。 软件项目存储于/ftproot，允许apache用户修改所有程序，设置访问权限的指令？ chmod 777 /ftproot ","date":"2020-12-28","objectID":"/linux%E7%9B%B8%E5%85%B3/:44:0","tags":null,"title":"Linux相关","uri":"/linux%E7%9B%B8%E5%85%B3/"},{"categories":["Java学习笔记"],"content":" package MapTest; import java.util.Iterator; import java.util.Map; import java.util.Set; import java.util.TreeMap; /** * ClassName: Maptest02 * Package: Maptest * Description: Map集合的遍历 * Datetime: 2020/10/4 下午9:01 * Author: shilongshen */ public class Maptest02 { public static void main(String[] args) { Map\u003cInteger, String\u003e map = new TreeMap\u003c\u003e(); map.put(1, \"hello\"); map.put(2, \"world\"); /* * 方式1：获取所有的key,通过遍历key来获取value * */ Set\u003cInteger\u003e keys = map.keySet();//KeySet()返回的是一个Set集合 for (Integer key : keys) {//通过foreach String value = map.get(key); System.out.println(\"key=\" + key + \" value=\" + value); } System.out.println(\"--------------\"); Iterator\u003cInteger\u003e it = keys.iterator(); while (it.hasNext()) {//通过迭代器 Integer key = it.next(); String value = map.get(key); System.out.println(\"key=\" + key + \" value=\" + value); } System.out.println(\"--------------\"); /* * 方式2：通过entrySet方式来遍历 * */ //Set\u003cMap.Entry\u003cInteger, String\u003e\u003e node = map.entrySet();//entrySet()返回一个Set集合，集合元素的类型是Map.Entry\u003c\u003e for (Map.Entry\u003cInteger, String\u003e n : map.entrySet()) { Integer key = n.getKey(); String value = n.getValue(); System.out.println(\"key=\" + key + \" value=\" + value); } System.out.println(\"--------------\"); Iterator\u003cMap.Entry\u003cInteger, String\u003e\u003e it2= node.iterator(); while (it2.hasNext()){ Map.Entry\u003cInteger, String\u003e node2= it2.next(); System.out.println(\"key=\" + node2.getKey() + \" value=\" + node2.getValue()); } System.out.println(\"----遍历----\"); map.forEach((key,value)-\u003e System.out.println(\"key=\"+key+\" value=\"+value)); } } ​ ","date":"2020-12-27","objectID":"/map%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/:0:0","tags":null,"title":"Map的遍历方式","uri":"/map%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"将字符串转换为字符： String str = \"42\"; char[] chars = str.toCharArray(); ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:1","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"去除字符串的空格： String trim //trim()方法移除字符串两侧(头尾)的空白字符(空格、tab键、换行符) String strip 1、trim()方法不足之处 trim()早在Java早期就存在，当时Unicode还没有完全发展到我们今天广泛使用的标准。 trim()方法移除字符串两侧的空白字符(空格、tab键、换行符) 支持Unicode的空白字符的判断应该使用isWhitespace(int)。 此外，开发人员无法专门删除缩进空白或专门删除尾随空白。 简单得说就是，trim()方法无法删除掉Unicode空白字符，但用Character.isWhitespace©方法可以判断出来。 2、strip()方法 JAVA11(JDK11)中的strip()方法，适用于字符首尾空白是Unicode空白字符的情况，通过一段代码来具体看一下， public static void main(String[] args) { String s = “\\t abc \\n”; System.out.println( “abc”.equals(s.trim()));//true System.out.println(“abc”.equals(s.trim()));//true Character c = ‘\\u2000’; String s1 = c + “abc” + c; System.out.println(Character.isWhitespace©);//true System.out.println(s1.equals(s1.trim()));//true，trim无法删除Unicdoe空白字符 System.out.println(“abc”.equals(s1.strip()));//true } 上面输出结果都是true， Character c = ‘\\u2000’;中’\\u2000’就是Unicdoe空白字符。 ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:2","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"切割字符串： String substring(int beginIndex, int endIndex) 得到的字符从beginIndex到endIndex-1 ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:3","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"构建字符串： StringBuilder build=new StringBuilder();//构造StringBuilder build.append(String s);//向StringBuilder中添加元素，可以是字符串或字符，也可以是其他值，具体请参照API build.append(char c); build.toString();//将StringBuilder转换为String ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:4","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"依次读取字符串中的字符： char charAt(int index) //例如： String str = \"42\"; char chars=str.charAt(0);//'4' ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:5","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"整型的极值： int max=Integer.MAX_VALUE;//2147483647 int min=Integer.MIN_VALUE;//-2147483648 ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:6","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"将字符串转换为数字： String str = \"42\"; int a=Integer.parseInt(str);//42 ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:7","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"将字符转换为字符串： tring str=String.valueOf('2'); 一、string 和int之间的转换 1、string转换成int :Integer.valueOf(\"12\") 2、int转换成string : String.valueOf(12) 二、char和int之间的转换 1、首先将char转换成string String str=String.valueOf('2') 2、转换 Integer.valueof(str) 或者Integer.PaseInt(str) Integer.valueof返回的是Integer对象，Integer.paseInt返回的是int ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:8","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"优先队列（堆）： //默认是小顶堆，即最小的值在根结点 //可以通过重写comparator,作为比较器传入构造函数中，将其修改为大顶堆 PriorityQueue\u003cInteger\u003e priorityQueue = new PriorityQueue\u003c\u003e(new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:9","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["Java学习笔记"],"content":"打印数组： int[] nums = {1, 3, -1, -3, 5, 3, 6, 7}; System.out.println(Arrays.toString(a)); ","date":"2020-12-27","objectID":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:10","tags":null,"title":"常用函数","uri":"/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["技术分享与记录"],"content":"参考 在服务器上安装不同版本的pytorch 先创建一个虚拟环境 conda create -n pytorch1.0 python=3.7 切换到该虚拟环境(这样就不会影响原有的环境了) conda activate pytorch1.0 方法一： conda install pytorch=1.0.0 torchvision -c pytorch 这样就会安装 Collecting package metadata (current_repodata.json): done Solving environment: done Please update conda by running $ conda update -n base -c defaults conda ## Package Plan ## environment location: /home/wag/anaconda3/envs/pytorch1.0 added / updated specs: - pytorch=1.0.0 - torchvision The following NEW packages will be INSTALLED: blas anaconda/pkgs/main/linux-64::blas-1.0-mkl cffi anaconda/pkgs/main/linux-64::cffi-1.14.4-py37h261ae71_0 freetype anaconda/pkgs/main/linux-64::freetype-2.10.4-h5ab3b9f_0 intel-openmp anaconda/pkgs/main/linux-64::intel-openmp-2020.2-254 jpeg anaconda/pkgs/main/linux-64::jpeg-9b-h024ee3a_2 lcms2 anaconda/pkgs/main/linux-64::lcms2-2.11-h396b838_0 libpng anaconda/pkgs/main/linux-64::libpng-1.6.37-hbc83047_0 libtiff anaconda/pkgs/main/linux-64::libtiff-4.1.0-h2733197_1 lz4-c anaconda/pkgs/main/linux-64::lz4-c-1.9.2-heb0550a_3 mkl anaconda/pkgs/main/linux-64::mkl-2020.2-256 mkl-service anaconda/pkgs/main/linux-64::mkl-service-2.3.0-py37he8ac12f_0 mkl_fft anaconda/pkgs/main/linux-64::mkl_fft-1.2.0-py37h23d657b_0 mkl_random anaconda/pkgs/main/linux-64::mkl_random-1.1.1-py37h0573a6f_0 ninja anaconda/pkgs/main/linux-64::ninja-1.10.2-py37hff7bd54_0 numpy anaconda/pkgs/main/linux-64::numpy-1.19.2-py37h54aff64_0 numpy-base anaconda/pkgs/main/linux-64::numpy-base-1.19.2-py37hfa32c7d_0 olefile anaconda/pkgs/main/linux-64::olefile-0.46-py37_0 pillow anaconda/pkgs/main/linux-64::pillow-8.0.1-py37he98fc37_0 pycparser anaconda/pkgs/main/noarch::pycparser-2.20-py_2 pytorch pytorch/linux-64::pytorch-1.0.0-py3.7_cuda9.0.176_cudnn7.4.1_1 six anaconda/pkgs/main/linux-64::six-1.15.0-py37h06a4308_0 torchvision pytorch/noarch::torchvision-0.2.2-py_3 zstd anaconda/pkgs/main/linux-64::zstd-1.4.5-h9ceee32_0 注意 #此命令会安装 pytorch pytorch/linux-64::pytorch-1.0.0-py3.7_cuda9.0.176_cudnn7.4.1_1 所以会直接安装pytorch1.0.0 这个命令也会直接将安装cuda9.0.176和cudnn7.4.1_1（具体的原因不清楚），所以后面也不用重新安装与pytorch对应的cuda版本了。 注：这种方法是通过conda安装的不完整CUDA 常用指令： 检查PyTorch版本 torch.__version__ # PyTorch version torch.cuda.is_available()#是否能够使用cuda加速 torch.version.cuda # Corresponding CUDA version torch.backends.cudnn.version() # Corresponding cuDNN version torch.cuda.get_device_name(0) # GPU type 更新：采用上述方法似乎有点问题，报错 RuntimeError: cuda runtime error (11) : invalid argument at /opt/conda/conda-bld/pytorch_1544176307774/work/aten/src/THC/THCGeneral.cpp:405 vi ~/.bashrc source ~/.bashrc ","date":"2020-12-25","objectID":"/ubuntu-%E7%BB%99%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACpytorch%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9Acuda%E7%89%88%E6%9C%AC/:0:0","tags":null,"title":"给不同版本Pytorch指定特定CUDA版本","uri":"/ubuntu-%E7%BB%99%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACpytorch%E6%8C%87%E5%AE%9A%E7%89%B9%E5%AE%9Acuda%E7%89%88%E6%9C%AC/"},{"categories":["深度学习论文阅读笔记"],"content":"Dance Dance Generation: Motion Transfer for Internet Videos 该文章可以实现在复杂背景下的pose transfer。 In summary, our contributions include the following. We demonstrate personalized motion transfer on videos from the Internet. We propose a novel two-stage frame-work to synthesize people performing new movements and fuse them seamlessly with background scenes. （主要贡献：实现复杂背景下的姿态转换） We perform qualitative and quantitative evaluations validating the superiority of our method over existing state-of-the-art. method: (主要的思想是先将利用语义分割图将前景中的人物进行分割，采用STN 将前景人物与目标人物进行对齐。随后通过阶段进行修正） 利用语义分割图将前景中的人物进行分割，采用STN 将前景人物与目标人物进行对齐。 Human synthesis net：将对齐的body parts与target pose 作为输入，对body parts进行修正，并得到前景mask fusion net：将body parts + background +target pose 作为输入，进行前景和背景的融合，实现复杂背景下的pose transfer 这里需要注意的点; 如何保证生成视频帧在时间上是平滑的？方法: target pose采用多帧的姿态表示作为输入。 存在的问题： 当source person和target person将的body shape 存在较大差异时，可能生成的结果就不那么理想了。 TransMoMo: Invariance-Driven Unsupervised Video Motion Retargeting 难点： 1.原图像和目标图像间存在较大的结构和视角变化 2.难以构建合适的训练对进行训练 3.human motion的变化是复杂的。 解决思路: 三阶段网络：（这使得我们能够更加的关注motion retarget，其中步骤1,步骤3是直接采用现有最好的方法即可） 1.skeleton extraction 2.motion retarget（主要贡献处：invariance-driven disentanglement） 3.skeleton-to-video rendering 为了解决第2和第3个难点，利用了三个因素的不变性质：structure（表示体型），motion（表示姿态），view-angle（表示相机视角）。具体来说： 1.当structure 和 view-angle变化时，motion是不变的 2.当view-angle变化时，structure是不变的，同时structure不会随着时间的变化而变化 3.当structure变化时，view-angle是不变的，同时view-angle不会随着时间的变化而变化 这些不变特性使得我们能够设计一些无监督函数来将skeleton解耦成三个正交的隐变量：structure，motion，view-angle。 可以通过mix来自不同skeleton的structure（原图像的structure，即原人物体型）和motion（目标图像的motion，即目标姿态）来实现motion retarget; 通过在decoder阶段采用不同的view-angle来实现不同视角下的motion retarget 网络结构： 具体的实施步骤： 通过现有的姿态提取器提取source video中人物姿态（多帧）以及提取target video中人物姿态（多帧）。 motion retarget network中由encoder 和 decoder组成，encoder将skeleton通过三个独立的解码器进行解码，得到view-angle code 、motion code和structure code。 [将source video中的motion code和target video 中的 structure code结合以及任取一个view-angle code（用于实现视角变化] 经过decoder进行解码，得到一个3D的，可以具有不同视角的 Retargeted skeleton code ，最后再将这个3D Retargeted skeleton code映射为2D Retargeted skeleton 将和 target video中人物的纹理通过skeleton-to-video rendering渲染到Retargeted skeleton 上。实现motion transfer task 在motion retarget network中的网络细节： 输入是一个skeleton 序列（多帧）：$x \\in \\mathbb{R}^{T \\times 2N}$ 。$T$表示帧数，$N$表示骨骼点。encoder分为三个部分 motion encoder： 结构：several layers of one dimensional temporal convolution 。输出$E_m(x)=m \\in \\mathbb{R}^{M \\times C_m}$。$M$表示帧数，$C_m$表示通道数 structure encoder：结构：several layers of one dimensional temporal convolution+ temporal max pooling。输出：$\\bar{E}_s(x)=\\bar{s} \\in \\mathbb{R}^{C_s} =pool(s)$ 其中 $E_s(x)=s \\in \\mathbb{R}^{M \\times C_s}$ view-angle encoder: 结构：several layers of one dimensional temporal convolution+ temporal max pooling。输出：$\\bar{E}_v(x)=\\bar{v} \\in \\mathbb{R}^{C_v} =pool(s)$ 其中 $E_v(x)=v \\in \\mathbb{R}^{M \\times C_v}$ 将$m,\\bar{s},\\bar{v}$进行组合，经由decoder得到3D Retargeted skeleton code：${\\large{\\hat{X}}}=G(m,\\bar{s},\\bar{v}) \\in \\mathbb{R}^{T \\times 3N}$ 本文的关键点在于如何确保通过motion retarget network提取的structure（表示体型），motion（表示姿态），view-angle（表示相机视角）是解耦的。（skeleton -\u003e structure，motion，view-angle） 结构变化处理： 将输入的skeleton进行缩放处理。 视角变化处理： 将输入的skeleton进行360度视角转换 现在要通过loss term保证前面提到的三个不变特性： 1.当structure 和 view-angle变化时，motion是不变的 2.当view-angle变化时，structure是不变的，同时structure不会随着时间的变化而变化 3.当structure变化时，view-angle是不变的，同时view-angle不会随着时间的变化而变化 1. Invariance of motion Cross Reconstruction Loss ​ Structural Invariance Loss Rotation Invariance Loss 2.Invariance of Structure Triplet Loss（确保structure 不随时间变化，这个不太理解） Rotation Invariance Loss 3.Invariance of View-Angle Triplet Loss（确保view-angle不随时间变化，这个不太理解） Structural Invariance Loss 可能存在的一些问题： 仅仅从skeleton的角度进行处理，并没有显示的考虑纹理信息（即没有考虑skeleton与纹理之间的对齐问题）。从这一角度出发是不是可以进行优化。 生成结果的时间连续性上的处理是采用多帧的skeleton进行输入。 Deep Spatial Transformation for Pose-Guided Person Image Generation and Animation 该文首先基于图像设计了一种新颖的网络框架，随后又将其拓展到视频生成（主要加上了skeleton降噪处理时间平滑性处理） 这里只介绍video-based person generation 第一部分为skeleton的降噪处理。 作者认为通过现有方法（如openpose）提取出来的skeleton的表示并不精确，因此首先对提取出来的skeleton进行降噪处","date":"2020-12-19","objectID":"/video-based-pose-transfer-method/:0:0","tags":null,"title":"video-based pose transfer method","uri":"/video-based-pose-transfer-method/"},{"categories":["深度学习论文阅读笔记"],"content":"Method 首先因为没有完美的监督信息，所以文章借鉴了monkey-net的训练方法：用同一个视频同时作为source image和driving video来利用本身作为监督信息，这类似于一种自监督的学习机制。然后文章提出的方法大概包括以下三个模块： ","date":"2020-12-19","objectID":"/video-based-pose-transfer-method/:1:0","tags":null,"title":"video-based pose transfer method","uri":"/video-based-pose-transfer-method/"},{"categories":["深度学习论文阅读笔记"],"content":"Local Affine Transformations for Approximate Motion Description 这个部分的理解我们首先需要考虑一个非常简单的问题：如何用一种最naive的方法来借助driving video中的关键点帮助调整source image中的motion？这个问题的解答可能会让人想到一种简单的映射函数:R2-\u003eR2，也就是将一个帧里的像素映射到另一帧里面去，这种思想非常类似于inpainting里面的examplar的方法：像素迁移，这种映射关系在光流场中被称为后向光流场。 但是作者没有直接地将D映射到S，而是假设了一种中间的reference帧来帮助建立过渡关系，这一篇的独到之处在于用local affine transformations来逼近运动的表述，也就是用泰勒展开来逼近于关键点在空间的位移，关键点和仿射系数都是由关键点检测的网络来输出。 我对于这一步的理解其实很像光流的计算原理： 也就是说可以用关键点的位置加上一个映射的仿射系数和无穷小量来表示运动之后的关键点的位置，其中关键点就是当前的位置信息，然后映射系数就是motion信息，最后无穷小量可以被忽略不计。 当然这一步我觉得是需要基于一个物理假设的就是每一个关键点对应的一个刚体，其上的运动是一样的，然后就是可以用泰勒展开的方法来逼近这个刚体部分的运动。（文章提到了monkey-net其实就是只用了零阶的泰勒展开，而本文进一步优化提出了一阶的泰勒展开） ","date":"2020-12-19","objectID":"/video-based-pose-transfer-method/:1:1","tags":null,"title":"video-based pose transfer method","uri":"/video-based-pose-transfer-method/"},{"categories":["深度学习论文阅读笔记"],"content":"Occlusion-aware Image Generation 第二步是由上一步预测得到的关键点和仿射系数来预测一个更加dense的光流场变化，并输出一个occlusion mask来指示哪个区域直接transfer哪个区域需要inpainting。 然后就是生成器首先用上一步预测得到的dense的光流场来warp source图像，并结合那些occlusion的区域进行inpainting得到最终的输出。 DwNet: Dense warp-based network for pose-guided human video generation ​ Cross-Identity Motion Transfer for Arbitrary Objects Through Pose-Attentive Video Reassembling 贡献： 基于warp的方法能够解决解决较小的形变问题，但是还是存在一下几点问题： ​ 1.难以构建大的、复杂的位移 ​ 2.不能够使用多个原图像进行生成(使用多个原图像同时进行生成可以起到相互补充的作用) 之前的方法仅仅使用一张原图像进行生成。当原图像和目标图像之间存在较大的形变时，就会出现生成图像和目标图像之间无法存在一一对应的关系，导致生成的结果差；通过使用多张原图像可以起到相互补充的作用(可以利用多张原图像的外观) 采用交叉训练的方式，这能够使其进行不同外观物体之间的motion transfer Pose-Dependent Appearance Embedding 提取图像的姿态编码和外观编码 Pose-Attentive Retrieval Block 使用注意力机制来融合多个原图像的外观信息 Image Generation 考虑背景的影响，单独使用一个自编码器学习背景信息。最后再将其融合进前景中 训练方式 训练方式分为了重构训练和交叉训练 重构损失 交叉损失 总的损失函数 推理阶段 本文存在的最大的一个问题在于是一张一张的生成图像，并没有考虑帧与帧之间的连续性,即一帧一帧的生成图像-\u003e可以考虑处理帧与帧之间的连续性 还有一个问题就是只在一个维度的特征空间中进行attention的融合，可以考虑多维度的融合 ","date":"2020-12-19","objectID":"/video-based-pose-transfer-method/:1:2","tags":null,"title":"video-based pose transfer method","uri":"/video-based-pose-transfer-method/"},{"categories":["Java学习笔记"],"content":"网络基础知识 TCP/IP是通信协议的统称 TCP/IP就是IP,TCP,HTTP等协议的集合。 简单的说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。两台计算机之间必须能够支持相同的协议，并准守相同协议进行处理，这样才能实现相互通信。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:0:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"分组交换协议 分组交换协议是指将大数据分割成一个个叫做包的较小单位进行传输的方法。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"协议的分层 每个分层都接受由它下一层所提供的特定服务，并且负责为它的上一层提供特定的服务。上下层之间进行交互时所遵守的约定称为接口。同一层之间的交互叫做“协议”。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"传输方式的分类 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"面向有连接型与面向无连接型 通过网络发送数据可以大致分为面向有连接型与面向无连接型。 面向有连接型：字发送数据数据之前，需要在收发主机之间建立一条通信线路。就好比人们平常打电话 （如TCP协议） 面向无连接型：不要求建立和断开连接。发送端可以在任何时候自由发送数据。反之，接收端也永远不知道自己会在何时收到数据。因此在面向无连接型时，接收端常常需要确认是否接收到数据。就好比去邮局寄包裹 （如UDP协议，IP协议） ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:3:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"电路交换和分组交换 网络通信方式大致可以分为两种：电路交换和分组交换。 电路交换历史久远，主要用于过去的电话网 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 分组交换则是比较新的通信技术，TCP/IP则是采用了分组交换技术（重点介绍）。 让连接到通信电路的计算机将所要发送的数据分为多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。有了分组交换，数据被细分之后，所有计算机就可以一齐收发数据。 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:3:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"地址 TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。甚至在应用层中，可以使用电子邮件地址作为网络通信的地址。 地址应该具有唯一性和层次性 MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是其中只有IP具有层次性。 TCP/IP的基础知识 参考 互联网进行通信时需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族。 因此互联网的协议就是TCP/IP，TCP/IP就是互联网的协议。 http是应用层协议，tcp是传输层协议，IP是网络层协议，不是同一层的协议，协议是一层层打包的。 像这样**［以太［IP［TCP［http［应用数据］］** ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:4:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"OSI与TCP/IP的区别和联系 ISO制定了OSI模型，OSI参考模型中各个分层的作用： ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员（IEFT）自己开发的TCP/IP协议栈获得了更为广泛的应用。如图所示，是TCP/IP参考模型和OSI参考模型的对比示意图。 TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和主机到网络层。 在TCP/IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络接口层。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:5:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网络7层协议，4层，5层？ 7层指OSI模型，包括物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 4层指TCP/IP，包括网络接口层、网络层、传输层、应用层 5层只是OSI和TCP/IP的综合，是业界产生出来的非官方协议模型，但是很多具体的应用。实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。五层体系结构包括：物理层、数据链路层、网络层、传输层、应用层、。 下面将针对“5层”进行介绍 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:6:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP/IP分层模型与通信示例 每个分层中都会对所发送的数据附加一个首部，在这个首部中包含了必要的信息 网络中传输的数据包由两部分组成：一部分是协议要用到的首部，另一部分是上层传过来的数据。 在数据包的首部明确表明了协议应该如何读取数据。 TCP/IP各层对邮件的收发处理： 每个包首部至少都会有两个信息：一个是发送端和接收端地址（以太网会用MAC地址，IP会用IP地址，TCP会用端口号，即使是应用程序，也会用电子邮件这样的信息作为一种地址标识）；另一个是上层协议的协议类型（一个标识位，用来标识上一层的协议信息）。 什么是端口 分层中的包信息： 1.物理层（硬件） ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:7:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"bit,byte,帧的区别和联系 1byte=8bit 在网络中，网络设备将“bit”组成一个个的byte，然后这些字节“封装”成帧，在网络上传输。为什么要把数据“封装”成帧呢？因为用户数据一般都比较大，有的可以达到MB字节，一下子发送出去十分困难，于是就需要把数据分成许多小份，再按照一定的次序发送出去。 以太网的帧值总是在一定范围内浮动，最大的帧值是1518字节，最小的帧值是64字节。在实际应用中，帧的大小是由设备的MTU（最大传输单位）即设备每次能够传输的最大字节数自动来确定的。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:8:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"物理层的任务 物理层是TCP/IP中最底层、负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。 物理层的上一层为数据链路层，接收来自数据链路层发送来的数据帧，将数据帧转换为数据比特流。 计算机以二进制0,1来表示信息，然而实际的通信媒介之间处理的却是电压的高低、光的闪灭以及电波的强弱等信号。把这些信号转换成0,1信号的正是物理层。 物理层需考虑怎样才能在连接各种计算机的传输媒介上传输数据比特流，而不是指具体的传输媒体。硬件设备、传输媒介种类、通信手段多样，物理层要屏蔽掉这些差异，使上面的数据链路层感受不到这些差异，这样数据链路层能只管如何完成本层的协议和服务。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:9:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"中继器 中继器是物理层延长网络的设备（通过中继器进行网络延长）。由电缆传来的信号经由中继器的波形调整和方法再传给另一个电缆。 除此之外只具有中继器功能的HUB称为集线器，也是物理层设备 2.数据链路层 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:10:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"计算机网络的连接方式 计算机网络是指计算机与计算机连接组成的网络，现实中计算机是通过电缆相互连接的。根据数据链路的不同选用的电缆类型也不相同。而媒介本身也可以分为电波、微波等不同类型的电磁波。 LAN：局域网; WAN:广域网 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:11:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网卡 任何一台计算机连接网络时，都必须使用网卡（网络接口卡NIC），也被称为网络适配器、LAN卡 明确： 我们可以将数据链路层视为视为让网卡起作用的“驱动程序”。驱动程序是在操作系统与硬件之间起到桥梁作用的软件。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:12:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"MAC地址 MAC地址由设备的制造厂商针对每块网卡进行分别的指定。 人们可以通过制造商内部产品编号唯一确定MAC地址。但是却无法确定哪家场商的哪个网卡被用在了哪个地方（不具有层次性）。 MAC地址用于识别数据链路中互连的节点。 用于表示同一链路中不同计算机的一种标识 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:13:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网桥 数据链路层上连接两个网络的设备。它能够识别数据链路中的数据帧，并将这些数据帧临时存储与内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。 数据链路的数据帧中有一个数据位叫做FCS，用于校验数据是否正确送达目的地。网桥通过检查这个这个域中的值，将那些损坏的数据丢弃，从而避免发送给其他网段。此外，网桥还能够通过地址自学机制和过滤功能控制网络的流量 这里所说的地址是指MAC地址、硬件地址、物理地址以及适配器地址，也就是针对网卡分配的具体地址。 网桥的自学功能：根据源MAC地址进行自学 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:14:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"数据链路层的作用 数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括了双绞线电缆、同轴电缆、光纤、电波等介质。 计算机以二进制0,1来表示信息，然而实际的通信媒介之间处理的确是电压的高低、光的闪灭以及电波的强弱等信号。把这些信号转换成0,1信号的正是物理层。数据链路层的数据也不是单纯的0,1信号，而是将他们集合成一个称为“帧”的块，再进行传输。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:15:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"信道复用技术 频分多路复用 Frequency-division multiplexing，FDM 波分多路复用 Wavelength Division Multiplexing, WDM 时分多路复用 Time-Division Multiplexing，TDM 码分复用 (Code Division Multiplexing)，CDM 空分多路复用 Space Division Multiplexing, SDM ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:16:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"共享介质型网络 从通信介质的使用方法上来看，网络可以分为共享介质型和非共享介质型。 共享介质型就是多个设备共享同一个通信介质的一种网络。在这种方式下，设备之间使用同一个载波信道进行发送和接收，基本采用半双工通信方式。 共享介质型网络有两种介质访问控制方式：争用方式和令牌传递方式。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:17:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"争用方式 也称为CSMA（载波监听多路访问） 这种方式采用先到先得的方式占用信道发送数据 这种方式如果多个站同时发送帧，会产生冲突现象。 改良的CSMA方式-CSMA/CD方式 CSMA/CD CSMA/CD要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道，原理： 如果载波信道上没有数据流动，则任何站可以发送数据 检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立刻释放信道 放弃发送后，随机等待一段时间，再重新抢占介质，重新发送帧。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:17:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"令牌传递方式 令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文。是控制传输的一种方式。只有获得令牌的站才能够发送数据。 两个特点： 不会冲突 每个站有平等循环获得令牌的机会。因此，即使网络拥堵也不会导致性能下降 在网络不拥堵的情况下利用效率不高。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:17:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"非共享介质型网络 网络中的每个站直连交换机，由交换机来负责转发数据帧。此方法中，发送端和接收端不共享通信介质，可以采用全双工的方式进行通信 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:18:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"半双工和全双工通信 半双工指，在某一时刻只能够发送或者只能够接收的通信方式。类似于无线电收发器 全双工指，在某一时刻既可以发送数据页可以接收数据的通信方式，类似于电话 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:19:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"根据MAC地址转发 以太网交换机（也称为交换集线器，交换机的每一个端口可以看成是一个网桥），这是一种将非介质共享型网络中所使用的交换机用在以太网中的技术。 以太网交换机就是持有多个端口的网桥。它们根据数据链路层中每个帧的目标MAC地址，决定从哪个网络端口发送数据。这时所参考的，用于记录发送接口的表就叫做转发表。 转发表的内容是自动生成的。 数据链路层中的每个通过点在接到包时，会从中将源MAC地址以及曾经接收地址发送的数据包的接口作为对应关系记录在转发表中。（根据源MAC地址进行自学） 以某个MAC地址作为源地址的包有某一接口接收，实质上可以理解为该MAC地址就是该接口的目标 换句话说，以该MAC地址作为目标地址的包，经由该接口送出即可。 这一过程称为自学过程。 交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入转发表中。为了发送数据帧到 B，先查转发表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:20:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"以太网 以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:21:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"以太网帧格式 以太网的帧的前端有一个叫做前导码的部分，表示一个一台网帧的开始，也是对端网卡能够确保与其同步的标志。 以太网帧本体的前端是以太网的首部。共14个字节。然后是数据，帧尾是FCS。 目标MAC地址：目标工作站物理地址 源MAC地址：发送端工作站物理地址 类型：表明以太网上一层：网络层，的协议类型 FCS：用于检查帧是否损坏。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:21:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"PPP PPP (point-to-point protocol) 指点对点连接计算机的协议。相当于位于数据链路层。 PPP与以太网和FDDI不同，后两者不仅与数据链路层有关，还与物理层有关。具体来说，以太网使用同轴光缆或双绞线光缆，它可以决定其中的0,1信号被解释为何种电子信号。 而PPP属于纯粹的数据链路层，与物理层没有关系。换句话说，仅有PPP无法实现通信，还需要物理层的支持。 互联网用户通常需要连接到某个 ISP （互联网供应商）之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:22:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"PPP的帧格式 每个帧的前后加上8为字节“01111110”用于区别帧，称为标志码 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:22:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"信道分类 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:23:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"广播信道 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:23:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"点对点信道 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:23:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 3.网络层 IP : 是跨越网络传送数据包，使整个互联网都能收到数据的协议 虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此属于非可靠性传输协议 ICMP : IP数据包在发送过程中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能制定的。它有时页用于诊断网络的健康状况 ARP ： 从分组数据包的IP地址中解析出物理地址（MAC）地址的一种协议 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:23:3","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址 IP地址由网络号和主机号两部分组成。 两个主机即使主机号不同，但是网络号相同，这说明了它们处于同一网段。通常处于同一网段的主机也都属于同一个部门或集团组织。这位IP寻址带来了极大的方便。因此IP地址具有层次性。 连接到网络中的所有主机用于通信的目标地址 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:24:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"主机，路由器和节点的区别 主机：配置有IP地址，但是不进行路由控制（中转分组数据包）的设备 路由器：既配有IP地址又具有路由控制功能的设备 节点：主机和路由器的统称 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:24:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"路由器 路由器是网络层上连接两个网络、并对分组报文进行转发的设备。网桥是根据物理地址（MAC地址）进行处理，而路由器则是根据IP地址进行处理的。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:25:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"路由器的结构 路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:26:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"路由器的分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N（即网络标识，网路标识相同的计算机必须属于同一链路）。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:27:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"路由选择协议 路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:28:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网络层和数据链路层的关系 数据链路层的主要作用是在互连同一种数据链路的结点间进行包传递。而一旦跨越多种数据链路就需要借助网络层。网络层可以跨越不同的数据链路进行数据包的传输。 数据链路层提供直连两个设备之间的通信功能 网络层负责在没有直连的两个网络之间进行通信传输。 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:29:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP基础知识 IP大致分为三个作用模块 IP寻址 路由（最终节点为止的转发） IP分包与组包 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:30:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址属于网络层 在TCP/IP通信中的所有主机和路由器都必须配置IP地址 无论主机和哪种形式的数据链路相连，其IP地址的形式都不会改变。以太网、无线局域网、PPP等，都不会改变IP地址的形式 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:30:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"路由控制 路由控制是指将分组数据发送到最终目标地址的功能。 多跳路由 “跳”：网路中的一个区间 IP路由又称为多跳路由，指路由器或主机在转发数据包时，只指定下一个路由器或主机，而不是将到最终目标地址的所有通路都指出。 因为每一个区间在转发数据包时会指定下一跳的操作，直到最终目标地址。 路由控制表 为了将数据包发送给目标主机，所有主机都维护一张路由控制表。该表记录IP数据在下一步应该发送给哪一个路由器（根据MAC地址）。数据包将根据路由控制表在各个数据链路传递。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:30:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"数据链路的抽象化 不同的数据链路最大的不同在于它们的最大传输单位（MTU）不同。 以太网的MTU为1500字节， FDDI的MTU为4352字节， 为了解决这一问题，IP进行分片处理，将较大的IP包分为多个小的IP包进行传输，分片的包到达目标地址后再被组合起来。 即从IP的角度看，它完全可以忽略数据包在途中各个数据链路上的MTU。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:30:3","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址属于面向无连接型 IP地址属于面向无连接型，不需要建立与目标地址间的连接，属于非可靠传输。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:30:4","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址基础知识 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP数据包格式 （IPv4）长度为32位，（IPv6）长度为128位 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网络标识和主机标识 IP地址由网络标识和主机标识两部分组成， 同一段内的主机的网络标识是一样的（网路标识相同的计算机必须属于同一链路） 同一段内的主机标识是不一样的 由此保证IP地址的唯一性。 IP数据包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。即使不看主机标识，只要一见到网络标识就能够判断出是否出现为该网络段的主机。 那第几位到第几位是网络标识，第几位到第几位是主机标识呢？有两种类型，最初两者是按照分类进行区别。而现在基本以子网掩码区分。以下将分别介绍 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址的分类 IP 地址 ::= {\u003c 网络标识 \u003e, \u003c 主机标识 \u003e} 可分为A类，B类，C类，D类 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:3","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"子网掩码 作用：划分出更加细粒度的IP地址，提高利用率。 利用子网掩码来对IP地址进行划分（划分出网络标识和主机标识） 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 子网掩码用二进制方式标识的话，也是 32位的数字。它对应网络标识的部分全部为1，对应主机标识的部分全部为0，通过这种方式可以灵活的指定网络标识的长度。 作者：纪言 链接：https://www.zhihu.com/question/56895036/answer/447915532 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 首先子网掩码这名字取得很好，它是用来划分子网的网段和遮掩部分IP地址。换个说法就是：它是用来划分IP地址中哪一部分是网络号，哪一部分是机器号（这话教科书里写的）。网路号对应网络标识，网络标识相同的机器处于同一网段，即同一链路；机器号对应主机标识。 那么，问题来了 ： 怎么划分子网网段？ 为什么要遮掩IP地址？怎么个遮掩法？ 现在我们有这么个IP地址：192.168.1.129 我们并不知道它的网络号，也不知道它属于哪部分子网网段。我们现在就需要一个东西来划分出子网网段，这个东西就叫：子网掩码。 再，我们给出具体子网掩码：255.255.255.0 什么要这么给？因为子网掩码的长度要和IP地址相同32位，每8位预先被划分为一段。255的二进制就是1111 1111。 那么我们把子网掩码设置为255.255.255.193行不行？ 这需要看它的二进制，子网掩码还需要满足一个条件才可以使用：它的二进制中1和0必须是连续的。 255.255.255.193的二进制： 1111 1111.1111 1111.1111 1111.1100 0001 可以看出它1并不连续，所以255.255.255.193不能作为子网掩码使用。 255.255.255.0就很符合条件。 那子网掩码怎么用？ 答：用乘法来遮掩IP地址。1×1=1、1×0=0、0×0=0、0×1=0 IP地址：192.168.1.129 二进制： 1100 0000.1010 1000.0000 0001.1000 0001 子网掩码：255.255.255.0 二进制： 1111 1111.1111 1111.1111 1111.0000 0000 计算： 1100 0000.1010 1000.0000 0001.1000 0001 1111 1111.1111 1111.1111 1111.0000 0000 ———————————————————— 1100 0000.1010 1000.0000 0001.0000 0000 计算后的这段二进制代码相比于原来的IP地址，后面8位被用0遮掩了。 为什么要遮掩？因为我们不必关心后面8位是1还是0了。子网网段已经被划分出来了。 1100 0000.1010 1000.0000 0001.0000 0000的十进制：192.168.1.0 也就是说，从192.168.1.0到192.168.1.255都是同一个子网网段，里面的0—255号可以分配给不同的机器。 0—255号都是机器的号码，IP地址显示的就是其中129号。 192.168.1.0就是所谓的网络号，也可以写作192.168.1或者192.168.1.0\\24（24指的是IP地址中有24位未被遮掩） IP地址的意思就很明白了，网段（网络号）加上机器号码。同一个IP地址根据不同子网掩码，会划分出不同的网络号和机器号。 ————————————————————————————————————— 但是，现在就出现了个问题，我子网掩码的最后8位全是0，要是最后8位不全为0怎么办？又是什么意思呢？ 现在我们就要看上面子网掩码为255.255.255.0的时候机器号码是从0到255的，那如果我想在0到255里再划分一部分呢？ 给出新IP地址：192.168.1.188 再给出新的子网掩码：255.255.255.224 现在IP的网络号就不是192.168.1.0了，不再是网段192.168.1.0到192.168.1.255了 1100 0000.1010 1000.0000 0001.1011 1100 1111 1111.1111 1111.1111 1111.1110 0000 ———————————————————— 1100 0000.1010 1000.0000 0001.1010 0000 不再是24位未被遮掩了，而是27位未被遮掩。被遮掩的后5位，我们不必再关心它是1还是0了。 这就意味着：后5位不论怎么变换，都是在同一个网段里。 后5位的变化是在 1100 0000.1010 1000.0000 0001.1010 0000 到 1100 0000.1010 1000.0000 0001.1011 1111 之间的。 它的十进制：192.168.1.160到192.168.1.191是由新的子网掩码划分出来的子网网段。 我们称192.168.1.160\\27是它的网络号，它的机器号是在160到191之间任意分配出去。之前的IP地址：192.168.1.188属于其中。 总结：子网掩码就是用来遮掩IP地址并划分网段的工具，根据遮掩的位数不同来划分不同的网段。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:4","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"无分类 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {\u003c 网络前缀号 \u003e, \u003c 主机号 \u003e} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:5","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"广播地址 作用：用于在同一链路相互连接的主机之间发送数据包。 将IP地址中的主机标识全都设为1就形成了广播地址 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:6","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"IP地址聚合（CIDR与VLSM） 参考 无类域间路由技术（CIDR）（超网技术supernet） 将现有的IP地址合并成较大的、具有更多主机地址的路由域。 CIDR提出“网络前缀（network-prefix）”代替“网络号+主机号”，形成新的无分类的二级地址结构， ​ 即IP地址表示为：网络前缀+主机号 CIDR不在使用子网的概念，是一种无分类的二级地址结构。采用“斜线记法” 例：200.16.23.0/20 其中前20位为网络前缀，后12位是主机号。 CIDR将网络前缀相同的连续的IP地址组成一个“CIDR地址块”，一个CIDR地址块是由起始地址与块地址数来表示的。地址块的起始地址是指地址块中数值最小的一个。 例：200.16.23.0/20表示一个地址块时，起始地址为200.16.23.0，地址块中的地址数为2^12次。 CIDR中的广播地址：将主机号全置为1。 例：网络195.1.22.64/27的广播地址就要考虑5位主机号置1。由于64的二进制数为 0100 0000，后5位置1后为01011111（为十进制数95），那么网络195.1.22.64/27的广播地址为195.1.22.95。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:31:7","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"DNS ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:32:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"DNS的产生 起因：IP地址不便于记忆。 解决方法：为每一台计算机赋予一个唯一的主机名。主机名与IP地址一一对应 在进行网络通信时直接使用主机名，系统自动将其转换为对应的IP地址。 **DNS系统：有效管理主机名和IP地址之间对应关系的系统。**它可以维护一个用来表示主机名和和IP地址之间对应关系的数据库。 域名：为了识别主机名称和组织名称的一种具有分层的名称。 例如：kusa.ac.jp。在使用域名时，可以在每个主机名后面追加上域名。例如:pepper.kusa.ac.jp,piyo.kusa.ac.jp 域名服务器：指管理域名的主机和相应的软件。 它可以管理所在分层的域的相关信息。其所管理的分层叫做ZONE 。 DNS解析器：进行DNS查询的主机和软件。 DNS查询 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:32:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"ARP ARP是一种解决MAC地址问题的协议。 以目标IP地址为线索，用来定位下一个应该接收数据包的网络设备对应的MAC地址。如果目标主机不在同一条链路，可以通过ARP查找下一跳路由器的MAC地址 ARP只适用于IPv4,IPv6中可以用ICMPv6来替代ARP. ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:33:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"ARP 的工作机制 ARP是借助ARP请求和ARP响应两种类型的包确定MAC地址。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:33:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"ICMP ICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的主要原因，改善网络设置等。 有了这些功能之后，就可以获得网络是否正常、设置是否有误以及设备有何异常等情况。从而便于在网络上的问题诊断。 在IP通信中如果某个IP包因为某种原因未能到达目标地址，那么这个具体的原因有ICMP负责通知。 ICMP的这种通知消息会使用IP进行发送。发送主机分解该ICMP的首部和数据域以后得知具体发生问题的原因。 ICMP的信息大致可以分为两类： 通知出错原因的信息 用于诊断的查询信息 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:34:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Ping Ping 是 ICMP 的一个重要应用（ICMP回送信息），主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:34:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Traceroute Traceroute 是 ICMP 的另一个应用（ICMP超时信息），它可以显示由执行程序的主机到达特定主机之前经历多少路由器。。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:34:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"DHCP 功能：实现IP地址的自动配置、统一管理IP地址分配。 DHCP让即插即用成为可能 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:35:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"NAT 功能：用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。 专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:36:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"虚拟专用网 VPN 由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。 ​ VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原 4.传输层 传输层的主要功能是能够让应用程序之间实现通信 TCP ： 是一种面向有连接的传输层协议。能够保证数据的可靠传输。有重发控制，顺序控制，流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP ：是一种面向无连接的传输层协议。它不会关注对端是否真的接收到数据（不可靠传输）。 尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。（UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。） ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:37:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"套接字（Socket） 应用在使用TCP或UDP时，会用到操作系统提供的类库。这种类库一般被称为API（应用编程接口）。 使用TCP或UDP通信时，会广泛使用到套接字（Socket）的API。 参考 应用程序利用套接字，可以设置对端的IP地址、端口号，并实现数据的发送与接收 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –\u003e 读写write/read –\u003e 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭） socket是“open—write/read—close”模式的一种实现 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:38:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"端口号 数据链路中的地址：MAC地址；作用：识别同一链路中的不同计算机 网络层中的地址:IP地址；作用：识别TCP、IP网络中互连的主机和路由器 传输层的地址：端口号（程序地址）；作用：识别同一台计算机中的不同应用程序。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:39:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息称为确认应答（ACK） 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"通过序列号和确认应答来提高可靠性 序号 ：用于对字节流进行编号。能够识别是否已经接收数据，又能够判断是否需要接收。 按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"重发超时 如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： $$ RTTs=(1-a)(RTTs)+aRTT $$ 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： $$ RTO=RTTs+4*RTTd $$ 其中 RTTd 为偏差的加权平均值。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:3","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP三次握手 TCP是面向有连接的通信传输。需要在数据通信之前先做好通信两端之间的准备工作。 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:4","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端接收还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:5","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"TCP以段为单位发送数据 在建立TCP的连接过程中，也可以确立发送数据包的单位。我们可以称之为最大消息单位（MSS）。 TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。，进行重发时也是以MSS为单位。 MSS是在三次挥手时，在两端主机计算出来的。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:6","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"利用窗口控制提高速度 TCP以1个段为单位，每发送一个段就要进行一次确认应答处理，这种传输方式的一个缺点是，包的往返时间越长通信性能就越低。 为此，TCP引入了窗口这个概念，能够提高传输的速度。即发送端主机在发送一个段后不必一直等待确认应答，而是继续发送。如下图： 窗口是指无需等待确认应答就可以继续发送数据的最大值 如下图： 在窗口内的数据即使没有收到确认应答也可以发送出去 发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据（如果没有收到确认应答需要重发） 收到确认应答的情况下，发送端的可以将窗口滑动到确认应答中序列号的位置。 通过这种方式可以顺序的将多个段同时发送提高通信性能。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:7","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"窗口控制和快速重发控制 分为两种情况：1. 确认应答未能返回的情况（接收端主机成功接收到发送端主机发送的报文，但是接收端主机返回的确认应答未成功被发送端主机收到） 2.某个报文丢失的情况（接收端主机未成功接收到发送端主机发送的报文） 确认应答未能返回的情况 在没有使用窗口控制的情况下，没有收到确认应答的数据都会被重发 但是在使用窗口控制的情况下，某些确认应答即便丢失了也不需要重发（通过下一个确认应答进行确认） 某个报文丢失的情况 接收端主机在内有收到自己所期望序号的数据时，会对之前收到的数据进行确认应答。 发送端一旦收到某个确认应答后，又连续3次收到同样的确认应答，则认为数据段已经丢失，需要进行重发。这种机制被称为快速重发机制 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:8","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"流控制 TCP提供流控制可以让发送端根据接收端的实际接收能力控制发送的数据量 TCP首部中，专门有一个字段用来通知窗口的大小，接收主机可以将自己可以接收的缓冲区大小放入这个字段中通知给发送端 窗口大小的值就是由接收端主机确定的 接收区缓冲区一旦面临数据溢出，窗口大小的值就会被设置成一个更小的值，从而控制发送端主机发送数据 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:9","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"拥塞控制 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 发送的最初执行慢开始，令 cwnd（报文段大小） = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd \u003e= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始 5.应用层 TCP/IP应用架构绝大多属于客户端/服务端模型。提供服务的程序叫做服务端，接受服务的程序叫客户端。在这种通信模式中，提供服务的程序会预先被部署到主机上，等待接收任何时刻客户可能发送的请求。 TCP和IP等下层协议是不依赖于上层应用类型、适用面非常广的协议，而应用协议则是为了实现某种应用而设计和创造的协议。 （网络应用由不同的用户和软件供应商开发。为了实现网络应用的功能，在应用层之间进行通信时将其连接的协议是十分重要的） 常见的应用协议： 浏览器与服务端之间的通信协议为HTTP，所传输数据的主要格式为HTML。 发送电子邮件时用到的协议为SMTP协议或MIME协议。 文件传输协议:FTP。文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上 远程登录协议：SSH 协议或TELNET协议。 网络管理协议：SNMP协议。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:40:10","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"文件传输协议:FTP FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:41:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"WWW 万维网（WWW，World Wide Web）是将互联网中的信息以超文本形式展示的系统。也叫作Web。 可以显示Web信息的客户端软件称为Web浏览器。简称为浏览器。 借助浏览器，人们不需要考虑该信息保存在在哪个服务器，只需要点击鼠标就可以访问页面的链接并打开相关信息。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:0","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Web的基本要素:URL，HTML，HTTP URL （统一资源定位符）：用来表示互联网中资源（文件）的具体位置 它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。 HTML（超文本标记语言） 是记录Web页中的一种语言。HTML具有纯文本的功能。在页面中不仅可以为文字或图像附加链接，当用户点击那些链接时还可以呈现该链接所指示的内容，因此它可以将整个互联网中任何一个Web服务器中的信息以链接的形式展现。 HTTP（文档传输协议） 当用户在浏览器上输入要访问的Web页的URL后HTTP的处理就会开始。HTTP默认使用80端口。它的工作机制为，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。 HTTP有两个版本，一个是HTTP1.0另一个是HTTP1.1 HTTP1.0中每一个命令和应答都会触发一次TCP的连接和断开 HTTP1.1允许在一个TCP连接上发送多个命令和应答；大大减小TCP连接和断开操作，从而提高了效率。 持久连接： 也称为keep-alive 特点为：只要任意一端没有明确的提出断开连接则保持TCP连接状态。 在HTTP1.1中，所有的连接默认都是持久连接 管线化： 管线话技术出现后，不用等待响应就可以发送下一个请求。 这样就能够同时并行发送多个请求，而不需要一个一个等待响应了。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:1","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"JavaScript : 是一种嵌入在HTML中的编程语言，作为客户端程序运行于多种类型的的浏览器中。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:2","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"CGI 是一种Web服务器调用外部程序时所使用的一种服务端应用的规范。 引入CGI以后客户端请求会触发Web服务器运行另一个程序，客户端的请求也会输给这个程序。该程序运行结束后就会将生成的HTML和其他数据再返回给客户端。 利用CGI可以针对用户的操作返回给客户端动态的信息。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:3","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Cookie Cookie技术通过在请求和响应报文中写入Cookie信号来控制客户端的状态 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 HTTP是不保存状态的协议，即无状态协议，**HTTP协议自身不对请求和响应之间的通信状态进行保存。**因此需要使用Cookie技术。 用途： 比如，用户登录在一家购物网站，即使他跳转到该站的其他页面后，也能够继续保持登录状态。针对这个实例，网站为了能够掌握是谁发送的请求，需要保存用户的状态。 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 分类： 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 过程： 客户端发送请求报文 服务端返回响应报文，响应报文中的首部字段有一个叫做Set-Cookie字段 客户端通过响应报文中的Set-Cookie字段得知，自动保存Cookie 在下次客户端发送请求报文时，请求报文中会自动包含Cookie字段 服务端发现请求报文中的Cookie字段后，会去检查是哪一个客户端发送过来的请求，然后对比服务器上的记录，最后的到之前的状态信息 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:4","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Session 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 利用Session将用户信息存储在服务端 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 浏览器禁用 Cookie 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 Cookie 与 Session 选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:5","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"虚拟主机 HTTP1.1规范允许一台HTTP服务器搭建多个Web 站点。 即使物理层面只有一台主机，但是只要使用虚拟主机的功能，就可以假想有多台服务器 客户端通过域名来访问服务器，域名首先会通过DNS解析成IP地址。即虚拟主机具有不同的域名，但是一台服务器上的虚拟主机的IP地址是相同的。所以需要区别不同的虚拟主机。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:6","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URL，会直接发送给前方持有资源的目标服务器。 使用代理服务器的原因： 利用缓存技术减少网络带宽的流量 组织内部针对特定网站的访问控制 … 缓存代理：会预先将资源副本（缓存）保存在代理服务器上 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:7","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"网关 网关与代理的不同之处在于，网关能够使通信线路上的服务器提供非HTTP协议服务 网关能够提高通信的安全性。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:8","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"隧道 隧道可以按照要求建立一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。 隧道的目的是确保通信的安全性 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:9","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"缓存 缓存指代理服务器或客户端本地磁盘内保存的资源副本 利用缓存可以减少堆源服务器的访问，节省了通信流量和通信时间 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:10","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"内容协商 通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 1. 类型 1.1 服务端驱动型 客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。 它存在以下问题： 服务器很难知道客户端浏览器的全部信息； 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）； 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。 1.2 代理驱动型 服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。 2. Vary Vary: Accept-Language 在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。 例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 Vary: Accept-Language 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:11","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"内容编码 内容编码将实体主体进行压缩，从而减少传输的数据量。 常用的内容编码有：gzip、compress、deflate、identity。 浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:12","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"范围请求 如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。 1. Range 在请求报文中添加 Range 首部字段指定请求的范围。 GET /z4d4kWk.jpg HTTP/1.1 Host: i.imgur.com Range: bytes=0-1023 请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 HTTP/1.1 206 Partial Content Content-Range: bytes 0-1023/146515 Content-Length: 1024 ... (binary content) 2. Accept-Ranges 响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。 Accept-Ranges: bytes 3. 响应状态码 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:13","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"分块传输编码 Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:14","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多部分对象集合 一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： Content-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\"submit-name\" Larry --AaB03x Content-Disposition: form-data; name=\"files\"; filename=\"file1.txt\" Content-Type: text/plain ... contents of file1.txt ... --AaB03x-- ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:15","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"基本概念 HTTP协议用于客户端和服务器之间的通信 HTTP规定，客户端和服务端通过请求和响应的交换达成通信。 请求和响应报文 客户端发送一个请求报文给服务端，服务端根据请求报文中的信息进行处理，并将处理的结果放入响应报文中返回给客户端。 请求报文的结构 请求方法 请求URL 协议版本 可选的请求首部字段 内容实体 响应报文结构 协议版本 状态码（表示请求成功或失败的数字代码） 用来解释状态码的原因短语 可选的响应首部字段 实体主体 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:16","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"报文主体和实体主体 HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速度 HTTP报文的主体用于传输请求或响应的实体主体 通常情况下报文主体等于实体主体，只有当传输过程中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:17","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"HTTP方法 请求报文中包含了方法字段，常用方法如下: GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第九章。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 PUT /new.html HTTP/1.1 Host: example.com Content-type: text/html Content-length: 16 \u003cp\u003eNew File\u003c/p\u003e PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 PATCH /file.txt HTTP/1.1 Host: www.example.com Content-Type: application/example If-Match: \"e0023aa4e\" Content-Length: 100 [description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:18","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"HTTP状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:19","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"HTTP首部 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容 HTTP首部字段结构： 首部字段名：字段值 一个字段名可以有多个字段值 有4种HTTP首部字段类型 通用首部字段 请求首部字段 响应首部字段 实体首部字段 各种首部字段及其含义如下（不需要全记，仅供查阅）： 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:20","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"HTTPS HTTP存在的问题 通信使用明文（不加密），内容可能被窃听 不验证通信双方的身份，可能不是和预想的通信方在通信。 无法证明报文的完整性，内容可能被篡改。 什么是HTTPS： 与SSL组合使用的HTTP被称为HTTPS.（超文本传输安全协议）。 SSL是一种网络安全技术，其能够为HTTP提供通信加密、证书、完整性保护 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 共享秘钥加密 加密和解密使用同一个秘钥，也称为对称秘钥加密 优点：运算速度快 存在问题：无法安全的将秘钥发送给对方 公开秘钥加密 发送密文的一方使用对方的公开秘钥进行加密处理 对方收到被加密的信息后，在使用自己的私有秘钥进行解密（也称为非对称秘钥加密） 优点：使用这种方式可以不需要发送用于解密的私有秘钥，也不必担心木要被攻击者窃听而盗走 缺点：运算速度慢 HTTPS加密方式 上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性（但是传输效率低），因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案： 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性; 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） 认证 存在问题： 公开秘钥加密方式的问题：无法证明公开秘钥本身就是货真价实的公开秘钥。（无法证明收到的公开秘钥就是预想的那台服务器发行的公开秘钥） 解决方法： 通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 如何将公开秘钥安全的转交给客户端： ​ 多数浏览器开发商发布版本时，会事先在内部植入常用认证机构的公开秘钥 完整性保护 SSL 提供报文摘要功能来进行完整性保护。 HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。 HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 HTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:21","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"HTTP2.0 ","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:22","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Web 页面请求过程 1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 参考 https://github.com/CyC2018/CS-Notes 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014. 竹下隆史. 图解 TCP/IP[M]. 人民邮电出版社, 2013. 常见问题 某一速率 为 100M 的交换机有 20 个端口，则每个端口的传输速率为（ ） 100M 交换机独享带宽；交换机与网桥的区别是交换机具有背板带宽容量，可以为每个端口分配相同带宽，这区别于网桥的带宽征用 报文分组交换方式是把长的报文分成若干个较短的报文组，报文分组是交换单位，它与报文交换方式不同的是，报文分组交换有（） 报文分组编号 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换：单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查看转发表，转发到下一个结点。 运输层为运行在不同主机上的进程彼此之间提供了逻辑通信，而网络层则提供了主机之间的逻辑通信。（ ） 正确 传输层是进程到进程，俗称端到端。网络层是主机到主机，俗称点到点。 下面哪一个地址不能用作某个局域网内网IP（C） A.192.168.201.114 B.172.16.4.25 C.127.0.0.1 D.10.0.0.1 A类地址中，10.0.0.0到10.255.255.255是私有地址 在B类地址中，172.16.0.0到172.31.255.255是私有地址 在C类地址中，192.168.0.0到192.168.255.255是私有地址 127.0.0.1 本机回送地址 做测试用 下列关于单模光纤与多模光纤的区别描述错误的是？(B) A.光的传输方式不同 B.带宽容量也不一样，多模光纤较大 C.多模光纤用于短距离的系统 D.单模光纤用于长距离的系统 单模光纤传输模式单一，因此干扰小，带宽大，适合长距离传输 多模光纤是在一条光纤中传输多条光路，适合短距离传输 公司办公室的一台计算机通过IP可以访问外网，无法使用域名访问外部web服务器,造成这种情况可能的原因是（ A,B ） A该计算机的DNS缓存有错 B没有指定正确的DNS服务器 C该计算机与DNS服务器IP地址在不同的网段 D网关设置出错 IP地址与路由器网关地址必须在同一网段，DNS则不需要，DNS服务器地址一般由运营商指定；所以C错 如果网关设置错误，不能访问外网。题目中是可以通过IP地址访问外网的；所以D错 总部给某分公司分配的网络地址是172.16.2.0/24,该分公司有三个部门（不同的部门属于不同的网段，即不同的网络标识），每个部门计算机不多于30台,在网络配置时，进行子网划分，可以使用的子网掩码是（B,C） A.255.255.255.128 B.255.255.255.192 C.255.255.255.224 D.255.255.255.240 利用子网掩码来划分网络标识和主机标识。同一网段内的主机的网络标识是一样的。同一网段内的主机的主机标识是不一样的。 1.分公司的网络地址是172.16.2.0/24（其中24表示网络表示的长度），子网掩码长度就是24位11111111.11111111.11111111.00000000（子网掩码对应网络标识部分为1，对应主机表示部分为0.）； 2.分公司3个部门，那么就用第25位和第26位来区分三个部门，11111111.11111111.11111111.11000000（00~11），直接排除A； 3.那么各个部门用来区分自己的子网掩码只剩下最后6位（27~32位）来表示了； 4.若用255.255.255.192，最后8位是11000000，只能表示11000000~11111111除去广播地址一共62台 5.若用255.255.255.224，最后8位是11100000，只能表示11100000~11111111除去广播地址一共30台 6.若用255.255.255.240，最后8位是11110000，只能表示11110000~11111111除去广播地址一共14台 下面有关http keep-alive说法错误的是？(D) A.在HTTP1.0和HTTP1.1协议中都有对KeepAlive的支持。其中HTTP1.0需要在request中增加“Connection： keep-alive” header才能够支持，而HTTP1.1默认支持 B.当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 C.可以在服务器端设置是否支持keep-alive D.当你的Server多为动态请求，建议开启keep-alive增加传输效率 HTTP/1.0 ​ 在HTTP/1.0版本中，并没有官方的标准来规定Keep-Alive如何工作，因此实际上它是被附加到HTTP/1.0协议上，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive， 当服务器收到附带有Connection: Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Kee","date":"2020-12-16","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/:42:23","tags":null,"title":"计算机网络基础","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Linux中的命令行界面称为shell （图形界面称为GUI）。 bash shell（bash）是大多数Linux系统的默认shell，还用很多其他的shell ,例如ksh和csh。 文本模式登录后所取得的程序被称为壳（shell），这是因为这只程序负责最外面跟使用者（我们）打交道，所以被戏称为“壳” 在Linux中的shell为bash shell也只是一个普通的用户程序。它仅仅需要从键盘读取数据、向显示器输出数据和运行其他程序的能力。 可以将一系列shell命令放到一个文件中，然后将此文件作为shell的输入来运行。包含shell命令的文件称为shell脚本。 ","date":"2020-12-14","objectID":"/linux%E5%9F%BA%E7%A1%80/:0:0","tags":null,"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Linux应用程序 Linux的命令行用户界面（shell）中包含大量的标准应用程序。这些程序大致可以分为以下6类： 文件和目录操作命令 过滤器 程序设计工具，如编辑器和编译器 文档处理 系统管理 其他 常用指令： cal : 日历查看 date：日期查看 shift+pageup /shift+pageup:向上翻页/向上翻页 ","date":"2020-12-14","objectID":"/linux%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"内核结构 运行在硬件之上的为操作系统，其作用为控制硬件并且为其他程序提供系统调用接口。这些系统调用允许用户创立并管理进程、文件以及其他资源。 Linux具有三种不同的接口：真正的系统调用接口，库函数接口，由标准应用程序构成的接口。 内核位于硬件之上，负责实现I/O设备和存储管理单元的交互，并控制CPU对前苏诉设备的访问。 最底层：最底层包含中断处理程序，它们是与设备交互的主要方式，以及底层的分派机制 中间层：中间层为内核的三个主要部件，I/O部件，内存管理部件，进程管理部件。 I/O部件： 内存管理部件：任务包括维护虚拟内存到物理内存的映射，维护最近被访问页面的缓存以及实现一个好的页面置换算法，并根据需要把需要的数据和代码页读入内存中。 进程管理部件：主要任务是进程的创建和终止 最顶层：最顶层为到内核的系统调用接口。所有系统调用都来自这里，其触发一个陷入，并将系统从用户态转换到受保护的内核态，继而将控制权交给上诉的内核部件之一。 ","date":"2020-12-14","objectID":"/linux%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Linux中的进程 在大多数单用户的工作站中，即使用户已经退出登录了，仍然会有很多后台进程，称为守护进程。计划任务是一种典型的守护进程。它每个几分钟运行一次来检查是否有工作需要它完成。 在Linux中，系统调用fork将会创建一个与原始进程完全一样的进程副本。调用fork函数的进程称为父进程，新的进程称为子进程。 进程以其PID来命名 Linux中，进程间可以通过消息传递的方式进行通信。有两种方式： 管道：一个进程子啊管道中写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，因为当一个进程试图从一个管道中读取数据，这个进程就会被挂起直到管道中有数据为止。 shell中的管线就是用管道技术实现的，例如sort \u003cfile | head,有两个进程sort,head 软中断：一个进程可以给另一个进程发送信号，进程可以告诉操作系统当信号到来时他们希望发生什么事件。相关的选择有忽略这个信号、抓取这个信号或被这个信号杀死。 ","date":"2020-12-14","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Linux中进程与线程的实现 每一个进程都有运行用户程序的用户模式。 但是当它的某个线程调用系统调用之后，进程就会陷入内核模式并且运行在内核上下文中，他将使用不同的内存映射并且拥有对所有机器资源的访问权。它还是同一个进程，但是现在拥有更高的权限，同时拥有自己的内核堆栈以及内核程序计数器。 ","date":"2020-12-14","objectID":"/linux%E5%9F%BA%E7%A1%80/:3:1","tags":null,"title":"Linux基础","uri":"/linux%E5%9F%BA%E7%A1%80/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 第一张图代表标准卷积操作。若输入特征图尺寸为 ，卷积核尺寸为 ，输出特征图尺寸为 ，标准卷积层的参数量为： 。（一个滤波器在输入特征图 大小的区域内操作，输出结果为1个数值，所以需要 个滤波器。） 第二张图代表分组卷积操作。将输入特征图按照通道数分成 组，则每组输入特征图的尺寸为 ，对应的卷积核尺寸为 ，每组输出特征图尺寸为 。将 组结果拼接(concat)，得到最终尺寸为 的输出特征图。分组卷积层的参数量为 。 深入思考一下，常规卷积输出的特征图上，每一个点是由输入特征图 个点计算得到的；而分组卷积输出的特征图上，每一个点是由输入特征图 个点计算得到的。自然，分组卷积的参数量是标准卷积的 。 将输入特征图沿着通道方向进行划分，分割成不同组，每一组分别采用一个卷积和进行卷及操作。 输入特征图的大小、输出特征图的大小和标准的卷积一样，指示卷积核的参数整体减小了。 ","date":"2020-12-12","objectID":"/group-______/:0:0","tags":null,"title":"group convolution.","uri":"/group-______/"},{"categories":["深度学习论文阅读笔记"],"content":"深度可分离卷积（Depthwise separable convolution） 这张图怎么少的了呢： 图(a)代表标准卷积。假设输入特征图尺寸为 ，卷积核尺寸为 ，输出特征图尺寸为 ，标准卷积层的参数量为： 。 图(b)代表深度卷积，图(c)代表逐点卷积，两者合起来就是深度可分离卷积。深度卷积负责滤波，尺寸为(DK,DK,1)，共M个，作用在输入的每个通道上；逐点卷积负责转换通道，尺寸为(1,1,M)，共N个，作用在深度卷积的输出特征映射上。 深度卷积参数量为 ，逐点卷积参数量为 ，所以深度可分离卷积参数量是标准卷积的 。 为了便于理解、便于和分组卷积类比，假设 。深度卷积其实就是 的分组卷积，只不过没有直接将 组结果拼接，所以深度卷积参数量是标准卷积的 。逐点卷积其实就是把组结果用 conv 拼接起来，所以逐点卷积参数量是标准卷积的 。(*只考虑逐点卷积，之前输出的特征图上每一个点是由输入特征图 区域内的点计算得到的；而逐点卷积输出上每一个点是由 区域内的点计算得到的)。*自然，深度可分离卷积参数量是标准卷积的 。 ","date":"2020-12-12","objectID":"/group-______/:1:0","tags":null,"title":"group convolution.","uri":"/group-______/"},{"categories":["Java学习笔记"],"content":"线程和进程的区别 简单的理解： 进程是系统中的一个应用，进程不会相互影响。进程是程序运行的基本单位，系统运行一个程序就是一个进程从创建到灭亡的过程 一个进程中可以包含多个线程，一个线程开辟一个栈空间，假设有10个线程，就会开辟10个栈空间。但是不同线程之间是共享方法区和堆的。 栈是线程私用的，生命周期和线程相同，栈描述的是Java方法执行的线程内存模型：每个方法执行的时候都会同步创建一个栈帧用于存储局部变量表/操作数栈，动态连接。方法出口等信息。 堆是所有线程共享的区域。这在JVM启动时创建，此内存唯一的目的就是存放对象实例 方法区是所有线程共享的区域，用于存储已被JVM加载的类型信息，常量，静态常量，即时编译后的代码缓存片段。 这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存 --- 进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成： 程序A得到CPU -\u003e CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。 这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境的更为细小的CPU时间段。线程主要共享的是进程的地址空间。 作者：zhonyong 链接：https://www.zhihu.com/question/25532384/answer/81152571 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 小结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。参考 进程的实现： 为了实现进程模型，操作系统维护这一张表格，即进程表（PCB）。每个进程占用一个进程表项（或称为进程控制块）。该表项中包括了进程的状态的重要信息，包括程序计数器，堆栈指针，内存分配状况，所打开文件的状态，账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断一样 注意：进程表是在操作系统中的（在内核态中） 再一次明确：进程切换的效率是比较低的 在切换进程时，首先用户态必须切换到内核态；然后保存当前进程的状态 ，包括在进程表中存储寄存器值以便以后重新加载。在许多系统中，内存映像也必须保存；接着，通过运行调度算法选定一个新进程；之后，应该将新进程的内存映像重新载入MMU（内存管理单元）中；最后，新进程开始运行。除此之外，进程切换还要使得整个内存高速缓存失效，强迫缓存从内存中动态重新载入两次（进入内核一次，出内核一次）。 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。 所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示： 为什么需要线程： 主要原因：在一个进程中可能会同时发生多个活动。其中某一些活动随着时间的推移会被阻塞。通过将进程分解为多个线程，程序设计模式会变得简单 线程比进程更加的轻量化，所以线程比进程更容易创建和销毁。 进程和线程的区别： Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 注意：一个进程中的所有线程都有完全一样的地址空间，这意味着他们也共享同样的全局变量（共享公共内存）。除了共享内存地址外，所有线程还共享同一个打开的文件集，子进程、定时器以及相关信号等。 一个进程总是由某个用户拥有，该用户创建多个线程是为了他们之间的相互合作而不是竞争。 而不同进程可能由不同用户拥有，不同进程间可能存在敌对关系。 线程的分类： 线程可以分为用户级线程和内核级线程，其调度算法与可以是进程的调用算法中的一种。 两者间的差异在于性能。 用户级线程的线程进行切换时只需要少量的机器指令，而内核级线程的线程进行切换时需要完整的上下文切换（修改内存映像，清理高速缓存等内容） 用户级线程可以使用专门为应用程序定制的线程调度算法 进程和程序的区别： 举个例子： 有一位科学家在为他的女儿制作生日蛋糕。他有做蛋糕的食谱，厨房里有所需的原料。在这个比喻中，做蛋糕的食谱就是程序（即用适当形式描述的算法），科学家就是CPU，而做蛋糕的各种原料就是输入数据。进程就是科学家阅读食谱，取来各种原料以及烘制蛋糕等一系列动作的总和。 这里的关键思想是：一个进程是某中类型的一个活动，它有程序、输入、输出以及状态。 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"创建线程的方式 继承Thread,重写run方法，在创建对象时直接new即可使用 public class ThreadTest01 { public static void main(String[] args) { Student student = new Student(); // start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成后，瞬间就结束了 // 启动成功的线程会自动调用run()方法，并且run()方法在分支栈的底部(压栈) // run()方法在分支栈的底部，main()方法在主栈的底部，run()方法和main()方法是平级的。 // 如果直接调用run()方法，无法启动分支线程，所以必须写start()方法 student.start(); for (int i=0;i\u003c500;i++){ System.out.println(\"这是主线程\"+i); } } } class Student extends Thread {//Thread实现Runnable接口 @Override public void run() { // 编写程序，这段程序直接运行在分支线程中(分支栈中) for (int i = 0; i \u003c 500; i++) { System.out.println(\"这是分支线程\" + i); } } } 实现接口Runnable，并重写run方法,在创建对象是直接new，此时创建出来的对象称为可运行对象，然后将可运行对象封装成一个线程对象。 public class ThreadTest02 { public static void main(String[] args) { // 创建一个可运行对象 User u = new User(); // 将可运行对象封装成一个线程对象 Thread thread = new Thread(u);//Thread构造方法的参数类型为Runnable // 启动线程 thread.start(); for (int i = 0; i \u003c 100; i++) { System.out.println(\"这是主线程\" + i); } } } class User implements Runnable { @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(\"这是分支线程\" + i); } } } 小结： 由于Java中不允许多继承，但是能够实现多个接口。如果要继承其他的类就要选择实现Runnable接口。 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"线程的生命周期 线程的生命周期可以分为：新建，准备(ready)，运行(running)，阻塞(blocked)和终止 注意： 处于running下的线程因为某些原因进行阻塞状态后，会释放掉抢占到的CPU时间片，并且不会直接进入ready，而需要等待引起阻塞的原因消除时才进入ready.进入ready还要重新抢CPU时间片，当抢到cpu时间片后会接着上次运行的代码继续运行，而不是重新运行 其中阻塞又可以细分为三种状态： （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)。直到调用notify/notifyAll或wait时间到，线程会进入锁池。 （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。当锁池中的线程拿到对象的锁时会重新进入Ready转态 （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 常见问题 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ 调用线程的start()方法会为使得线程进入ready状态，当线程抢到cpu时间片后会执行线程中的run方法 直接调用run()方法会将run（）方法视为main()线程下的一个普通方法 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"线程中的常用函数 1.获取当前线程对象 Thread.currentThread，属于静态方法 2.获取线程名字 getName() 3.设置线程名字 setName() public class ThreadTest04 { public static void main(String[] args) { // 获取当前线程对象， // 这个代码出现在main方法中，所以当前线程就是主线程 Thread currentthread=Thread.currentThread(); System.out.println(currentthread.getName()); MyThread01 myThread01=new MyThread01(); Thread thread01=new Thread(myThread01); // 设置线程名字 thread01.setName(\"beijing\"); // 获取线程名字 System.out.println(\"分支线程名字为：\"+thread01.getName()); Thread thread02=new Thread(myThread01); System.out.println(thread02.getName()); // thread01.start(); } } class MyThread01 implements Runnable{ @Override public void run() { System.out.println(\"这是分支线程\"); } } /* main 分支线程名字为：beijing Thread-1 */ 4.线程睡眠方法 Thread.sleep(long millis)方法，使当前线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为准备（ready）状态,需要重新抢夺CPU时间片。 public class ThreadTest06 { public static void main(String[] args) throws InterruptedException { Mythread02 mythread02=new Mythread02(); Thread thread=new Thread(mythread02); // thread.setName(\"t\"); thread.start(); Thread.sleep(1000*5);//让当前线程进入睡眠，也就是main进入睡眠 System.out.println(Thread.currentThread().getName()); System.out.println(\"主线程\"); } } class Mythread02 implements Runnable{ @Override public void run() { // 让子线程进入睡眠 try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } for (int i=0;i\u003c10;i++){ System.out.println(Thread.currentThread().getName()+\"---\u003e\"+i); } } } 5.中断线程睡眠的方法 interrupt() public class ThreadTest07 { public static void main(String[] args) throws InterruptedException { Thread thread=new Thread(new MyThread03()); // thread.setName(\"t\"); thread.start(); //主线程睡眠5秒，但是分支线程还在执行，5秒后执行thread.interrupt();分支线程中断睡眠 Thread.sleep(1000*5); // 中断thread线程的睡眠，这种中断睡眠的方式依靠的是异常处理机制 thread.interrupt(); } } class MyThread03 implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\" start\"); try { Thread.sleep(1000*60); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+\" end\"); } } /* Thread-0 start java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at ThreadTest.MyThread03.run(ThreadTest07.java:37) at java.base/java.lang.Thread.run(Thread.java:832) Thread-0 end */ 6.如何合理的终止线程 通过标记进行终止 public class ThreadTest08 { public static void main(String[] args) throws InterruptedException { MyThread04 myThread04=new MyThread04(); Thread thread=new Thread(myThread04); thread.start(); // 主线程睡眠5秒，但是分支线程还在执行,5秒后执行myThread04.run=false;此时分支线程结束 Thread.sleep(1000*5); myThread04.run=false; } } class MyThread04 implements Runnable{ boolean run=true; @Override public void run() { for (int i=0;i\u003c100;i++){ if (run){ // 如果run=true，每隔一秒输出一次 System.out.println(Thread.currentThread().getName()+i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } else { // 可以在return前将需要保存的数据进行保存 return;//return表示方法结束 } } } } /* Thread-00 Thread-01 Thread-02 Thread-03 Thread-04 Process finished with exit code 0 */ 7.线程让位 yield，属于静态方法 使得处于running的线程主动放弃占用的CPU时间片，回到ready状态，以允许具有相同优先级的其他线程获得运行机会，因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 public class ThreadTest09 { public static void main(String[] args) throws InterruptedException { Mythread009 mythread009=new Mythread009(); Thread thread1=new Thread(mythread009); thread1.start(); Thread.yield();//属于静态方法，使得running的线程让出cpu时间片 // System.out.println(\"主线程开始\"); for (int i=0;i\u003c3;i++){ System.out.println(Thread.currentThread().getName()+i); } // System.out.println(\"主线程结束\"); } } class Mythread009 implements Runnable{ @Override public void run() { for (int i=0;i\u003c3;i++){ System.out.println(Thread.currentThread().getName()+i); } } } 8.线程合并 join 在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 public class ThreadTest09 { public static void main(String[] args) throws InterruptedException { Mythread009 mythread009=new Mythread009(); Thread thread1=new Thread(mythread0","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"线程同步 什么时候会存在线程安全问题 当满足以下条件（竞态条件）： 多线程并发 有共享数据的行为 共享数据有修改数据的行为 多线程可能会导致共享数据被破坏，引起线程安全问题。 如何解决线程安全问题 用排队执行的机制来解决线程安全问题，这种机制称为线程同步机制。 如何实现线程同步？使用 synchronized关键字 1.首先明确： 每个对象都有一把锁，用来保护代码片段 锁可以管理试图进入被保护代码段的线程（如wait,notify等方法） synchronized关键字的作用域 某个对象实例（获取的是对象锁） synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法 某个类（获取的是类锁） synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 //将synchronized作用静态方法 //或作用与类名称字面常量 Class Foo{ public synchronized static void methodAAA() // 同步的static 函数 { //…. } public void methodBBB() { synchronized(Foo.class) // class literal(类名称字面常量) } } synchronized可以通过调用同步方法来获得锁 即如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法。也就是说，要调用这个方法必须获得对象的锁 public synchronized void methed(){ method body } synchronized关键字还可以用于方法中的某个区块中（即同步语句块），表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/*区块*/}，它的作用域是当前对象； public synchronized void methed(){ synchronized（this）{ } } synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法； 小结： synchronized关键字可以作为函数的修饰符，也可作为函数内的语句的修饰符，也就是平时说的同步方法和同步语句块 如果再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁 每个对象只有一个锁（lock）与之相关联 明确： 同一个类中new出来的不同对象的锁是不同的，即每个对象只有一把锁 假设现在有一个类,new出来了两个对象p1,p2，这两个的对象锁是不一样的。但是类锁是唯一的 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:5","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"死锁 ​ 多个线程同时被阻塞，其中一个或全部线程等待某个资源的释放。由于线程被无限期的阻塞，因此程序不可能会正常终止 多出现在synchronized嵌套使用的情况中，例如： 线程A想要获得资源1和资源2的锁，同时线程2也想要获得资源1和资源2的锁。当A抢到资源1的锁，B抢到资源2的锁时，A线程会等待资源2的锁，B线程会等待资源1的锁，此时就会进入一个无限期的等待。 package ThreadDeadLockTest01; /** * ClassName: DeadLockTest01 * Package: ThreadDeadLockTest01 * Description: * Datetime: 2020/10/17 下午8:24 * Author: shilongshen */ /* * 死锁 *怎么写死锁: * 当t1线程锁住o1的锁时，由于t2线程已经锁住了o2对象的锁，所以t1线程永远不会结束，同理t2线程也不会结束。 * * ---\u003esynchronized在开发中最好不要嵌套使用 * */ public class DeadLockTest01 { public static void main(String[] args) { Object o1=new Object(); Object o2=new Object(); //t1,t2线程共享o1,o2 Thread t1=new Thread(new Mythread1(o1,o2)); Thread t2=new Thread(new Mythread2(o1,o2)); t1.setName(\"t1\"); t2.setName(\"t2\"); t1.start(); t2.start(); } } class Mythread1 implements Runnable{ Object o1; Object o2; public Mythread1(Object o1,Object o2){ this.o1=o1; this.o2=o2; } @Override public void run() { synchronized(o1){ System.out.println(\"t1 --\u003eo1\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o2){ System.out.println(\"t1--\u003eo2\"); } } } } class Mythread2 implements Runnable{ Object o1; Object o2; public Mythread2(Object o1,Object o2){ this.o1=o1; this.o2=o2; } @Override public void run() { synchronized(o2){ System.out.println(\"t2--\u003eo2\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o1){ System.out.println(\"t2---\u003eo1\"); } } } } ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:6","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"volatile关键字 JMM（Java内存模型） 在Java内存模型下，线程可以将变量保存到本地内存（比如计算机的寄存器）中，而不是直接在主存中进行读写。这就可能造成当一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用他在寄存器中的拷贝值时数据不一致。 为了保证共享数据的安全，可以使用线程同步机制（通过对象锁）。 而volatile关键字为共享变量的同步访问提供了一种免锁机制，使得线程每一次使用共享变量都是直接到主存中进行操作。 常见问题： ​ synchronized 关键字和 volatile 关键字的区别 volatile 只能修饰变量，而synchronized能够修饰方法和代码块。volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比 synchronized 关键字要好 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:7","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"并发编程的三个重要特性 原子性 : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么都不执行。synchronized 可以保证代码片段的原子性。（即synchronized中的代码块一定是全部一起执行的或者是不执行） 可见性 ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。 有序性 ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。 ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:8","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"ThreadLocal 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ JDK 中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 public class ThreadLocalTest { public static void main(String[] args) throws InterruptedException { ThreadLocal\u003cString\u003e threadLocal=new ThreadLocal\u003c\u003e();//创建一个ThreadLocal变量 MyThread myThread=new MyThread(threadLocal); Thread thread1=new Thread(myThread); thread1.setName(\"t1\"); threadLocal.set(\"beijing\");//main进程调用了ThreadLocal，并设置为“beijing”，注意设置的是threadLocal在main线程的这个副本 System.out.println(Thread.currentThread().getName()+\" before ThreadLocal= \"+threadLocal.get()); thread1.start(); Thread.sleep(1000*1);//使main进程睡眠1s，确保t1先执行 System.out.println(Thread.currentThread().getName()+\" after ThreadLocal= \"+threadLocal.get());//输出为beijing,得到的是threadLocal在main线程的这个副本，t1线程中threadLocal副本的更改不会影响到main线程的副本。 } } class MyThread implements Runnable{ ThreadLocal\u003cString\u003e local=new ThreadLocal\u003c\u003e(); public MyThread(ThreadLocal\u003cString\u003e local ){ this.local=local; } @Override public void run() { System.out.println(Thread.currentThread().getName()+\" before ThreadLocal= \"+local.get());//得到的为null，注意得到的是threadLocal在t1线程的这个副本,初始值为null local.set(\"shenzhen\"); System.out.println(Thread.currentThread().getName()+\" after ThreadLocal= \"+local.get()); } } /* main before ThreadLocal= beijing t1 before ThreadLocal= null t1 after ThreadLocal= shenzhen main after ThreadLocal= beijing */ ","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:9","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"线程池 线程池中包含许多准备运行的线程，为线程池提供一个Runnable，就会有一个线程调用run方法。当run方法退出时，这个线程不会死亡，而是留在线程池中准备为下一个请求提供服务。 Callable和Runnable接口的区别 实现Callable接口的线程能够返回中执行结果-\u003ecall函数有返回值，返回值的类型为V ; call()方法可抛出异常 public interface Callable\u003cV\u003e { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; } 实现Runnable接口的线程不能够返回执行结果-\u003erun函数没有返回值 ；run()方法是不能抛出异常的 public interface Runnable { /* * @see java.lang.Thread#run() */ public abstract void run(); } 创建线程的第三种方式 Callable的使用： public class CallableTest01 { public static void main(String[] args) { MyThread01 myThread01=new MyThread01(); /* 创建一个线程需要通过 new Thread('Runnable') 但是Thread内的参数应该为'Runnable'类型(Thread构造方法的参数类型为Runnable) 我们通过Callable创建的对象为Callable,怎么办呢？ 这时我们可以通过Runnable下的一个实现类: FutureTask,来解决这一问题。 FutureTask传入的参数类型为Callable类型(通过构造函数来包装Callable) 再将FutureTask的对象作为Thread的参数 */ FutureTask futureTask=new FutureTask(myThread01); Thread thread01=new Thread(futureTask); thread01.setName(\"t1\"); thread01.start(); System.out.println(futureTask.get());//可以得到call()方法的返回值 } } class MyThread01 implements Callable\u003cInteger\u003e { @Override public Integer call() throws Exception { System.out.println(Thread.currentThread().getName()+ \" is running\"); return 1024; } } /* t1 is running 1024 */ 小结： Callable规定的方法是call()，而Runnable规定的方法是run() Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。 call()方法可抛出异常，而run()方法是不能抛出异常的。 运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。 它提供了检查计算是否完成的方法，以等待计算的完成，并检索 计算的结果。 通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。 Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。 FutureTask FutureTask的关系图： 首先FutureTask实现了RunnableFuture接口 public class FutureTask\u003cV\u003e implements RunnableFuture\u003cV\u003e RunnableFuture接口实现了Future接口和Runnable接口 public interface RunnableFuture\u003cV\u003e extends Runnable, Future\u003cV\u003e { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } 看一看FutureTask的构造方法： public FutureTask(Callable\u003cV\u003e callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable } 可知FutureTask还可以包装Runnable和Callable 上面代码块可以看出：Runnable注入会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务。 小结： FutureTask实现Runnable，所以能通过Thread包装执行， FutureTask实现Runnable，所以能通过提交给ExcecuteService来执行，注：ExecuteService：创建线程池实例对象，其中有submit（Runnable）、submit（Callable）方法 还可以直接通过get()函数获取执行结果，该函数会阻塞，直到结果返回。 因此FutureTask是Future也是Runnable，又是包装了的Callable( 如果是Runnable最终也会被转换为Callable )。 因为FutureTask实现了Runnable接口，又能够通过构造方法包装Callable，所以能够借由FutureTask来通过Callable来创建线程。 执行器 1.构造线程池: 通过Executors类的静态方法newCachedThreadPoll或newFixedThreadPoll来创建线程池 2.将Runnable或Callable对象提交给ExecutorService 调用submit提交Runnable或Callable对象 Future\u003cT\u003e submit(Callable\u003cT\u003e task) Future\u003c?\u003e submit(Runnable task) Future\u003cT\u003e submit(Runnable task,T result) 调用submit时会返回一个Future对象，可用来得到结果或者取消任务 而调用execute时没有返回结果 3.关闭线程池 shutdown：被关闭的执行器不再接收新的任务，当所有任务执行完成后，线程池中的线程死亡 shutdownNow：取消所有尚未开始的任务 继承关系图如下 例子： package ExecutorTest; import java.util.concurrent.*; /** * ClassName: ExecutorTest * Package: ExecutorTest * Description: * Datetime: 2020/11/30 上午11:12 * Author: shilongshen */ public class ExecutorTest { public static void main(String[] args) { ExecutorService executor= Executors.newCachedThreadPool();//Executors中的静态方法来创建线程池 MyThread myThread=new MyThread(); executor.submit(myThread);//通过submit提交Runnable对象 executor.shutdown();//关闭线程 } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\" is running\"); } } 线程池几个关键的属性 corePoolSize：线程池中最小的工作线程数量 maximumPoolSize：线程池最大线程数 keepAliveTime：空闲线程等待执行任务的超时时间（纳秒） workQueue：任务缓存队列，用来存放等待执行的任务 handler：任务拒绝策略 常见问题： 执行 execute()方法和 submit()方法的区别是什么呢？ execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； submit()方法用于提交需","date":"2020-11-27","objectID":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/:0:10","tags":null,"title":"并发总结","uri":"/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"什么是操作系统 操作系统所处的位置： 底层是硬件，包括芯片，电路板，硬盘，键盘等 硬件的上层是软件，软件又分为用户态和内核态 其中操作系统运行在内核态中，处于软件的最基础部分，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。 用户态的最低层次称为用户接口程序（用户与之交互的程序，基于文本的称为shell，基于图形界面的称为GUI），用户接口程序允许用户运行其他程序，例如web应用,电子邮件，音乐播放器。 文本模式登录后所取得的程序被称为壳（shell），这是因为这只程序负责最外面跟使用者（我们）打交道，所以被戏称为“壳” 在Linux中的shell为bash 操作系统本质上是一个运行在计算机的软件，用于管理计算机硬件和软件资源（操作系统是一个运行在内核态的软件） 操作系统屏蔽了硬件的复杂性 操作系统运行与裸机之上，为其他软件提供基础的运行环境 操作系统具有两种功能： 向应用程序提供抽象;例如将硬盘抽象为文件，使用该抽象，程序可以创建，读写文件，而不用直接和硬件打交道。 管理计算机资源;在相互竞争的程序间有序的控制对处理器、存储器以及其他I/O接口的分配。 什么是系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 线程中发生函数调用时, 就会在线程栈中分配函数调用栈, 而虚拟内存分配, 文件操作, 网络读写等很多功能都是由操作系统来实现的, 再向用户程序暴露接口, 所以线程免不了要调用操作系统提供的系统服务, 即系统调用. Linux 的系统调用主要有以下这些： Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 例： 如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统通过参数检查找出所需要的调用进程。然后，它执行系统调用，并将控制返回给系统调用后面跟随的指令。 1.什么是系统调用？ 系统调用是操作系统（OS）提供给用户编程时的一些公共子程序，一般为函数或方法 2.为什么要使用系统调用？ OS为了安全的管理计算机软硬件资源，不允许程序员直接操作系统资源，例如I/O，进程，内存，文件 但是用户可以通过系统调用向OS请求相关资源的服务，比如I/O额请求和释放；设备启动；文件的创建，读写，删除；进程的创建，阻塞，唤醒等 总结：系统调用就是程序员给操作系统发送请求服务的方法 或函数 好比，你去餐馆吃饭，你只需要向服务员点菜（系统调用），服务员就会处理你的请求，而不是你自己去做菜。 3.如何进行系统调用，操作系统如何响应？ 程序员在代码中首先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为核心态，并将返回地址压栈备用，然后 CPU 执行相应的内核服务程序，最后返回用户态。 根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别： 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。 内核态(kernel mode):可以简单的理解内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。 说了用户态和系统态之后，那么什么是系统调用呢？ 我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了！ 也就是说在我们运行的用户程序中，凡是与内核态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。 这些系统调用按功能大致可分为如下几类： 设备管理。完成设备的请求或释放，以及设备启动等功能。 文件管理。完成文件的读、写、创建及删除等功能。 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。 进程通信。完成进程之间的消息传递或信号传递等功能。 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。 1.进程和线程 什么是进程？（在并发总结中已经提及） 什么是线程？（在并发总结中已经提及） 进程和线程的区别（在并发总结中已经提及） 进程的状态实际上与线程的状态是一致的，包括了就绪（Ready）,运行（Running）和阻塞（blocked）//（在并发总结中已经提及） ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:0:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"线程和进程的区别 简单的理解： 进程是系统中的一个应用，进程不会相互影响。进程是程序运行的基本单位，系统运行一个程序就是一个进程从创建到灭亡的过程 一个进程中可以包含多个线程，一个线程开辟一个栈空间，假设有10个线程，就会开辟10个栈空间。但是不同线程之间是共享方法区和堆的。 栈是线程私用的，生命周期和线程相同，栈描述的是Java方法执行的线程内存模型：每个方法执行的时候都会同步创建一个栈帧用于存储局部变量表/操作数栈，动态连接。方法出口等信息。 堆是所有线程共享的区域。这在JVM启动时创建，此内存唯一的目的就是存放对象实例 方法区是所有线程共享的区域，用于存储已被JVM加载的类型信息，常量，静态常量，即时编译后的代码缓存片段。 这里要引入一个概念：除了CPU以外所有的执行环境，主要是寄存器的一些内容，就构成了进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存 --- 进程的颗粒度太大，每次的执行都要进行进程上下文的切换。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成： 程序A得到CPU -\u003e CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。 这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换线程的上下文，而没有进行进程上下文切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境的更为细小的CPU时间段。线程主要共享的是进程的地址空间。 作者：zhonyong 链接：https://www.zhihu.com/question/25532384/answer/81152571 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 小结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。参考 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"进程的实现 为了实现进程模型，操作系统维护这一张表格，即进程表（PCB）。每个进程占用一个进程表项（或称为进程控制块）。该表项中包括了进程的状态的重要信息，包括程序计数器，堆栈指针，内存分配状况，所打开文件的状态，账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断一样 注意：进程表是在操作系统中的（在内核态中） 再一次明确：进程切换的效率是比较低的 在切换进程时，首先用户态必须切换到内核态；然后保存当前进程的状态 ，包括在进程表中存储寄存器值以便以后重新加载。在许多系统中，内存映像也必须保存；接着，通过运行调度算法选定一个新进程；之后，应该将新进程的内存映像重新载入MMU（内存管理单元）中；最后，新进程开始运行。除此之外，进程切换还要使得整个内存高速缓存失效，强迫缓存从内存中动态重新载入两次（进入内核一次，出内核一次）。 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。 所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示： ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"为什么需要线程 主要原因：在一个进程中可能会同时发生多个活动。其中某一些活动随着时间的推移会被阻塞。通过将进程分解为多个线程，程序设计模式会变得简单 线程比进程更加的轻量化，所以线程比进程更容易创建和销毁。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"进程和线程的区别 Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 注意：一个进程中的所有线程都有完全一样的地址空间，这意味着他们也共享同样的全局变量（共享公共内存）。除了共享内存地址外，所有线程还共享同一个打开的文件集，子进程、定时器以及相关信号等。 一个进程总是由某个用户拥有，该用户创建多个线程是为了他们之间的相互合作而不是竞争。 而不同进程可能由不同用户拥有，不同进程间可能存在敌对关系。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"线程的分类 线程可以分为用户级线程和内核级线程，其调度算法与可以是进程的调用算法中的一种。 两者间的差异在于性能。 用户级线程的线程进行切换时只需要少量的机器指令，而内核级线程的线程进行切换时需要完整的上下文切换（修改内存映像，清理高速缓存等内容） 用户级线程可以使用专门为应用程序定制的线程调度算法 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"进程和程序的区别 举个例子： 有一位科学家在为他的女儿制作生日蛋糕。他有做蛋糕的食谱，厨房里有所需的原料。在这个比喻中，做蛋糕的食谱就是程序（即用适当形式描述的算法），科学家就是CPU，而做蛋糕的各种原料就是输入数据。进程就是科学家阅读食谱，取来各种原料以及烘制蛋糕等一系列动作的总和。 这里的关键思想是：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:1:5","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"进程间通信 讨论三个问题： 一个进程如何把信息传递给另一个 确保两个或更多的进程在关键活动中不会出现交叉 正确的顺序 竞争条件 有两个或多个进程读写同一共享数据，这两个进程可能会相互覆盖。取决与进程的访问次序，可能会导致共享数据被破坏。这称为竞争条件或竞态条件（ race condition ）（线程也有相似的概念） 临界区 临界区：对共享内存进行访问的程序片段 互斥：多个进程在同一时刻只有一个能进入临界区 忙等待互斥 实现互斥的几个方法（在这些方案中，当一个进程进入临界区更新共享内存时，其他进程不会进入临界区） 屏蔽中断 锁变量 严格轮换法 Peterson解法 TSL指令 睡眠与唤醒 信号量 信号量是一个整型变量，可以对其进行down和up操作，也就是常见的P , V 操作。 down： 如果信号量大于0，执行减1操作；如果信号量等于0，进程睡眠，等待信号量大于0. up： 对信号量进行加1操作，唤醒睡眠的进程让其进行down操作。 down和up被设置为原子操作，一旦一个信号量开始操作，则在该操作完成或阻塞之前，其他进程均不可以访问该信号量 。 原子操作：指一组相关联的操作要么不间断的执行，要么不执行。 互斥量 互斥量是一个处于两态之一的变量：解锁和加锁。 如果一个进程需要访问临界区，他将调用互斥量。如果该互斥量是解锁的，该进程则可以自由进入临界区 如果该互斥量是加锁的，调用进程将会阻塞，直到临界区中的进程完成。 如果有多个进程阻塞，则会随机选择选择一个进程并允许他获得锁。 管程 管程有一个重要的特性：即任何时刻管程中只能有一个活跃进程，这一特性使得管程能够高效的完成互斥。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞(使得进程进入等待队列)，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程（将等待队列中的进程放入锁池中）。 信息传递 屏障 避免锁 进程同步和进程通信间的区别 进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 进程通信 管道 管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 #include \u003cunistd.h\u003e int pipe(int fd[2]); 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。 FIFO 也称为命名管道，去除了管道只能在父子进程中使用的限制。 #include \u003csys/stat.h\u003e int mkfifo(const char *path, mode_t mode); int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列 相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 信号量 它是一个计数器，用于为多个进程提供对共享数据对象的访问。 共享存储 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 套接字 与其它通信机制不同的是，它可用于不同机器间的进程通信。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"调度 如果有多个进程或线程同时竞争CPU,那么就必须选择下一个要运行的进程或线程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序所使用的算法称为调度算法。 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"1. 批处理系统 批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 1.1 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 shortest job first（SJF） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 shortest remaining time next（SRTN） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"2. 交互式系统 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"3. 实时系统 实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 2. 内存管理 分层存储体系： 若干兆(MB) 快速，昂贵且易失的高速缓存（catch）-\u003e高速缓存的管理主要有硬件来完成 数千兆(GB) 速度和价格适中且同样易失的内存 -\u003e内存的管理由编程人员来完成,本章介绍的内容 几兆兆(TB) 低速，廉价，非易失的磁盘存储 DVD，USB等可移动存储装置 操作系统中管理分层存储体系的部分称为存储管理器，它的任务是有效的管理内存，即记录哪些内存是正在使用的，哪些是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存 操作系统的内存管理主要是做什么？ 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。 内存管理机制: ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:3:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"存储器的抽象：地址空间 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"什么是地址空间 地址空间为程序创造了一个抽象的内存。 地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下需要共享它们的地址空间外） ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"基址寄存器和界限寄存器 基址寄存器和界限寄存器提供为每一个进程提供了一个独立的地址空间 当一个进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。 每一次进程访问内存，取一条指令，读或写一个数据字，CPU硬件会把地址发送给内存总线之前，自动把基址值（当前程序的起始物理地址）加到进程发出的地址值上。同时，它检查程序提供的地址是否大于或等于界限寄存器里的值（当前程序的长度），如果访问地址超出了界限，就会产生错误并终止访问。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"交换技术 基址寄存器和界限寄存器的方法相当于将所有进程存在内存中。但是将所有进程存在内存中需要巨大的内存，若果内存不够，就做不到这一点。因此这一方法几乎不再使用了。 有两种处理内存超载的技术： 交换技术，把一个进程完整的调入内存，是该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时不会占用内存（其中有一些进程会周期性的被唤醒以完成工作，然后就会又进入休眠状态）。 虚拟内存， -\u003e接下来将介绍 注意一个问题：当进程被创建或换入时应该为它分配多大的内存? 如果进程的创建时其大小是不变的，则操作系统按照准确的大小进行内存分配即可。 如果进程的数据段是增长的，一种可用的分配策略为：当创建进程时为其分配一些额外的内存。当进程被换出到磁盘时，应该只交换进程实际上使用内存中的内容，因为将额外的内存交换出去是一种浪费。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"空闲内存管理 在动态分配内存的时候（在创建进程和将进程换出时，内存应该如何变化），操作系统必须对其进行管理。一般有两种跟踪内存使用情况的方式： 位图 空闲区链表 使用位图的存储管理 将内存划分为小到几个字或大到几千字节的分配单元。每个单元对应于位图中的一位，0表示空闲，1表示占用。 优点：利用一块固定大小的内存（用于存储位图）就能对内存使用情况进行记录 缺点：在决定把一个占用k个存储单元的进程调入内存时，存储管理器必须搜索位图，在位图中找出k个连续0的串。这是十分耗时的。 使用链表进行管理 维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个结点或包括一个进程，或包括两个进程间的一块空闲区 链表的每个结点包含以下内容：空闲区(H)或进程(P)的指示标记，起始地址，长度和指向下一个结点的指针。 优点：当进程被换出时，链表的更新是非常方便的。 当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以用来为创建的线程（或从磁盘中换入的线程）分配内存。 首次适配法 下次适配法 最佳适配法 最差适配法 快速适配法 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"虚拟内存 解决程序大于内存的问题 基本思想：每个程序拥有自己的地址空间，这个空间被分割为多块，每一块被称为一页或页面。每一页有连续的地址范围。这些页被映射到物理内存中，但是并不是所有页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。 注意：上述表述的可以理解为：虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存中，也就是一个程序不需要全部调用内存就可以运行。（如果调用到了不在物理空间中的内存地址，操作就将其装入物理内存中重新执行）， 这使得有限的内存运行大程序成为可能。 分页 由程序产生的地址称为虚拟地址，他们构成了一个虚拟地址空间。虚拟地址空间按照固定大小划分为被称为页面的若干单元。在物理内存中对应的单元被称为页框。页面和页框的大小通常是一致的。 例子： 当程序试图访问地址0时，例如执行了一下这条指令： MOV REG ,0 将虚拟地址0送入MMU。MMU看到虚拟地址落在页面0（0-4095），根据其映射结果，这一页面对应的是页框2（8192-12287），因此MMU把地址变换为8192，并把地址8192送到总线上。内存对MMU一无所知，它只看到一个读或写地址8192的请求并执行它。MMU从而有效的将所有0-4095的虚拟内存地址映射到了8192-12287的物理地址。 假设有64K的虚拟地址空间和32K的物理内存地址，页面和页框的大小为4K，那么一共有16个页面和8个页框。因此只有8个页面被映射到了物理内存地址中。还有8个页面没有被映射到物理内存地址，如何为解决这一问题？ 在实际的硬件中，用一个标记位“在/不在”来记录页面在内存中的实际存在情况。 当程序访问当了一个未被映射的页面，MMU会注意到该页面没有被映射（通过标记位来识别），于是CPU陷入到操作系统中，这个陷阱称为页面中断或缺页错误。操作系统找到一个很少使用的页框并将它的内容写到磁盘中（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。 MMU的内部结构： 虚拟地址到物理地址的映射可以概括如下：虚拟地址被分为虚拟页号和偏移量。 虚拟页号可用于页表的索引，以便找到虚拟页面对应的页表项。由页表项可以找到页框项（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。 页表的目的是吧虚拟页面映射为页框。 需要强调的是：虚拟内存本质上用来创造一个新的抽象概念-地址空间，这个概念是对物理地址的抽象，类似于进程是对CPU 的抽象。虚拟内存的实现，是将虚拟地址空间分解为页，并将每一页映射到物理内存的某个页框或者解除映射。 页面转换算法 回顾：缺页中断-当程序访问当了一个未被映射的页面，MMU会注意到该页面没有被映射（通过标记位来识别），于是CPU陷入到操作系统中，这个陷阱称为页面中断或缺页错误。操作系统找到一个\u003cu\u003e很少使用的页框并将它的内容写到磁盘中\u003c/u\u003e（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，\u003cu\u003e修改映射关系\u003c/u\u003e，然后重新启动引起陷阱的指令。 在程序运行过程中，如果要访问的页面不在内存（访问到了一个未被映射的页面）中，就发生缺页中断从而将该页调入内存中。 页面置换： 当发生缺页中断时，操作系统就必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。 对于换出内存的页面存在两种情况： 如果换出的页面在内存驻留期间已经被修改过了，就必须将它写回磁盘以更新该页面在磁盘上的副本 如果该页面没有被修改过，那么他在磁盘上的副本已经是最新的，不需要回写。直接用调入的页面覆盖被淘汰的页面就可以了。 注意：页面置换是发生在缺页中断的情况下的。当访问到了一个未被映射的页面才会发生缺页中断。 当发生缺页中断时，虽然可以随机的选择一个页面来置换，但是如果每次都选择不常使用的页面会提升系统的性能。 页面置换算法: 最优页面置换算法 原理：在缺页中断发生时，有些页面在内存中，其中一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要到10,100或1000条指令才会被访问，每个页面都可以用在该页面首次被访问前所要被访问的指令数作为标记。最优页面置换算法规定应该置换标记最大的页面。 这种算法的缺点是无法实现，因为我们在发生缺页中断时无法得知每个页面首次被访问的指令数。 最近未使用页面置换算法（NRU） 每个页面都有两个状态位，R与M，当页面被访问时，R被置为1，当页面被修改时，M被置为1.其中R会被定时清零，比如每个20ms被清零。可以根据R和M分为将页面分为4个状态： R=0，M=0 ，没有被访问，没有被修改 R=0，M=1 ， 没有被访问，被修改 R=1，M=0 ， 被访问，没有被修改 R=1，M=1 ， 被访问，被修改 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类（R=0，M=1）中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 先入先出置换算法（FIFO） 原理：由操作系统维护一个所有当前在内存中的所有页面的链表，最新进入的页面放在链表尾部，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加入表尾。 很少使用纯粹的先入先出置换算法。 第二次机会页面置换算法 FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法进行修改。 检查最老页面的R位。如果R位为0，那么这个页面既老又没被使用，可以立刻置换掉；如果R为1，就将其 R位清零，并把该页面放到链表的尾部，修改它的装入时间使得它就像刚装入一样，然后继续搜索。 时钟页面置换算法 尽管第二次机会算法比较合理，但是经常需要在链表中移动页面，既降低了效率，又不是很有必要。 一个更好的方法是将所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。 原理：当发生缺页中断时，算法首先检查表针指向的页面，如果R为0，则将其页面进行淘汰，并把一个新页面插入此处，然后将表针向前移一位；如果R为1，则将表针向前移一位，重复这一过程真到找到了R为0 的页面。 最近最少使用页面算法（LRU） 原理：在缺页中断发生时，置换未使用时间最长的页面。 虽然LRU在理论上是可行的，但是代价很高。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。 分段 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 段页式 程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分页与分段的比较 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 3. 输入/输出 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:4:5","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"I/O硬件原理 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"I/O设备 I/O设备可以大致分为两类：块设备和字符设备 块设备：将信息存储在固定大小的块中，每个块有自己的地址。所有的传输以一个或多个完整的（连续的）块为单位。块设备的基本特征是每个块都能独立于其他块进行读写。硬盘，光盘和USB盘是常见的块设备。 字符设备：以字符为单位发送和接收一个字符流，而不考虑任何块结构。打印机、网络接口、鼠标，以及大多数与磁盘不同的设备都可以看做字符设备。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"设备管理器 I/O设备由机械部分和电子部分组成。电子部分称为设备控制器或适配器，常以主板上的芯片的形式出现。 设备控制器的任务是把串行的位流转换为字节流，并进行必要的错误校正工作。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"内存映射I/O CPU与设备管理器进行通信的方式 每个控制器有几个寄存器用来与CPU进行通信。通过读写这些寄存器，操作系统可以了解设备的状态或控制设备。 除了控制寄存器外，许多设备还有一个操作系统可以读写的数据缓冲区。 CPU如何与设备的控制寄存器和缓冲区进行通信？ 方法1：每个控制寄存器被分配一个I/O端口号 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"直接存储器存储（DMA） 方法2： ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"重温中断 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:5:5","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"I/O软件原理 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"I/O软件的目标 设备独立性。应该能够编写出这样的程序：它能够访问任意I/O设备而无需事先指定设备。 错误处理 同步和异步传输 缓冲 I/O可以通过三种不同的方式来实现，1.程序控制I/O，2.中断驱动I/O，3.使用DMA的I/O ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"程序控制I/O 基本思路：在程序（设备驱动程序）中通过不断地检测I/O设备的当前状态，来控制I/O操作的完成。具体来说，在进行I/O操作之前，要循环地检测设备是否就绪；在I/O操作进行之中，要循环地检测设备是否已完成。从硬件来说，控制I/O的所有工作均由CPU来完成。 也称为繁忙等待方式（busy waiting)或轮询方式（polling)。 缺点：在进行I/O操作时，一直占用CPU时间。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"中断驱动I/O 循环检测的控制方法占用了太多的CPU时间，可能会造成CPU时间的浪费。例如：假设打印机的打印速度为100字符/秒，在循环检测方式下，当一个字符被写入到打印机的数据寄存器中后，CPU需要等待10毫秒才能写入下一个字符。 一种解决的办法：中断驱动的控制方式。 1 //系统调用函数print 2 copy_from_user(buffer,p,count);//p:内核缓冲区 3 enable_interrupts()； 4 while(*printer_status_reg!=READY)； 5 *printer_data_register=p[0]; 6 scheduler()； 在执行系统调用函数print时进程是否切换？没有切换，A仍为运行状态，但执行的代码是操作系统代码 1 //中断处理程序 2 if(count==0) 3 { 4 unblock_user(); 5 } 6 else 7 { 8 *printer_data_register=p[++i]; 9 count--； 10 } 11 acknowledge_intereupt()； 12 return_from_interrupt()； 中断驱动方式的基本思路是：用户进程通过系统调用函数来发起I/O操作，并在发起后阻塞该进程，调度其他的进程使用CPU。在I/O操作完成时，设备向CPU发出中断，然后在中断处理程序中做进一步的处理。在中断驱动方式下，数据的每次读写还是通过CPU来完成，但是当I/O设备在进行数据处理时，CPU不必等待，可以继续执行其他的进程。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用DMA的I/O 适合大规模数据传输！ I/O读操作的典型过程： -CPU向设备控制器发出命令，启动读操作； -设备控制器控制I/O设备完成此次读操作，并将数据保存在设备控制器内部的寄存器或缓冲区中，然后中断CPU； ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:6:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"I/O软件层次 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:7:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"盘 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:8:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"磁盘结构 盘面（Platter）：一个磁盘有多个盘面 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道 扇区(Track Sector)：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理存储单位，目前主要有512bytes和4K两种大小 磁头（Head）：与盘面非常接近，能够将判别上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写） 制动手臂（Actuator arm）:用于在磁道中移动磁头 主轴（Spindle）：使得整个盘面转动。 下面将分别介绍 磁道（Track）如下图，数据存储在磁道上 扇区： 如何确定数据存储在硬盘上的哪一个位置，实现快速读写数据（这么多文件存在磁盘上该如何快速的找到需要读写的数据呢？） 有两种方式： ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:8:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"分区表 在写数据时，再将数据存储到磁道后，会将分区表中记录数据存储位置对应的扇区和簇，这能够大致的定位数据的位置 在读数据时，首先在查找分区表，找到数据对应的存储位置并进行读取（通过移动磁头）。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:8:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"cache 通过精确的映射到数据存储的位置 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:8:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"磁盘调度算法 读写一个磁盘块需要多长时间，取决与以下三点： 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 旋转时间（主轴转动盘面，使得磁头移动到适当的扇面上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使得磁盘的姘居寻道时间最短。 1.先来先服务 FCFS，First Come First Served 磁盘的驱动程序每次接收一个请求并按照接收顺序完成请求。 优点：公平和简单 缺点：因为未对寻道做任何优化，使平均寻道时间可能较长。 2.最短寻道时间优先 SSTF，Shortest Seek Time First 下一次总是处理与磁头距离最近的请求以使寻道时间最小化。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 3.电梯算法 SCAN 电梯总是保持一个方法运行，直到该方向没有请求为止，然后改变运行方向。 电梯算法（扫描算法）和电梯的运行过程类似，总是按照一个方向来进行磁盘调度，知道该方向上没有未完成的磁盘请求，然后改变方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决SSTF的界问题。 4. 死锁 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:8:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"资源 简单的来说，资源就是随着时间的推移，必须能够获取、使用以及释放的任何东西。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:9:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"可抢占资源和不可抢占资源 可抢占资源：可以从拥有它的进程中抢占而不会产生任何的副作用，存储器就是一类可抢占资源 不可抢占资源：在不引起相关计算失败的情况下，无法将它从占有它的进程处抢占过来。 死锁与不可抢占资源有关。 有关可抢占资源的潜在死锁通常可以通过在进程之间重新分配资源而化解。 使用一个资源需要的事件顺序可以抽象为： 请求资源 使用资源 释放资源 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:9:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"资源获取 一种允许用户管理资源的可能方法是为每一个资源配置一个信号量。 现在考虑两个进程和两个资源的情况：当进程A获取了资源1，进程B获取了资源2，每个进程如果都想要请求另一个资源就会被阻塞，那么，每个进程都无法继续运行。这种情况就是死锁。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:9:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"死锁简介 定义：如果一个进程集合中的每一个进程都在等待只能够由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。 所有进程都在无限期的等待，就造成了死锁 在大多数情况下，每个进程所等待的事件是释放进程集合中其他进程所占用的资源。这种资源称为资源死锁，是最常见类型的死锁，但是不是唯一的类型。 资源是事件的一种，还有其他类型的事件。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:10:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"资源死锁的条件 资源死锁的四个必要条件： 互斥条件：每个资源要么就是分配给了一个进程（要有只能有一个，不能有多个），要么就是可用的 占有和等待条件：已经得到某个资源的进程可以再请求得到另外的资源 不可抢占条件：已经分配给一个进程的资源不能够强制性的抢占，只能够由占有它的进程显式的释放 环路等待条件：死锁发生时，一定有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待这下一个进程所占有的资源。 死锁发生时，上述四个条件一定是同时满足的。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:10:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"死锁建模 资源分配图：在有向图中，用圆形表示进程，用方形表示资源。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 资源分配图可以作为一种分析工具。如果其中有环路就说明有死锁，反之则没有死锁。 有四种处理死锁的策略： 忽略该问题。如果也许你忽略它，它就会忽略你。（？） 检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题 仔细对资源进行分配，动态避免死锁发生 通过破坏引起死锁的四个必要条件之一，防止死锁的发生 下面将分别讨论这四种方法。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:10:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"鸵鸟算法 把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:11:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"死锁检测和死锁恢复 在使用这种技术时，系统并不试图阻止死锁的发生，而是允许死锁发生，当检测到死锁发生后，采用措施进行恢复。 以下将考察检测死锁的几种方法以及恢复死锁的几种方法。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:12:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"每种类型一个资源的死锁检测 最简单的情况，即每种资源类型只有一个资源。这样的系统可能有扫描仪、打印机，但是每种设备都不超过一个，即排除了同时有两台打印机的情况。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 如果从任何给定的结点出发的弧都被穷举了，那么就回溯到前面的节点。如果回溯到根并且不能够再深入下去，那么从当前节点出发的子图就不包含任何环。如果所有节点都是如此，那么整个图就不存在环，也就是说系统不存在死锁。 该算法对节点次序是任意的，例如我们选择R-A-B-C-S…作为访问次序。 从R开始，R-\u003eA-\u003eS, S节点没有出发的弧，所以是一条死路，所以回溯到A，回溯到R。 再选A，这次检索页很快结束了 再选B，B-\u003eT-\u003eE-\u003eV-\u003eG-\u003eU-\u003eD，然后随机选择，例如选择了S, S节点没有出发的弧，所以是一条死路,回溯到D，然后选择T，此时为：B-\u003eT-\u003eE-\u003eV-\u003eG-\u003eU-\u003eD-\u003eT。在这一节点上发现了环，算法结束。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:12:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"每种类型多个资源的死锁检测 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:12:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"从死锁中恢复 假设死锁检测算法成功检测到了死锁，下一步需要一些方法是系统重新正常工作。以下将讨论各种从死锁中恢复的方法 利用抢占恢复 将不通知原进程的情况下将某一个资源强行的（使用人工方法）方法取走，并给另一个进程使用，然后再将该资源还给原来的进程。 利用回滚恢复 当了解死锁有可能发生时，就可以周期性的对进程进行检查点检查。 一旦检测到死锁，就很容易发现需要哪些资源。为了进行恢复，要从一个较早的检查点上开始，这样拥有所需要资源的进程会回滚到一个时间点，在此时间点之前该进程获得了一些其他资源。在该检查点之后所做的所有工作都丢失了。 通知杀死进程恢复 杀死一个或若干个进程。 杀死环中的一个进程 杀死环外的一个进程以释放该进程的资源 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:12:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"死锁避免 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:13:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"安全状态和不安全状态 如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也依然存在某一种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:13:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"单个资源的银行家算法 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:13:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:13:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"死锁预防 死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的。 那么实际系统是如何避免死锁的，我们可以从死锁的四个必要条件出发。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:14:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"破坏互斥条件 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 如果资源不被一个进程所独占，那么死锁肯定不会发生。允许两个进程同时使用打印机会造成混乱，通过采用假脱机打印机技术可以允许若干个进程同时产生输出。该模型唯一真正请求使用物理打印机的进程是打印机守护进程，由于守护进程绝不会请求别的资源，所以不会因打印机而产生死锁。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:14:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"破坏占有并等待条件 禁止已经持有资源的进程在等待其他资源便可以消除死锁。 一种实现方法是规定所有进程在开始执行前请求所需的全部资源。如果所需的全部资源可用，那么就将他们分配给这个进程，于是该进程肯定能够运行结束。如果有一个或多个资源正在被使用，那么就不进行分配，进程等待。 这种方法的一个直接问题是很多进程知道运行时才知道它需要多少资源。实际上如果进程知道它需要多少资源，就可以使用银行家算法，另一个问题时这种方法的资源利用率不是最高的。 另一种方法是当一个进程请求资源时，先暂停释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:14:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"破坏不可抢占资源 一些资源可以通过虚拟化的方式来避免发生这样的情况。假脱机打印机项磁盘输出，并且只允许打印机守护进程访问真正的物理打印机。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:14:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"破坏环路等待条件 消除环路等待有几种方法 一种是保证每一个进程在任意时刻只能占用一个资源，如果要请求另外一个资源，它必须先释放第一个资源。 另一种方法是将所有资源进行统一编号，进程可以在任意时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:14:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"其他问题 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:0","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"通信死锁 资源死锁是竞争性同步问题。进程在执行过程中如果与竞争的进程无交叉，便会顺利执行。进程将资源死锁，是为了防止交替访问资源而产生不一致的资源状态。交替访问加锁的资源将会可能产生死锁。 资源死锁是一种最普遍的类型，但不是唯一的一种。另一种死锁发生在通信过程中，即两个或两个以上的进程利用发送信息来通信时。一种普遍的情形是进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B会阻塞等待一个向其发送命令的请求，因此发生死锁。我们把上面这种情况称为通信死锁，通信死锁是协同死锁的异常情况。 用于中断通信死锁的技术称为超时；在大多数网络通信系统中，只要一个信息被发送到一个特定的地方，并等待其返回一个特定的回复，发送者就同时启动计时器。若计时器在回复到达前计时就停止了，则信息的发送者可以认定信息已经丢失了，并重新发送。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:1","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"活锁 在某些情况下，当进程意识到它不能够获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待1ms，在尝试一次。 从理论上来说，这是用来检测并预防死锁的号方法。但是，如果另一个进程在相同的时刻做了相同的操作，那么就像两个人在一条路上相遇并同时给对方让路，相同的步调将导致双方都无法前进。这种情况可以称之为活锁 参考 https://github.com/CyC2018/CS-Notes 现代操作系统（第4版） 相关问题： ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:2","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"1、什么是多道程序系统？ 多道程序系统是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行(系统由一个程序转而运行另一个程序时需要使用中断机构中断正在运行的程序) 。 两个或两个以上程序在计算机系统中同处于开始和结束之间的状态，这就称为多道程序系统。其技术运行的特征：多道、宏观上并行、微观上串行。 2、在多道程序设计系统中，如何理解“内存中的多个程序的执行过程交织在一起，大家都在走走停停”这样一个现象？ 在多道程序设计系统中，内存中存放多个程序，它们以交替的方式使用CPU。因此，从宏观上看，这些程序都开始了自己的工作。但由于CPU只有一个，在任何时刻CPU只能执行一个进程程序。所以这些进程程序的执行过程是交织在一起的。也就是说，从微观上看，每一个进程一会儿在向前走，一会儿又停步不前，处于一种“走走停停”的状态之中。 3、什么是“多道程序设计”技术？它对操作系统的形成起到什么作用？ 所谓“多道程序设计”技术，即是通过软件的手段，允许在计算机内存中同时存放几道相互独立的作业程序，让它们对系统中的资源进行“共享”和“竞争”，以使系统中的各种资源尽可能地满负荷工作，从而提高整个计算机系统的使用效率。基于这种考虑，计算机科学家开始把CPU、存储器、外部设备以及各种软件都视为计算机系统的“资源”，并逐步设计出一种软件来管理这些资源，不仅使它们能够得到合理地使用，而且还要高效地使用。具有这种功能的软件就是“操作系统”。所以，“多道程序设计”的出现，加快了操作系统的诞生。 4、为什么说批处理多道系统能极大地提高计算机系统的工作效率？ ① 多道作业并行工作，减少了处理器的空闲时间。 ② 作业调度可以合理选择装入主存储器中的作业，充分利用计算机系统的资源。 ③ 作业执行过程中不再访问低速设备，而直接访问高速的磁盘设备，缩短执行时间。 ④ 作业成批输入，减少了从操作到作业的交接时间。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:3","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"2、从使用的角度来分析设备的特性，可以把设备分为（）。 独占设备和共享设备 独占设备：打印机； 共享设备：磁盘。 可以同时使用的就是共享设备，不可以同时使用的是独占设备，当然如果使用SPOOLing技术，可以使得打印机似乎可以“同时使用”。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:4","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"3、访管指令能引起访管中断，它本身属于特权指令（ ） 错误 执行访管指令会产生一个中断事件，从而将CPU从用户态转换到核心态。而访管指令本身是在用户态下执行的。（理解） 特权指令是在核心态下执行的指令。 所以访管指令不是特权指令。 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:5","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"4、下列有关进程的说法中，错误的是 进程与程序是一一对应的 进程与作业是一一对应的 进程是静态的 进程是动态的过程 正确答案: A B C A. 错误 \\1. 进程是程序的一次执行过程，是动态的，有生命期，可动态产生和消亡。 \\2. 程序作为软件资源保存，是静态的。 \\3. 程序与进程无一一对应关系。【一个程序(资源)可以由多个进程使用。一个进程也可以有序地执行若干程序。】 B.错误 \\1. 作业是由一系列有序步骤组成，经过 【作业提交 作业收容 作业执行 作业完成】四个阶段。 \\2. 一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。 C.错误 D.正确 ","date":"2020-11-27","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/:15:6","tags":null,"title":"操作系统基础","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"将ArrayList转换为数组 方法1：利用循环语句将ArrayList中的元素添加到数组中 public class ArrayListTest { public static void main(String[] args) { List\u003cInteger\u003e list =new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); int[] b=new int[list.size()]; for (int i=0;i\u003clist.size();i++){ b[i]= list.get(i); } for (int s:b){ System.out.println(s); } } } 方法2：使用ArrayList中的toArray方法，将Arraylist转换为数组 public class ArrayListTest { public static void main(String[] args) { List\u003cInteger\u003e list =new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); Integer[] a=new Integer[list.size()];//注意这里的数组类型为Integer,引用类型，而不是int，基本类型 list.toArray(a); for (Integer s:a){ System.out.println(s); } } } 这里需要注意的是ArrayList中的toArray方法，有两个重载方法 1.public Object[] toArray() 2.public \u003cT\u003e T[] toArray(T[] a) 对于public Object[] toArray()返回的是一个Object数组 对于public \u003cT\u003e T[] toArray(T[] a)能将list转化为你所需要类型的数组，当然我们用的时候会转化为与list内容相同的类型 对于第一种方法存在的局限性是，该方法只能够返回Object数组，而不能返回你所需要类型的数组，例如 List\u003cInteger\u003e list =new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); Integer[] s=list.toArray(); for (Integer s1:s){ System.out.println(s); } 会报错： java: 不兼容的类型: java.lang.Object[]无法转换为java.lang.Integer[]//向下转型失败 表明只能够返回Object类型数组 第二种方法就比较方便，可以转换为我们想要的类型 List\u003cInteger\u003e list =new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); Integer[] a=new Integer[list.size()];//注意这里的数组类型为Integer,引用类型，而不是int，基本类型 list.toArray(a);//会自动推断传入参数的类型 for (Integer s:a){ System.out.println(s); } 但是如果是这样写 List\u003cInteger\u003e list =new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); int[] a=new int[list.size()]; list.toArray(a); for (Integer s:a){ System.out.println(s); } 会报错： java: 对于toArray(int[]), 找不到合适的方法 方法 java.util.Collection.\u003cT\u003etoArray(java.util.function.IntFunction\u003cT[]\u003e)不适用 (无法推断类型变量 T (参数不匹配; int[]无法转换为java.util.function.IntFunction\u003cT[]\u003e)) 方法 java.util.List.\u003cT\u003etoArray(T[])不适用 (推论变量 T 具有不兼容的上限 等式约束条件：int 下限：java.lang.Object) 可以看出此时编译器无法推断出传入toArray中参数的类型，似乎传入的参数必须是引用类型（必须继承Object） ","date":"2020-11-25","objectID":"/arraylist%E4%B8%8E%E6%95%B0%E7%BB%84%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:0:1","tags":null,"title":"ArrayList与数组之间的相互转换","uri":"/arraylist%E4%B8%8E%E6%95%B0%E7%BB%84%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["Java学习笔记"],"content":"将数组转换为ArrayList 使用Arrays.asList public class ArrayListTest02 { public static void main(String[] args) { String[] s={\"1\",\"2\",\"3\"}; List\u003cString\u003e list=new ArrayList\u003c\u003e(); list= Arrays.asList(s); for (String a:list){ System.out.println(a); } } } 不过通过list= Arrays.asList(s);直接赋值存在的一个缺点是list无法添加或删除元素，例如 String[] s={\"1\",\"2\",\"3\"}; List\u003cString\u003e list=new ArrayList\u003c\u003e(); list= Arrays.asList(s); for (String a:list){ System.out.println(a); } list.add(\"lll\");//添加元素 会报错 Exception in thread \"main\" java.lang.UnsupportedOperationException at java.base/java.util.AbstractList.add(AbstractList.java:153) at java.base/java.util.AbstractList.add(AbstractList.java:111) at CollectionTest.ArrayListTest02.main(ArrayListTest02.java:22) 此时可以通过ArrayList的构造方法 public ArrayList(Collection\u003c? extends E\u003e c) 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 进行转换，如 public class ArrayListTest02 { public static void main(String[] args) { String[] s={\"1\",\"2\",\"3\"}; List\u003cString\u003e list1=new ArrayList\u003c\u003e(Arrays.asList(s)); list1.add(\"lll\"); for (String s1:list1){ System.out.println(s1); } } } 此时可以添加/删除元素。 ","date":"2020-11-25","objectID":"/arraylist%E4%B8%8E%E6%95%B0%E7%BB%84%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:0:2","tags":null,"title":"ArrayList与数组之间的相互转换","uri":"/arraylist%E4%B8%8E%E6%95%B0%E7%BB%84%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["Java学习笔记"],"content":"异常分类 所有的异常都派生于Throwable,在下一层又分解为Error和Exception。 Error类层次描述Java运行时系统的内部错误和资源耗尽错误，发生这类错误时，除了通知错误并尽力妥善终止程序外，你几乎无能为力，这一类错误很少发生。 Exception类又分为Runtime Exception和其他Exception。 Java将异常进行分类： 非检查型异常（unchecked）：派生于Error类和Runtime Exception类的所有异常 检查型异常（checked）:其他所有异常 需要为所有检查型异常提供异常处理器。 ","date":"2020-11-25","objectID":"/%E5%BC%82%E5%B8%B8/:0:1","tags":null,"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["Java学习笔记"],"content":"声明检查型异常 一个方法必须声明所有可能抛出的检查型异常，如果没有声明，编译器就会发出一个错误警告 声明的方法：在方法首部通过throws 声明这个方法可能抛出的检查型异常，例如 class Test{ public Image LoadImage(String s) throws IOException{ ... } } 这里需要注意的是： 如果子类覆写父类的方法，那么子类的这个方法声明的异常不能比父类更加通用。子类中的方法可以声明更加特殊的异常或不声明异常 如果父类中的方法没有声明任何异常，那么子类的方法也不能声明异常 ","date":"2020-11-25","objectID":"/%E5%BC%82%E5%B8%B8/:0:2","tags":null,"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["Java学习笔记"],"content":"如何抛出异常 例： String readData(Scanner in) throws EOFException{ while(){ if(!in.hasNext()){ if(n\u003clen){ throw new EOFException;//抛出异常 } } } return s; } 抛出异常的方法： 找到一个合适的异常类 创建这个类的一个对象 将对象抛出 一旦方法抛出了异常，这个方法就不会返回到调用者。 或者是通过throws进行抛出，具体的用法和声明异常一样，即在方法首部通过throws 抛出异常 throw 和throws的区别：参考 throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。 throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。 throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。 throw是具体向外抛异常的动作，所以它是抛出一个异常实例。 throws说明你有那个可能，倾向。 throw的话，那就是你把那个倾向变成真实的了。 同时： 1、throws出现在方法函数头；而throw出现在函数体。 2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 例： void doA(int a) throws Exception1,Exception3{ try{ ...... }catch(Exception1 e){ throw e; }catch(Exception2 e){ System.out.println(\"出错了！\"); } if(a!=b) throw new Exception3(\"自定义异常\"); } 代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。 如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理。 如果产生Exception2异常，则该方法自己处理了（即System.out.println(“出错了！\");）。所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了。 而Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。 ","date":"2020-11-25","objectID":"/%E5%BC%82%E5%B8%B8/:0:3","tags":null,"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["Java学习笔记"],"content":"捕获异常 如果只是声明异常或者是抛出异常而没有捕获异常，当发生异常时，程序就会终止，并在控制台上打印出一个消息。 如果捕获了异常程序不会立即终止，而是会对异常进行相应的处理 这里需要注意的是 检查型异常必须声明，而非检查型异常可以不用声明（也可以声明，但是一般是不用声明的） 检查型异常和非检查型异常都可以被捕获（但是一般都是捕获检查型异常） 实际上我们非检查型异常的处理是：对于Error异常，描述Java运行时系统的内部错误和资源耗尽错误，对于这类错误是无能为力的；对于Runtime Exception 异常，是运行时的异常，例如数组越界等，这是我们在编写程序时就应该避免发生的。而对于检查型异常，例如一个文件是否存在，我们就需要对其进行声明或捕获或抛出 捕获异常的语句块： try{ code } catch(ExceptionType e){ handle for this Type } finally{ must do } 执行逻辑 如果try中某一语句抛出了catch子句指定的异常类，那么 程序将跳过try语句中的其余代码 程序执行catch字句中的处理代码 如果try中语句没有抛出任何异常，那么程序就会跳过catch语句 如果try中某一语句抛出了catch子句中没有声明的异常类，方法就会结束（应该尽量避免出现这种情况） 无论前面是什么情况，finally语句中的代码一定会执行 例子：参考 throw,throws和try...catch 1、throws出现在方法函数头；而throw出现在函数体。 2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 也就是异常处理是会一层层往上抛的，直到遇到了某个方法(try…catch)处理了这个异常或者最后抛给了JVM. package abnormalTest; import java.io.IOException; //定义一个测试类，检查JAVA中的异常处理机制 public class Test { int age; public void Abnormal() throws IOException{ int i=0; int x=5/i; System.out.println(x); } //主函数入口 public static void main(String[] args) throws IOException { Test t=new Test(); t.Abnormal(); } } 分析：我们这里直接使用了JAVA中的IOException对象，由于我们在main函数中没有对这个异常进行处理，所以我们要给main函数加上throws IOException，指明我不想处理这个异常，请帮我把它抛给上一级。于是这个异常就被抛给了JAVA虚拟机，JAVA虚拟机根据IOException所带的异常信息，判断这是一个整数除以0的异常，于是终止程序，并且打印出”/ by zero\"的报错信息。 如果我们要对上一级方法中抛出来的异常进行处理，那么必须用到try…catch的结构。测试样例如下： package abnormalTest; import java.io.IOException; //定义一个测试类，检查JAVA中的异常处理机制 public class Test { int age; public void Abnormal() throws IOException { int i=0; if(i==0) { throw new IOException(\"除以0错误\"); } int x=5/i; System.out.println(x); } //主函数入口 public static void main(String[] args) { try { Test t=new Test(); t.Abnormal(); }catch(IOException e){ System.out.println(\"出现了IOException异常\"); }catch(NullPointerException e) { System.out.println(\"出现了空指针异常\"); } } } 运行结果如下。这里打印出的是catch中的异常处理信息“出现了IOException”，而没有打印出\"除以0错误”，说明这个异常在main函数中处理完就终止了，没有继续往上抛给JVM，这和我们前面的分析是一致的。然后我们这里定义两个catch方法分别来处理IOException和NullPointerException两种不同的异常 throw/throws把异常一层层地往上抛，直到有人去处理它。而try...catch就是那个劳苦工人，负责获取相应的异常并对它进行处理。 相关问题： 有关finally语句块说法正确的是（A B C ） A 不管catch是否捕获异常，finally语句块都是要被执行的 B 在try语句块或catch语句块中执行到System.exit(0)直接退出程序 C finally块中的return语句会覆盖try块中的return返回 D finally 语句块在 catch语句块中的return语句之前执行 结论： 1、不管有木有出现异常，finally块中代码都会执行； 2、当try和catch中有return时，finally仍然会执行； 3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的； 4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 举例： 情况1：try{} catch(){}finally{} return; 显然程序按顺序执行。 情况2:try{ return; }catch(){} finally{} return; 程序执行try块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，最后执行try中return; finally块之后的语句return，因为程序在try中已经return所以不再执行。 情况3:try{ } catch(){return;} finally{} return; 程序先执行try，如果遇到异常执行catch块， 有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码， 最后执行catch块中return. finally之后也就是4处的代码不再执行。 无异常：执行完try再finally再return. 情况4:try{ return; }catch(){} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，因为finally块中有return所以提前退出。 情况5:try{} catch(){return;}finally{return;} 程序执行catch块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，因为finally块中有return所以提前退出。 情况6:try{ return;}catch(){return;} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码； 有异常：执行catch块中return之前（包括return语句中的表达式运算）代码； 则再执行finally块，因为finally块中有return所以提前退出。 无异常：则再执行finally块，因为finally块中有return所以提前退出。 最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。 如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的， 编译器把finally中的return实现为一个warning。 ","date":"2020-11-25","objectID":"/%E5%BC%82%E5%B8%B8/:0:4","tags":null,"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["Java学习笔记"],"content":"在Arrays类中的sort方法能够对对象数组进行排序，但是我们知道，排序要有排序规则，如果是自定义的类，必须明确这些规则才能够使用Arrays.sort方法对对象数组进行排序。实际上这些排序规则就是一种比较规则。 对于基本数据类型,例如int等，或者是常用的对象,例如String ,其本身就定义了比较规则，因此我们不需要在重新定义比较规则。但是对于我们自己定义的类就必须重新定义比较规则。 在Java中实现Arrays.sort数组排序有两种方式： 实现Comparable接口，并覆写compareTo方法。在调用Arrays.sort只需要传入对象数组即可 在调用Arrays.sort时需要传入一个数组和一个比较器作为参数。比较器是实现了Comparator接口中compare方法的类的的实例。 首先来看第一种方式 类实现Comparable类中的compareTo方法，Arrays.sort传入对象数组 public class ArraysTest { public static void main(String[] args) { Employee[] employees=new Employee[3];//构建一个对象数组 employees[0]=new Employee(10000,\"xiaoming\"); employees[1]=new Employee(20000,\"xiaohong\"); employees[2]=new Employee(15000,\"xiaocai\"); Arrays.sort(employees);//对数组进行排序，由于此时类已经实现了Comparable接口中的comparaTo方法,所以自需要传入对象数组即可 for (Employee s:employees){ System.out.println(s.getSalary()); } /* 输出结果： 10000 15000 20000 */ } } class Employee implements Comparable\u003cEmployee\u003e{ private int salary; private String name; public Employee(int salary,String name){ this.salary=salary; this.name=name; } public int getSalary(){ return salary; } @Override public int compareTo(Employee o) { return Integer.compare(salary,o.salary);//按照薪水进行比较 } } 第二种方式 在调用Arrays.sort时需要传入一个数组和一个比较器作为参数。比较器是实现了Comparator接口中compare方法的类的的实例。 这听起来有一些拗口，来看一看代码 public class ArraysTest { public static void main(String[] args) { Employee[] employees=new Employee[3];//构建一个对象数组 employees[0]=new Employee(10000,\"xiaoming\"); employees[1]=new Employee(20000,\"xiaohong\"); employees[2]=new Employee(15000,\"xiaocai\"); Arrays.sort(employees,new com());//对数组进行排序，此时传入的参数为对象数组以及比较器。 for (Employee s:employees){ System.out.println(s.getSalary()); } /* 输出结果： 10000 15000 20000 */ } } class Employee { private int salary; private String name; public Employee(int salary,String name){ this.salary=salary; this.name=name; } public int getSalary(){ return salary; } class com implements Comparator\u003cEmployee1\u003e{//实现Comparator接口并覆写compare方法 @Override public int compare(Employee1 o1, Employee1 o2) { return Integer.compare(o1.getSalary(), o2.getSalary()); } } 从代码中可以看出，实际上比较器就是实现了Comparator接口的实现类的一个对象。这一个对象也可以采用匿名内部类的方式来表示： public class ArraysTest { public static void main(String[] args) { Employee[] employees=new Employee[3];//构建一个对象数组 employees[0]=new Employee(10000,\"xiaoming\"); employees[1]=new Employee(20000,\"xiaohong\"); employees[2]=new Employee(15000,\"xiaocai\"); Arrays.sort(employees, new Comparator\u003cEmployee\u003e() { @Override public int compare(Employee o1, Employee o2) { return Integer.compare(o1.getSalary(), o2.getSalary()); } });//对数组进行排序，此时传入的参数为对象数组以及比较器。 for (Employee s:employees){ System.out.println(s.getSalary()); } /* 输出结果： 10000 15000 20000 */ } } class Employee { private int salary; private String name; public Employee(int salary,String name){ this.salary=salary; this.name=name; } public int getSalary(){ return salary; } 或者采用lambda表达式： public class ArraysTest { public static void main(String[] args) { Employee[] employees=new Employee[3];//构建一个对象数组 employees[0]=new Employee(10000,\"xiaoming\"); employees[1]=new Employee(20000,\"xiaohong\"); employees[2]=new Employee(15000,\"xiaocai\"); Arrays.sort (employee1s, ( (o1, o2) -\u003e { return Integer.compare(o1.getSalary(), o2.getSalary()); } ) );//对数组进行排序，此时传入的参数为对象数组以及比较器。 for (Employee s:employees){ System.out.println(s.getSalary()); } /* 输出结果： 10000 15000 20000 */ } } class Employee { private int salary; private String name; public Employee(int salary,String name){ this.salary=salary; this.name=name; } public int getSalary(){ return salary; } 实际上，不仅仅是Arrays.sort方法要求传入的对象数组必须实现Comparable接口或者Arrays.sort需要传入实现Comparator接口的比较器,对于TreeSet和TreeMap中的key部分也需要实现比较规则，因为TreeSet和TreeMap的底层结果为自平衡二叉树，其特点是可排序。 来看代码 1.TreeSet中的元素或TreeMap中的key部分需要实验Comparable接口 public class TreeMapTest03 { public static void main(String[] args) { User u1=new User(25); // System.out.println(u1); User u2=new User(23); User u3=new User(30); User u4=new User(27); TreeSet\u003cUser\u003e ts=new TreeSet\u003c\u003e(); ts.add(u1); ts.add(u2); ts.add(u3); ts.add(u4); for (User it:ts){ System.out.println(it); ","date":"2020-11-24","objectID":"/compable%E5%92%8Ccomparator/:0:0","tags":null,"title":"Comparable和Comparator","uri":"/compable%E5%92%8Ccomparator/"},{"categories":["Java学习笔记"],"content":"为什么引入lambda表达式 在Java中是面向对象进行编程，如果你想要调用一个方法，你必须创建一个类，并在类中构造一个方法，方法体中为实现的方法。当你想要调用这个方法时，你必须将类进行实例化才能够调用这个方法。从某种意义上来说，这是比较复杂的，lambda就是为了简化这一过程。 ","date":"2020-11-24","objectID":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:1","tags":null,"title":"lambda表达式","uri":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"lambda表达式的语法 lambda表达式的形式为参数，箭头（-\u003e），以及一个表达式。 如果代码要完成的计算无法放在一个表达式中，可以将放在{}中 {}中可以显式包含return语句： （String first,Sring second）-\u003e{ if (first.length\u003esecond.length) return -1; else return 0; } 即使lambda表达式中没有参数，任要提供空括号，就像空参数一样： ()-\u003e{ for (int i=0;i\u003c100;i++) System,out.println(i); } 如果可以推导出一个参数的类型，则可以忽略其类型： Comparator\u003cString\u003e Com=(first,second)-\u003e{ first.length-second.length; } 无需指定lambda表达式的返回类型。lambda表达式的返回类型总是能够从上下文推断得到： （String first,Sring second）-\u003e first.length\u003esecond.length //返回类型为int ","date":"2020-11-24","objectID":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:2","tags":null,"title":"lambda表达式","uri":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"函数式接口 定义：只具有一个抽象方法的接口称为函数式接口 这里需要注意的一个问题是，我们可能认为接口中的方法可能都是抽象方法，其实不然，因为接口中可以声明非抽象方法，例如默认方法，静态方法，私有方法。判断一个接口是否为函数为：对于Java自带的标准库里的大量单一方法的接口，很多都已经标记为@FunctionalInterface，表明该接口可以作为函数使用。 例如Comparator接口只具有一个抽象抽象方法compare //使用匿名内部类的方式 Arrays.sort(employees, new Comparator\u003cEmployee\u003e() { @Override public int compare(Employee o1, Employee o2) { return Integer.compare(o1.getSalary(), o2.getSalary()); } });//对数组进行排序，此时传入的参数为对象数组以及比较器。 //使用lambda表达式 Arrays.sort (employee1s, ( (o1, o2) -\u003e { return Integer.compare(o1.getSalary(), o2.getSalary()); } ) );//对数组进行排序，此时传入的参数为对象数组以及比较器。 ","date":"2020-11-24","objectID":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:3","tags":null,"title":"lambda表达式","uri":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"方法引用 如果函数式接口的实现恰好可以通过调用一个方法来实现，那么我们可以使用方法引用 方法引用分为 静态方法方法引用 非静态方法引用 构造函数的方法引用 public class Demo { public static void main(String[] args) { // 静态方法引用--通过类名调用 Consumer\u003cString\u003e consumerStatic = Java3y::MyNameStatic; consumerStatic.accept(\"3y---static\"); //实例方法引用--通过实例调用 Java3y java3y = new Java3y(); Consumer\u003cString\u003e consumer = java3y::myName; consumer.accept(\"3y---instance\"); // 构造方法方法引用--无参数 Supplier\u003cJava3y\u003e supplier = Java3y::new;//方法名为new System.out.println(supplier.get()); } } class Java3y { // 静态方法 public static void MyNameStatic(String name) { System.out.println(name); } // 实例方法 public void myName(String name) { System.out.println(name); } // 无参构造方法 public Java3y() { } } ","date":"2020-11-24","objectID":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:4","tags":null,"title":"lambda表达式","uri":"/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Java学习笔记"],"content":"String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，如： byte[] a= \"shen\".getBytes();//java默认的编码方式为unicode for (byte s:a){ System.out.println(s); } /* 115 104 101 110 */ ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"final，static关键字 final 关键字 表示常量，即变量被赋值后不能被更改。例如：final double number=24; 被final修饰的类不能被继承，被final修饰的方法不能被重写，能被重载。final不能修饰接口和抽象类。 static 关键字 静态字段属于类而不属于对象，通过类名.静态字段来访问；静态方法属于类，通过类名.静态方法来使用。静态方法只能访问静态字段，不能访问实例字段。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:1","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"this关键字，super关键字 this this指向当前对象 super super指向父类 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:2","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"自动装箱和自动拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； //自动装箱 //向ArrayList\u003cInteger\u003e中添加int元素 list.add(3); //等价于 list.add(Integer.valueOf(3)); //自动拆箱 int n=list.get(3); //等价于 int n =list.get(3).intValue(); ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:3","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"方法的参数 两个基本概念： 按值调用：方法接收调用者提供的值 按引用调用：方法接收调用者提供的变量地址 Java语言总是按值调用。也就是说，方法得到的参数值是一个副本。 如果该参数是基本数据类型（和以String str=\"aaa\"这种方式创建的字符串）的话，那方法不能修改该参数。 如果方法参数是对象引用（例如对象和数组）的话，那方法可以改变对象参数。（因为原来的对象引用和这个副本都引用同一个对象） 例子： public class test01 { public static void main(String[] args) { int num1=10; int num2=20; Swap(num1,num2);//参数是基本数据类型，按值传递 System.out.printf(\"num1=%d\\n\",num1); System.out.printf(\"num2=%d\\n\",num2); } public static void Swap(int a,int b){ int temp=a; a=b; b=temp; System.out.printf(\"a=%d\\n\",a); System.out.printf(\"b=%d\\n\",b); } } /* a=20 b=10 num1=10 num2=20 */ 在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr);//引用传递， System.out.println(arr[0]); } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } /* 1 0 */ 其中array是arr的副本，两者都指向同一数组对象。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:4","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"重载和重写的区别 首先定义方法的签名：方法的签名包括方法名和参数类型。注意返回类型不是方法的签名。也就是说不能有两个名字相同，参数类型也相同却有不同返回类型的方法。 重载（overlode）：如果有多个方法具有相同的方法名，不同的参数，便出现了方法重载。 重写（override）：当子类继承父类，子类必须对父类的某一个方法进行改变时，就发生了重写。注意重写要求方法签名相同，并且返回类型也要相同。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:5","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"成员变量和局部变量的区别 成员对象也称为实例变量，成员对象属于对象实例，随着对象的创建而创建，随着对象的消失而消失；局部变量属于方法中定义的变量或方法参数，在方法被调用后自动消失 成员变量可以被public ,private ,protected,static 修饰符修饰。而局部变量不能。但两个变量都能被final修饰 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:6","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"强制对象类型转换 明确：子类的功能比父类的功能更多。父类有的方法子类都有，但是子类有的方法父类不一定有。 向上转型：父类引用指向子类对象。这个时候我们用一个功能较弱的类型引用一个功能较强的对象，我们将子类转换为了父类。例如： Father father =new Son(); 在这里Son 对象实例被向上转型为father了,但是请注意这个Son对象实例在内存中的本质上还是Son类型，只不过它的功能被临时消弱了（这时我们只能调用father中的方法）。 向下转型： 分为两种情况 //1 Father father =new Son(); Son son=(Son) father; //ok! //2 Father father =new Father(); Son son=(Son) father;//error! //z等价与Son son=new Father(); 对于情况1,即先是父类引用指向子类对象，在将父类引用还原回子类引用。因为我们创建的对象为功能更多的子类对象，子类对象的引用本应该是子类引用。 对于情况2,我们创建了一个功能更少的父类对象，尝试用子类引用指向父类对象，但是由于父类对象的功能少，所以子类对象不能指向父类对象。 public class test01 { public static void main(String[] args) { Father father=new Son();//父类引用指向子类对象，此时的father只能调用method1,method2方法 Son son =(Son) father;//向下转型，此时son可以调用子类中的全部方法 /* 如果是这样调用则会出错 Father father=new Father(); Son son =(Son) father; */ } } class Father{ public void method1(){ System.out.println(\"father's method 1\"); } public void method2(){ System.out.println(\"father's method 2\"); } } class Son extends Father { public void method03() { System.out.println(\"son's method 3\"); } public void method4() { System.out.println(\"father's method 4\"); } } ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:7","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"面向对象的三大特性 继承 将一般的方法放在父类中，将特殊的方法放在子类中。 父类中的私有方法和私有属性，子类无法访问 。(保护成员是可以访问的) class X{ Y y=new Y(); public X(){ System.out.print(\"X\"); } } class Y{ public Y(){ System.out.print(\"Y\"); } } public class Z extends X{ Y y=new Y(); public Z(){ System.out.print(\"Z\"); } public static void main(String[] args) { new Z(); } } /* YXYZ */ /* 初始化过程： 1. 初始化父类中的静态成员变量和静态代码块 ； 2. 初始化子类中的静态成员变量和静态代码块 ； 3.初始化父类的普通成员变量和代码块，再执行父类的构造方法； 4.初始化子类的普通成员变量和代码块，再执行子类的构造方法； （1）初始化父类的普通成员变量和代码块，执行 Y y=new Y(); 输出Y （2）再执行父类的构造方法；输出X （3） 初始化子类的普通成员变量和代码块，执行 Y y=new Y(); 输出Y （4）再执行子类的构造方法；输出Z 所以输出YXYZ */ 多态 定义：一个对象变量（对象引用）可以指向多个实际类型的现象称为多态。 例如：父类引用指向子类对象，父类引用可以指向父类对象。但是子类引用不能指向父类对象 对象引用调用的方法究竟属于哪一个对象（实际类型）是在运行期间动态确定的，这称为动态绑定。 当父类引用指向子类对象。如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 例： son的实际类型是Son,它是Father的子类。如果Son定义了方法（重写）method1，则调用Son中的method1,否则调用Father中的method1。这是在运行期间动态决定的。 public class test01 { public static void main(String[] args) { Son son=new Son(); son.method1(); } } class Father{ public void method1(){ System.out.println(\"father's method 1\"); } public void method2(){ System.out.println(\"father's method 2\"); } } class Son extends Father { @Override public void method1() { System.out.println(\"son's method 1\"); } public void method03() { System.out.println(\"son's method 3\"); } public void method4() { System.out.println(\"father's method 4\"); } } 理解在方法调用时发生了什么？ 虚拟机预先为每一个类创建了一个方法表，其中列出了所有的方法签名和调用的实际方法 Father: method1()-\u003eFather.method1() method2()-\u003eFather.method2() Son: method1-\u003eSon.method1()//重写 method2()-\u003eFather.method2()//子类拥有父类的非私有方法 method3-\u003eSon.method3()//子类新增方法 method4-\u003eSon.method4()//子类新增方法 在调用方法时，如： Son son=new Son(); son.method1(); 首先根据son的实际类型来获取方法表： Son: method1-\u003eSon.method1() method2()-\u003eFather.method2()//子类拥有父类的非私有方法 method3-\u003eSon.method3() method4-\u003eSon.method4() 虚拟机在方法表中查找定义了method1()签名的类。确定应该调用的方法:Son.method1()。 在调用方法：如 Father father=new Son(); father.method1(); 根据father的实际类型来获取方法表：这里father的实际类型为Father。 Father: method1()-\u003eFather.method1() method2()-\u003eFather.method2() 虚拟机在方法表中查找定义了method1()签名的类。确定应该调用的方法:Father.method1()。但是由于Son已经将method1()进行重写了，所以实际上调用的是Son.method1() 小结： 多态存在的条件： 继承-\u003e父类和子类 子类重写父类中的方法-\u003e 父类引用指向子类对象 当父类引用指向子类对象时，原则上来说只能调用父类中的方法，但是一旦子类重写了父类的方法，就可以调用子类中的方法。这就是多态 再举个例子 public class test01 { public static void main(String[] args) { Father father=new Son(); father.method1(); } } class Father{ public void method1(){ System.out.println(\"father's method 1\"); } } class Son extends Father { @Override public void method1() { System.out.println(\"son's method 1\"); } } 这里输出的是son’s method 1。这里满足了多态的三个条件：继承，父类引用指向子类对象，子类重写父类方法。因此在调用father.method1();时，实际上是动态绑定到了子类的method1方法上。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 对象类型不可变，引用类型可变； 方法具有多态性，属性不具有多态性； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 封装 将对象的字段（field）隐藏在对象内部，不让外部直接操作，而是通过一些公有方法来间接的操作 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:8","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"抽象类和接口 抽象类（abstract修饰） 抽象方法（用abstract修饰）相当于占位，继承抽象类的类必须重写抽象方法 抽象类可以有字段和具体方法；抽象类可以有构造方法。 抽象类不能实例化 抽象类不能多继承（extends） 接口（interface修饰） 实现接口的类必须重写接口中的方法。在实现方法时，必须把方法声明为public。接口中的所有方法都自动是public方法。 接口不能有字段和具体方法，但可以有静态常量；接口不可以有构造方法 接口不能实例化 可以实现多个接口（implements） 补充：JDK8开始，接口中可以定义有方法体的方法，方法必须被default和static修饰。除此之外，其他方法都是抽象方法。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:9","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"==和equals的区别 == 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。如果为基本数据类型==比较的是值。如果是引用数据类型，比较的是内存地址。 equals 分为两种情况 类没有重写equals,则通过Object类的equals方法进行比较，用来比较两个对象的引用是否相等。 类重写了equals方法，一般我们重写equals方法来比较对象内容是否相等，若相等则返回true。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:10","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"hashCode 与 equals hashCode()的作用是获得哈希码，返回的是一个int整型，用于确定该对象在哈希表中的索引位置。hashCode()在哈希表中才有用！ 注意： 如果两个对象相等，那么哈希码一定相等 所以 重写equals方法时必须重写hashCode方法，如果equals方法返回true,哈希码一定相等 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:11","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"构造函数 构造函数的作用是完成对象的初始化。 下面的对象创建方法中哪些会调用构造方法 ： new语句创建对象 java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:12","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"i++和++i的区别 int m=7; int n=7; int a=2* ++m (此时a=16,m=8) --\u003e先进行加法运再进行乘法 int b=2* ++n (此时a=14,n=8) --\u003e先进行乘法运算再进行加法 i–和–i同理 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:13","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"String s和 new String的区别 String s1 = “a” 时，首先会在字符串常量池中查找有无 “a” 这个对象。 若没找到，就创建一个 “a” 对象。然后，以 s1 为它的引用。若在字符串常量池中找到了“a”这个对象， 同样也将s1作为它的引用。若再执行一次 String s2 = “a” , 那么 s1 和 s2 都是同一个对象的引用，即 逻辑判断 s1 == s2 的结果是 true。 String s3 = new String(“a”) 时，将在字符串常量池外的堆里，创建一个 “a” 对象。然后，以 s3 为它的引用。这时，s3 对应的是字符串常量池外的一个对象。因此，无论 s3 == s2，还是 s3 ==s1，其结果都是 false。但是s3.equals( s2) ，结果为true，因为内容是相同的。 Q: String str=new String(“hello”);我只想问下这个hello是放在堆里面还是放在字符串常量中？ A: 如果字符串常量池里存在hello这个字符串的话，则只在堆中创建一个hello对象，否则也要在字符串常量池中也创建一个hello常量，前者是新建了一个对象，后者是两个对象。 参考题 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:14","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"基本数据类型 1、整数类型byte（1个字节）short（2个字节）int（4个字节）long（8个字节） 2、字符类型char（2个字节） 3、浮点类型float（4个字节）double（8个字节） ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:15","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"Java类的访问权限 Java有四种访问权限， 其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符。 private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:16","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"深拷贝和浅拷贝 ","date":"2020-11-21","objectID":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/:0:17","tags":null,"title":"Java基础总结","uri":"/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"},{"categories":["Java学习笔记"],"content":"1. 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。链接 id email 1 john@example.com 2 bob@example.com 3 john@example.com Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: id email 1 john@example.com 2 bob@example.com 我的解法1： delete from Person where id= (select id from ( select max(id) as id from Person where email in ( select email from Person group by email having count(email)\u003e1 ) ) as a ); 我的思路是这样的： select email from Person group by email having count(email)\u003e1) 首先按照email进行分组，挑选出重复的email，即通过count(email)\u003e1判断-\u003e这一方法适用于挑选出表中重复的元素 然后在重复的eamil中找到id最大的那一行，进行删除即可 注意：MySQL每一个派生出来的表都必须有一个自己的别名 但是该方法碰到有三个或三个以上的重复email时就会失效。因为在删除的时候值删除了重复email中最大id的那一行，而中间大的没有被删除。 那我们换一个思路：能不能之间将重复email中最小id的那一行挑选出来，就行保留，其余的删除即可。这就是解法2： delete from Person where id not in (select id from ( select min(id) as id ,email from Person group by email ) as t ); 思路： select min(id) as id ,email from Person group by email 按照email进行分组，如果email是重复的，则只保留id最小的那一行，如果email是不重复的，即id最小的那一行就是它本身。 如果id不在派生出来的表中，则将对应行进行删除。 ","date":"2020-11-21","objectID":"/mysql/:0:1","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"2. 编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 select Email from Person group by Email having count(Email)\u003e1; ","date":"2020-11-21","objectID":"/mysql/:0:2","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"3.编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。 解法1 利用自查询的特性： 子查询可以在任意地方使用。相当于查询的列。在oracle中只写查询列没有查询表需要加上 from dual（伪表）。而mysql不用写 select (select distinct salary from employee order by salary desc limit 1,1) as second; 解法2： select ifnull((select distinct salary from employee order by salary desc limit 1,1),null) as second; IFNULL(expression, alt_value) 如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值(此题中是返回null)。 expression是table的时候要加括号 distinct： 去重一样的Salary limit：限时返回的个数 offset：跳过几个 limit 1 offset 1:返回一个结果，跳过一个 例如返回第三高就是：limit 1 offset 2 ","date":"2020-11-21","objectID":"/mysql/:0:3","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表： +----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ select Name as Customers from Customers where Id not in (select CustomerId as Id from Orders); ","date":"2020-11-21","objectID":"/mysql/:0:4","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"多表连接： select 字段列表 from 表1 inner | left |right join 表2 on 条件 1）内联结（inner join），取两表的公共数据 2）左联结（left join），联结结果保留左表的全部数据 -\u003e 在inner join的基础上，增加左边表有右边没有的内容 -\u003e 3）右联结（right join），联结结果保留右表的全部数据 链接 select FirstName, LastName, City, State from Person left join Address on Person.PersonId=Address.PersonId; ","date":"2020-11-21","objectID":"/mysql/:0:5","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"收入超过经理的员工 链接 Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 +----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。 +----------+ | Employee | +----------+ | Joe | +----------+ 解法1： select name as Employee from ( select * from Employee where managerid is not null #挑选出managerid不为null的行 ) as t where salary\u003e #进行比较 ( select salary from Employee where id=t.managerid ); 解法2： SELECT a.Name AS Employee FROM Employee AS a, Employee AS b WHERE a.ManagerId = b.Id AND a.Salary \u003e b.Salary ; ","date":"2020-11-21","objectID":"/mysql/:0:6","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。 返回结果 不要求顺序 。 我的解法： select id from Weather as w1 where Temperature \u003e(select Temperature from Weather w2 where recordDate=(w1.recordDate-1) ) #挑选出前一天日期的温度 ; 但是运行的时候会出错，原因在：比较两个日期的时候不能做差，而要使用datediff函数。datediff函数返回两个日期的时间差 例如： #DATEDIFF(date1,date2) SELECT DATEDIFF('2008-12-30','2008-12-29') #返回1,data1-data2 改正后： select id from Weather as w1 where Temperature \u003e(select Temperature from Weather w2 where DATEDIFF(w1.recordDate,w2.recordDate)=1 ) #挑选出前一天日期的温度 ; 或 SELECT w2.Id FROM Weather w1, Weather w2 WHERE DATEDIFF(w2.RecordDate, w1.RecordDate) = 1 AND w1.Temperature \u003c w2.Temperature ","date":"2020-11-21","objectID":"/mysql/:0:7","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"重新格式化部门表 原表为 +------+---------+-------+ | id | revenue | month | +------+---------+-------+ | 1 | 8000 | Jan | | 2 | 9000 | Jan | | 3 | 10000 | Feb | | 1 | 7000 | Feb | | 1 | 6000 | Mar | +------+---------+-------+ 通过语句 SELECT id, IF(`month`='Jan',revenue,NULL) Jan_Revenue, #对于原表中的第一行，其month=jan,所以该位置返回8000 IF(`month`='Feb',revenue,NULL) Feb_Revenue, #因为month!=feb,返回null IF(`month`='Mar',revenue,NULL) Mar_Revenue, IF(`month`='Apr',revenue,NULL) Apr_Revenue, IF(`month`='May',revenue,NULL) May_Revenue, IF(`month`='Jun',revenue,NULL) Jun_Revenue, IF(`month`='Jul',revenue,NULL) Jul_Revenue, IF(`month`='Aug',revenue,NULL) Aug_Revenue, IF(`month`='Sep',revenue,NULL) Sep_Revenue, IF(`month`='Oct',revenue,NULL) Oct_Revenue, IF(`month`='Nov',revenue,NULL) Nov_Revenue, IF(`month`='Dec',revenue,NULL) Dec_Revenue FROM Department; 或 SELECT id, CASE `month` WHEN 'Jan' THEN revenue END Jan_Revenue, CASE `month` WHEN 'Feb' THEN revenue END Feb_Revenue, CASE `month` WHEN 'Mar' THEN revenue END Mar_Revenue, CASE `month` WHEN 'Apr' THEN revenue END Apr_Revenue, CASE `month` WHEN 'May' THEN revenue END May_Revenue, CASE `month` WHEN 'Jun' THEN revenue END Jun_Revenue, CASE `month` WHEN 'Jul' THEN revenue END Jul_Revenue, CASE `month` WHEN 'Aug' THEN revenue END Aug_Revenue, CASE `month` WHEN 'Sep' THEN revenue END Sep_Revenue, CASE `month` WHEN 'Oct' THEN revenue END Oct_Revenue, CASE `month` WHEN 'Nov' THEN revenue END Nov_Revenue, CASE `month` WHEN 'Dec' THEN revenue END Dec_Revenue FROM Department; 得到虚拟表1,如下所示 +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-------------+-----+-------------+ | 1 | 8000 | null | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ | 2 | 9000 | null | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ | 3 | null | 10000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ | 1 | null | null | 6000 | ... | null | +------+-------------+-------------+-------------+-----+-------------+ | 1 | null | 7000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ 通过group by id语句可以得到得到一个虚拟表2，如下所示。 +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-------------+-----+-------------+ | | 8000 | null | null | ... | null | | 1 | null | null | 6000 | ... | null | | | null | 7000 | null | ... | null | -------+-------------+-------------+-------------------+-------------- | 2 | 9000 | null | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ | 3 | null | 10000 | null | ... | null | +------+-------------+-------------+-------------+-----+-------------+ 该虚拟表按id分组，其中对于id=1的组中，Jan_Revenue，Feb_Revenue，…，Dec_Revenue等列中有多个数值，因此需要一个聚合函数将多个数值进行整合，输出为一个数值。例如sum或max函数。 因此总的语句为： SELECT id, SUM(CASE `month` WHEN 'Jan' THEN revenue END) Jan_Revenue, SUM(CASE `month` WHEN 'Feb' THEN revenue END) Feb_Revenue, SUM(CASE `month` WHEN 'Mar' THEN revenue END) Mar_Revenue, SUM(CASE `month` WHEN 'Apr' THEN revenue END) Apr_Revenue, SUM(CASE `month` WHEN 'May' THEN revenue END) May_Revenue, SUM(CASE `month` WHEN 'Jun' THEN revenue END) Jun_Revenue, SUM(CASE `month` WHEN 'Jul' THEN revenue END) Jul_Revenue, SUM(CASE `month` WHEN 'Aug' THEN revenue END) Aug_Revenue, SUM(CASE `month` WHEN 'Sep' THEN revenue END) Sep_Revenue, SUM(CASE `month` WHEN 'Oct' THEN revenue END) Oct_Revenue, SUM(CASE `month` WHEN 'Nov' THEN revenue END) Nov_Revenue, SUM(CASE `month` WHEN 'Dec' THEN revenue END) Dec_Revenue FROM Department GROUP BY id; 最终的结果： +------+-------------+-------------+-------------+-----+-------------+ | id | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue | +------+-------------+-------------+-----------","date":"2020-11-21","objectID":"/mysql/:0:8","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"if语句 在mysql中if()函数的用法类似于java中的三目表达式，其用处也比较多，具体语法如下： IF(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false， 则返回expr3的值。 ","date":"2020-11-21","objectID":"/mysql/:0:9","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["Java学习笔记"],"content":"group by语句 参考 ","date":"2020-11-21","objectID":"/mysql/:0:10","tags":null,"title":"MySQL","uri":"/mysql/"},{"categories":["深度学习论文阅读笔记"],"content":"现有的姿态引导下图像生成方法存在着三个问题：细节缺失，内容模糊以及风格不一致，这严重降低可图像的质量以及真实性。本文提出了一种细粒度姿态引导下图像生成方法，该方法更加注重于语义的完整性以及细节的补充，该方法将内容合成(local warping)和特征转移(style transfer)的概念以相互引导的方式结合在一起。并提出了一个细节补充网络（DRN）。此外还提出了一套细粒度评估方法，包括了语义分析、结构检测和感知质量评估。HPT和FHPT的比较如下图： ","date":"2020-11-21","objectID":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/:0:0","tags":null,"title":"Towards Fine-grained Human Pose Transfer with Detail Replenishing Network","uri":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/"},{"categories":["深度学习论文阅读笔记"],"content":"A. HPT Methods 基于特征转换机制，我们可以将已有的HPT方法分为三类：global predictive methods、local warping methods 以及 hybrid methods。 该图展示了三种方法不同。我们可以从输出的结果分析出这三种方法存在的两个缺陷：保存原图片语义和外观细节的能力以及在遮挡区域合成新的内容的能力。 Global predictive methods 该方法将HPT视为多模态image-to-image translation问题，使用具有跳跃连接的U-net网络进行特征的前向传播。通过将提取的姿态表示与原图像叠加来将“姿态引导”引入。例如上图中（a）将原姿态$I_s$和目标姿态$I_t$进行编码并与原图像$I_s$进行叠加，直接生成具有目标姿态的图像$\\bar{I_t}$。然而，由于缺乏准确的变形建模，这些工作往往不能可靠地解决[35]不同姿态之间的结构不对齐问题。通常来说，global predictive methods 会缺乏捕获相应局部特征的能力，这会导致生成图像中细节缺失，例如模糊的细节和失真,过于平滑的衣服。 Local warping methods 该方法受到了spatial transformer networks的启发，将deformation构建在特征的前向传播中。例如DSC中使用part-wise 仿射变换，PATN中使用注意力机制来增加deformation modeling的灵活性。 不同姿态之间的变形映射通常是通过相应有限的姿态关键点的插值实现的。假设原图像\\目标图像中人体的区域为$\\Omega_s$ \\ $\\Omega_t$.将deformation 视为一个函数：$T_{st}:\\Omega_s \\rightarrow \\Omega_t$,将区域用关键点表示，则有$T_{st}(p_s)=p_t$.通常来说这样的映射不是唯一的，需要通过额外的正则项（blending energy）来减缓warped contents的失真。 由于视角变化和自遮挡的情况，无法保证estimated warping 覆盖整个target human body ,也就是说$\\Omega_t-T_{st}\\neq \\phi$.因此**local warping network很难恢复原图像中没有精确对应的underlying content，这会导致内容的模棱两可**。 由于视角变化和自遮挡的情况，无法保证estimated warping 覆盖整个target human body 的理解： 我们建立warping 最终的目的就是将原图像进行形变操作。实际是可以将目标图像看作是原图像的形变版本（由于姿态的变化）。 建立的warping， 例如光流法，实际上就是寻找原图像和目标图像之间的关系。具体来说就是目标图像中像素点对应的是原图像的哪一个像素点，如上图中红点所示，或者更准确的说应该是：目标图像的像素点是根据原图像中的像素点采样而来的。 但是存在的一个问题是。在pose-guided person generation 任务中，由于姿态的变化，可能会导致目标图像中的像素点在原图像中找不到对应的像素点。如上图中蓝点所示。换个说法就是无法保证estimated warping 覆盖整个target human body。这个时候生成图像中的某一些部位可能就会产生内容的模棱两可。或者说是产生hole或者说明unable to generate new contents。 论文中的描述： Hybrid methods 利用另一个global predictive branch在uncovered rigions来生成（hallucinate）新的内容，最后再将global和local生成结果进行结合（包含global branch和local branch）according to an estimated composition mask。这种方法常用于视频帧预测框架中。然而现有的hybrid methods通常将image-level的生成结果进行结合，intermediate-level 的特征是很少被研究的。通常来说，global branch和local branch通常是分离的。这会导致hallucinated和warped contents之间的style inconsistency。 ","date":"2020-11-21","objectID":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/:0:1","tags":null,"title":"Towards Fine-grained Human Pose Transfer with Detail Replenishing Network","uri":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/"},{"categories":["深度学习论文阅读笔记"],"content":"C. FHPT Network 该文提出的FHPT与其他方法的对比如上图. FHPT存在的根本问题是保存和补充细粒度语义和外观特征，这一问题之前是采用两种方法来解决的。其中一种是基于high-level 语义指导、用global predictive method来生成new contents。另一种方法是利用warping flow或注意力机制，将原图像的low-level特征进行local warping。而 hybrid methods则将两种方法进行了整合，但是由于该方法生成的图像会存在style inconsistency。针对以上问题，该问题提出了available image content的转换和new content的生成应该以一种相互指导的方式来共同保证style consistency和生成图像的逼真的细节。 该文提出了Detail Replenishing Network (DRN)来验证FHPT方法的有效性：1)detail replenishing module来使得style consistency。2）intermediate feature module pathway来促进相互指导。 DRN包含两个branch：pose transfer branch和detail replenishing branch。 pose represention 提取原图像$I_S$的姿态$P_s$和目标图像$I_t$的姿态$P_t$。提取原图像的面部图像$B$,以及目标图像的面部姿态$H_F$。 pose transfer branch $$ \\hat{I_c}=G_p(I_s.P_s.P_t) $$ 其中$I_c$为粗糙的图像。这里的生成器采用了PATN的级联模块。feature map $F_t$被用于detail replenishing module的spatial guidance。transfer branch应该提供有用的引导“where to add what kind of details”. detail replenishing branch detail replenishing branch包含几个detail replenishing module（DRM),具体来说，使用了两种类型的DRM来分别修正整张图片和面部图片。global module通过$F_t$和$I_s$来生成residual map$R_t$,并将其添加到$\\hat{I_c}$.regional module通过面部图片$I_F$和目标面部姿态$H_F$来生成目标面部图片$\\hat{I}F$，通过这种方式能够生成更加逼真的面部图片。为了将两个module的输出进行结合，采用了具有高斯混合权重掩模的alpha blending。$M_F=g(\\sigma)*1{BF}$,*表示卷积操作，$g(\\sigma)$表示离散2D卷积核，$1_{BF}$表示指示函数，当相应的pixel属于$B_F$时等于1，否则等于0. $$ \\hat{I}_t=(1-M_F)(\\hat{I}_c+R_t)+M_F\\hat{I}_F $$ detail replenishing module 利用残差下采样卷积块对原图片$I_s$的appearance and style information进行提取，为了获得更加鲁棒性的表示，采用了adaptive average pooling将encoderd feature 转换为style code $z_s$,并使用3-layer FC,通过style code，来计算AdaIN的参数，假设第i层的参数为$s^i=(s_w^i,s_b^i)$,则AdaIN的计算为 $$ AdaIN(F_t^i,s^i)=s_w^i\\frac{F_t^i-\\mu_t^i}{\\sigma_t^i}+s_b^i $$ 使用AdaIN将style information整合入相应的姿态信息中。注意到$z_s$在这里起到了style-guild的作用，其控制不同区域的合成细节。(从风格迁移的角度来看，此处将中间特征作为了content) loss function $$ \\mathcal{L}1=\\lambda{recon}\\mathcal{L}{recon}+\\lambda{per}\\mathcal{L}_{per} $$ 其中$\\mathcal{L}{recon}$为L1损失，$\\mathcal{L}{per}$ 为感知损失。 $$ \\mathcal{L}2=\\lambda{recon}\\mathcal{L}{recon}+\\lambda{per}\\mathcal{L}{per}+\\lambda{sty}\\mathcal{L}{sty}+\\lambda{GAN}\\mathcal{L}{GAN} $$ 其中$\\mathcal{L}{sty}$为Gram-matrix based style loss。 $\\mathcal{L}{GAN}$使用了两个判别器$D_A$和$D_S$来分别判别外观和姿态。 $$ \\mathcal{L}{GAN}=\\mathbb{E}[\\log (D_A(I_s,\\hat{I}_t))]+\\mathbb{E}[\\log (1-D_A(I_s,{I}_t))]+\\mathbb{E}[\\log (D_S(P_t,\\hat{I}_t))]+\\mathbb{E}[\\log (1-D_S(P_t,{I}_t))] $$ optimization 首先使用$\\mathcal{L}_1$对pose branch进行更新，以生成$\\hat{I}_c$以及$F_t$，其中$F_t$与target pose 大致对齐。 之后进行细粒度挖掘。使用$\\mathcal{L}_2$对detail replenishing branch进行更新，以生成$\\hat{I}_t$.注意这一过程中pose branch也通过$F_t$进行更新。 最后判别器更新3次。（生成器更新1次，判别器更新3次） ","date":"2020-11-21","objectID":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/:0:2","tags":null,"title":"Towards Fine-grained Human Pose Transfer with Detail Replenishing Network","uri":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/"},{"categories":["深度学习论文阅读笔记"],"content":"D. Experiments A. Ablation Study B. Comparisons with Previous Works Qualitative Comparison 定性实验评价 Perceptual Evaluation 定量实验评价，评价指标：IS，SSIM，FID，LPIPS 这评价的是整个生成 Structural Evaluation 评价的 是各个身体部位的生成质量 Semantic Evaluation For retrieval, we utilize generated images to query from the database of all corresponding source images, and calculate the retrieval scores using ground truth annotations provided in [24]. Specifically, ","date":"2020-11-21","objectID":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/:0:3","tags":null,"title":"Towards Fine-grained Human Pose Transfer with Detail Replenishing Network","uri":"/towards-fine-grained-human-pose-transfer-with-detail-replenishing-network/"},{"categories":["Java学习笔记"],"content":"什么是内部类：定义在另一个类中的类称为内部类 ","date":"2020-11-21","objectID":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/:0:1","tags":null,"title":"匿名内部类","uri":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"categories":["Java学习笔记"],"content":"内部类的分类： 1.静态内部类：类似静态变量 2.实例内部类：类似实例变量 3.局部内部类：类似局部变量 代码示例： class Test { //静态变量-\u003e变量属于类 static int a; //静态内部类 static class inner1 { } //实例变量-\u003e属于实例 int b; //实例内部类 class inner2 { } //方法 public void method1() { //方法中的变量称为局部变量 int c; //定义在方法内部的类称为局部内部类 class inner3 { } } } ","date":"2020-11-21","objectID":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/:0:2","tags":null,"title":"匿名内部类","uri":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"categories":["Java学习笔记"],"content":"匿名内部类是局部内部类的一种，因为这种类没有名字而得名 首先我们先来看不是用匿名内部类时的情况： package InnerClass; /** * ClassName: InnerClass * Package: InnerClass * Description: * Datetime: 2020/11/20 下午12:21 * Author: shilongshen */ public class InnerClass { public static void main(String[] args) { MySum mySum=new MySum(); /* * MySum方法的第一个参数为Computeer 引用类型，但是Computeer为接口，无法实例化，所以使用了Computer c=new Computerimplement() * 即父类引用指向子类对象。 * 执行int value=c.sum(x,y);时调用的是子类中的方法-\u003e多态 * */ mySum.mysum(new Computerimplement(),100,200); } } interface Computer{//接口 int sum(int a, int b); } class Computerimplement implements Computer{ @Override public int sum(int a, int b) { return a+b; } } class MySum{ public void mysum(Computer c,int x,int y){//MySum方法的第一个参数为Computeer 引用类型 int value=c.sum(x,y); System.out.println(x+\"+\"+y+\"=\"+value); } } 但是这样我们要多定义一个接口Computer的实现类Computerimplement，比较麻烦。来看看匿名内部类是如何解决的。 package InnerClass; /** * ClassName: InnerClass * Package: InnerClass * Description: * Datetime: 2020/11/20 下午12:21 * Author: shilongshen */ public class InnerClass { public static void main(String[] args) { MySum mySum=new MySum(); /* * 使用匿名内部类 * */ mySum.mysum(new Computer() { @Override public int sum(int a, int b) { return a+b; } },100,200); } } interface Computer{//接口 int sum(int a, int b); } class MySum{ public void mysum(Computer c,int x,int y){//MySum方法的第一个参数为Computeer 引用类型 int value=c.sum(x,y); System.out.println(x+\"+\"+y+\"=\"+value); } } 匿名内部类本质上也是定义了一个接口的实现类，只不过这个实现类没有名字。 匿名内部类的定义方式： new 接口名 (){ @Override//重写接口中的方法 ... } ","date":"2020-11-21","objectID":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/:0:3","tags":null,"title":"匿名内部类","uri":"/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"},{"categories":["Java学习笔记"],"content":"多态： 定义：一个对象变量（对象引用）可以指向多个实际类型的现象称为多态。 例如：父类引用指向子类对象，父类引用可以指向父类对象。但是子类引用不能指向父类对象 对象引用调用的方法究竟属于哪一个对象（实际类型）是在运行期间动态确定的，这称为动态绑定。 当父类引用指向子类对象。如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 例： son的实际类型是Son,它是Father的子类。如果Son定义了方法（重写）method1，则调用Son中的method1,否则调用Father中的method1。这是在运行期间动态决定的。 public class test01 { public static void main(String[] args) { Son son=new Son(); son.method1(); } } class Father{ public void method1(){ System.out.println(\"father's method 1\"); } public void method2(){ System.out.println(\"father's method 2\"); } } class Son extends Father { @Override public void method1() { System.out.println(\"son's method 1\"); } public void method03() { System.out.println(\"son's method 3\"); } public void method4() { System.out.println(\"father's method 4\"); } } 理解在方法调用时发生了什么？ 虚拟机预先为每一个类创建了一个方法表，其中列出了所有的方法签名和调用的实际方法 Father: method1()-\u003eFather.method1() method2()-\u003eFather.method2() Son: method1-\u003eSon.method1()//重写 method2()-\u003eFather.method2()//子类拥有父类的非私有方法 method3-\u003eSon.method3()//子类新增方法 method4-\u003eSon.method4()//子类新增方法 在调用方法时，如： Son son=new Son(); son.method1(); 首先根据son的实际类型来获取方法表： Son: method1-\u003eSon.method1() method2()-\u003eFather.method2()//子类拥有父类的非私有方法 method3-\u003eSon.method3() method4-\u003eSon.method4() 虚拟机在方法表中查找定义了method1()签名的类。确定应该调用的方法:Son.method1()。 在调用方法：如 Father father=new Son(); father.method1(); 根据father的实际类型来获取方法表：这里father的实际类型为Father。 Father: method1()-\u003eFather.method1() method2()-\u003eFather.method2() 虚拟机在方法表中查找定义了method1()签名的类。确定应该调用的方法:Father.method1()。但是由于Son已经将method1()进行重写了，所以实际上调用的是Son.method1() 小结： 多态存在的条件： 继承-\u003e父类和子类 子类重写父类中的方法-\u003e 父类引用指向子类对象 当父类引用指向子类对象时，原则上来说只能调用父类中的方法，但是一旦子类重写了父类的方法，就可以调用子类中的方法。这就是多态 再举个例子 public class test01 { public static void main(String[] args) { Father father=new Son(); father.method1(); } } class Father{ public void method1(){ System.out.println(\"father's method 1\"); } } class Son extends Father { @Override public void method1() { System.out.println(\"son's method 1\"); } } 这里输出的是son’s method 1。这里满足了多态的三个条件：继承，父类引用指向子类对象，子类重写父类方法。因此在调用father.method1();时，实际上是动态绑定到了子类的method1方法上。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 对象类型不可变，引用类型可变； 方法具有多态性，属性不具有多态性； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 ","date":"2020-11-21","objectID":"/%E5%A4%9A%E6%80%81/:0:0","tags":null,"title":"多态的浅显理解","uri":"/%E5%A4%9A%E6%80%81/"},{"categories":["算法"],"content":"参考 假设我们要计算一个函数：$f(n)=n*f(n-1)$ ","date":"2020-11-17","objectID":"/%E9%80%92%E5%BD%92%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/:0:0","tags":null,"title":"递归的浅显理解","uri":"/%E9%80%92%E5%BD%92%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"},{"categories":["算法"],"content":"递归三要素 递归的定义：接受什么参数，返回什么值，代表什么意思 。当函数直接或者间接调⽤⾃⼰时，则发⽣了递归 递归的拆解：每次递归都是为了让问题规模变⼩ **递归的出⼝：**必须有⼀个明确的结束条件。因为递归就是有“递”有“归”，所以必须又有一个明确的点，到了这个点，就不用“递下去”，而是开始“归来”。 return表示开始返回，即“归” 递归的结束条件十分的重要，在Java中即return回来的的条件 我调用了这个函数，函数需要给我返回一个值，而这个值又取决于我这个函数，只不过函数的变量发生了变化 /* * 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 * https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ * * 思路： * 对于两个对称的结点 * 如果L.value==R.value \u0026\u0026L.left.value==R.right.value \u0026\u0026 L.right.value==R.left.value * * 算法流程： * 如果root==null ，直接返回true * 否则调用recur(root.left,root.right) * * recur中的逻辑： * 递归终止条件：如果L.value==null \u0026\u0026 R.value==null 说明自顶向下都对称，返回 true * 如果L.value==null || R.value==null || L.value==R.value , 说明不对称，返回false * * 递归调用：recur(L.left,R.right)\u0026\u0026recur(L.right,R.left) * */ public boolean isSymmetric(TreeNode root) { if (root==null) return true; else return recur(root.LeftNode,root.RightNode); } private boolean recur(TreeNode L,TreeNode R){ if (L==null\u0026\u0026R==null) return true; if (L==null||R==null||L.data!=R.data) return false; return recur(L.LeftNode,R.RightNode)\u0026\u0026recur(L.RightNode,R.LeftNode); } 假设给定的二叉树是对称的： 从1开始，因为1不为空，所以调用了recur函数，此时recur函数的变量为(2,2),我调用了这个函数，函数需要给我返回一个值，true 或 false recur(2,2) 由于都不满足(L==null\u0026\u0026R==null) ；(L==null||R==null || L.data!=R.data)，所以会调用recur(L.LeftNode,R.RightNode)\u0026\u0026recur(L.RightNode,R.LeftNode) ，即recur(3,3)\u0026\u0026recur(4,4)。此时recur(2,2)的值取决于recur(3,3)\u0026\u0026recur(4,4) 其中recur(3,3)由于都不满足(L==null\u0026\u0026R==null) ；(L==null||R==null||L.data!=R.data)，所以会调用recur(L.LeftNode,R.RightNode)\u0026\u0026recur(L.RightNode,R.LeftNode) ，即recur(null,null)\u0026\u0026recur(null,null),此时recur(3,3)的值取决于recur(null,null)\u0026\u0026recur(null,null) 因为recur(null,null)满足了(L==null\u0026\u0026R==null)，所以返回true，所以recur(3,3)==true 其中recur(4,4)由于都不满足(L==null\u0026\u0026R==null) ；(L==null||R==null||L.data!=R.data)，所以会调用recur(L.LeftNode,R.RightNode)\u0026\u0026recur(L.RightNode,R.LeftNode) ，即recur(null,null)\u0026\u0026recur(null,null),此时recur(3,3)的值取决于recur(null,null)\u0026\u0026recur(null,null) 因为recur(null,null)满足了(L==null\u0026\u0026R==null)，所以返回true，所以recur(4,4)==true 因为recur(3,3)==true 且 recur(4,4)==true,所以recur(2,2)==true,所以总的返回值为true ","date":"2020-11-17","objectID":"/%E9%80%92%E5%BD%92%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/:1:0","tags":null,"title":"递归的浅显理解","uri":"/%E9%80%92%E5%BD%92%E7%9A%84%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3/"},{"categories":["Java学习笔记"],"content":"参考 ","date":"2020-11-15","objectID":"/jvm/:0:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"虚拟机与Java虚拟机 ","date":"2020-11-15","objectID":"/jvm/:1:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 ","date":"2020-11-15","objectID":"/jvm/:1:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"Java虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。 Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点： 一次编译，到处运行 自动内存管理 自动垃圾回收功能 ","date":"2020-11-15","objectID":"/jvm/:1:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"JVM的位置 JVM是运行在操作系统之上的，它与硬件没有直接的交互 ","date":"2020-11-15","objectID":"/jvm/:2:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"Java的体系结构 ","date":"2020-11-15","objectID":"/jvm/:3:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"java代码执行流程 ","date":"2020-11-15","objectID":"/jvm/:4:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"JVM内存区域 Java虚拟机所管理的内存包括以下几个运行时数据区 ","date":"2020-11-15","objectID":"/jvm/:5:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"程序计数器 当前线程所执行的字节码的行号指示器,每条线程都有一个独立的程序计数器。如果一个线程正在执行一个Java方法，则计数器记录的是字节码的指令的地址，如果执行的一个Native方法，则计数器的记录为空。此内存区域是唯一一个没有规定任何OutOfMemoryError的区域。 ","date":"2020-11-15","objectID":"/jvm/:5:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"虚拟机栈 虚拟机栈描述的是Java方法执行的线程内存模型： 每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信息。 方法的执行过程就是栈帧在JVM中出栈和入栈的过程。 方法只有在调用的时候才会在栈中分配空间，并且调用时是在压栈，方法执行结束后，该方法所需要的空间就会被释放了。 栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派（Dispatch Exception）。 局部变量表中存放的是各种基本数据类型，如boolean、byte、char、等8种，及引用类型（存放的是指向各个对象的内存地址），因此，它有一个特点：内存空间可以在编译期间就确定，运行期不在改变。 对于虚拟机栈这个内存区域规定了两种异常情况；如果线程请求的栈的深度大于虚拟机所允许的区域，将抛出StackOverflowError。 如果java虚拟机栈的容量可以动态拓展，当栈拓展时无法申请到足够的内存会抛出OutOfMenoryError 栈不会有垃圾回收 ","date":"2020-11-15","objectID":"/jvm/:5:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"本地方法栈 与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务， 而本地方法栈则是为虚拟机使用到的本地方法服务。 ","date":"2020-11-15","objectID":"/jvm/:5:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"堆 Java堆是虚拟机所管理的内存中最大的一块。 Java堆是被所有线程共享的一块内存区域， 在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例， Java世界里“几乎”所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的内存区域， 因此一些资料中它也被称作“GC堆”。 由于现代 JVM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。 在32位系统上最大为2G，64位系统上无限制。可通过-Xms和-Xmx控制，-Xms为JVM启动时申请的最小Heap内存，-Xmx为JVM可申请的最大Heap内存。 如果在堆中没有内存完成实例分配，并且堆也无法拓展时，Java虚拟机会抛出OutOfMenoryError ","date":"2020-11-15","objectID":"/jvm/:5:4","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"方法区 方法区与Java堆一样， 是各个线程共享的内存区域， 它用于存储已被虚拟机加载的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据。（方法区存放.class文件片段）(jvm在运行应用时要大量使用存储在方法区中的类型信息.) 类型信息 1. 类型的全限定名 2. 超类的全限定名 3. 直接超接口的全限定名 4. 类型标志（该类是类类型还是接口类型） 5. 类的访问描述符（public、private、default、abstract、final、static） 字段信息 1. 字段修饰符（public、protect、private、default） 2. 字段的类型 3. 字段名称 方法信息 1.. 方法名 2.方法的返回类型（包括void）3. 方法参数的类型、数目以及顺序 4. 方法修饰符（public、private、protected、static、final、synchronized、native、abstract） 5. 针对非本地方法，还有些附加方法信息需要存储在方法区中（局部变量表大小和操作数栈大小、方法体字节码、异常表） 静态变量 指该类所有对象共享的变量，即使没有创建该对象实例，也可以访问的类变量。它们与类进行绑定 方法区中一个重要的概念：运行时常量池。主要用于存放在编译过程中产生的字面量（字面量简单理解就是常量）和引用。一般情况，常量的内存分配在编译期间就能确定，但不一定全是，有一些可能就是运行时也可将常量放入常量池中，如String类中有个Native方法intern()。 ","date":"2020-11-15","objectID":"/jvm/:5:5","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"对象的创建 ","date":"2020-11-15","objectID":"/jvm/:5:6","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"类加载子系统 类的加载是将字节码文件（.class文件）中的二进制数据读入到内存中，将其放在方法区中，然后在堆中创建一个对象，用来封装类在方法区中的数据结构。 类的加载的最终结果是位于堆中的对象，对象封装了类在方法区中的数据结构，并向程序员提供了访问方法区内的数据结构的接口。 注意：因为Java是面向对象的编程语言，所以字节码文件中代表的是一个类或一个接口，类中由字段和方法构成，把类的数据放在了方法区中。属于类的对象是放在堆中的，对象可以调用类中的方法，所以说对象封装了类在方法区中的数据结构。或者说这个对象为方法区中这个类的各种数据的访问入口。 类加载分为一下几个步骤： ","date":"2020-11-15","objectID":"/jvm/:6:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"加载阶段 查找并加载类的二进制数据 通过类的全限定名来获取此类的二进制字节流 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构 在堆中生成一个表示这个类的对象，作为方法区这个类的各种数据的访问入口 ","date":"2020-11-15","objectID":"/jvm/:6:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"验证阶段 确保被加载的类的正确性 文件格式验证 元数据验证 字节码验证 符号引用验证 ","date":"2020-11-15","objectID":"/jvm/:6:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"准备阶段 为类中的变量（即静态变量，被static修饰的变量）分配内存并设置初始值。 注意： 1、这时候进行内存（方法区）分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value=3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static指令是在程序编译后，存放于类构造器 \u003cclinit\u003e（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 3、如果类字段的字段属性表中存在 Constant Value属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value=3； 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 ","date":"2020-11-15","objectID":"/jvm/:6:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"解析阶段 将常量池中的符号引用转换为直接引用 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 ","date":"2020-11-15","objectID":"/jvm/:6:4","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 类初始化顺序： 父类静态变量、-\u003e父类静态代码块、-\u003e子类静态变量、-\u003e子类静态代码块、-\u003e父类普通变量、-\u003e父类普通代码块、-\u003e父类构造函数、-\u003e 子类普通变量、-\u003e子类普通代码块、-\u003e子类构造函数 ","date":"2020-11-15","objectID":"/jvm/:6:5","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"类加载器 “通过类的全限定名来获取此类的二进制字节流”,实现这个动作的代码称为类加载器。 比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使在这两个类来自同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 站在虚拟机的角度上，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其它所有的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。 从Java开发人员的角度看，类加载器还可以划分得更细一些，如下： Bootstrap ClassLoader启动类加载器 ：最顶层的加载类，主要加载核心类库。这个类加载器负责将放置在\u003cJAVA_HOME\u003e\\lib目录中的，或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机能识别的(仅按照文件名识别**，如rt.jar，**名字不符合的类库即使放置在lib目录中也不会被加载**)类库加载到虚拟机内存中。**启动类加载器无法被Java程序直接使用**； Extention ClassLoader扩展类加载器**：负责加载 JAVA_HOME\\lib\\ext 目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，**开发者可以直接使用扩展类加载器**； Application ClassLoader应用程序类加载器：由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也被称为系统类加载器**。**它负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。** 双亲委派模型 各种类加载器之间的层次关系被称为类加载器的“双亲委派模型” 双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合关系来复用父加载器的代码。 一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完全这个加载请求时，子加载器才会尝试自己去加载。 优先：采用双亲委派的一个好处是比如加载位于rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。 破坏双亲委派模型 （1）双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2发布之前。JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。 （2）双亲委派模型的第二次“被破坏”是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，如果基础类又要调用用户的代码，这时候就出现问题了，出现了线程上下文类加载器，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型。 （3）双亲委派模型的第三次“被破坏”是由于用户对程序的动态性的追求导致的，例如OSGi(是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范）的出现。类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。 ","date":"2020-11-15","objectID":"/jvm/:6:6","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"执行引擎 输入是字节码二进制流，输出是机器指令。 执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器 JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。 解释器： ​ 对字节码进行逐行解释，将每条字节码翻译为对应平台的本地机器指令进行执行。（通过汇编语言执行） ​ 优点：响应速度块 ​ 缺点：运行效率低。 编译器： ​ 将字节码编译成和本地机器平台相关的机器语言。（二进制码，能够直接被cpu读取运行） ​ 优点：响应数度慢 ​ 缺点：运行效率高 java虚拟机中采用解释器和编译器并存的运行架构，在实际的执行引擎中，会同时利用解释器和编译器：当程序需要快速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间时间消耗，获得更高的执行效率。 ","date":"2020-11-15","objectID":"/jvm/:7:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"运行时的栈帧结构 Java虚拟机以方法作为最基本的执行单元，栈帧则是用于支持虚拟机进行方法调用和执行的数据结构。 对于执行引擎来说，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是有效的，其被称为活动栈帧，与这个栈帧关联的方法称为当前方法。执行引擎所运行的所有字节码指令都针对当前栈帧进行操作。 局部变量表 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的（局部变量必须进行初始化）。 操作数栈 虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的： begin iload_0 // push the int in local variable 0 onto the stack iload_1 // push the int in local variable 1 onto the stack iadd // pop two ints, add them, push result istore_2 // pop int, store into local variable 2 end 在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。 动态链接 在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。 方法的返回地址 方法执行完后有两种方式退出这个方法，一是正常完成出口，并可能会有返回值；二是异常完成出口，是不会给它的调用者产生任何返回值的。无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用者栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。 ","date":"2020-11-15","objectID":"/jvm/:7:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"垃圾收集器和内存分配管理 什么是”垃圾“：在运行程序中没用指针指向的对象被称为垃圾。 垃圾收集主要是针对堆。 ","date":"2020-11-15","objectID":"/jvm/:8:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"如何判断对象是否存活： 1. 引用计数器算法 ​ 原理：在对象中添加一个计数器，每当有一个地方引用该对象时，计数器就加一，当引用失效时，计数器就减一。当计数器为0的对象就是不能够再被引用的对象。 ​ 优点：实现简单，判别效率高 ​ 缺点：无法处理循环引用的情况，即当两个对象相互引用，但是二者已经没有作用时，按照常规，应该对其进行垃圾回收，但是其相互引用，又不符合垃圾回收的条件，因此无法完美处理这块内存清理 2 可达性分析算法(在java垃圾回收中使用的算法) ​ 原理：通过一系列称为”GC Roots“的根对象作为起始节点集，从这些节点开始向下搜索，搜索过程所走过的路径称为”引用链“。如果某个对象到”GC Roots“之间没用任何引用链相连，则称为此对象是不可能再被引用的对象。 ​ 可作为”GC Roots“的对象有： 在虚拟机栈中引用的对象 在方法区中类静态属性引用的对象 在方法区中常量引用的对象 在本地方法栈（Native方法）中引用的对象 java虚拟机内部的引用 所用被同步锁持有的对象 反映java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等 还可以有其他对象临时加入-\u003e例如分代收集和局部回收 ","date":"2020-11-15","objectID":"/jvm/:8:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"强软弱虚引用 强、软、弱、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义： （1）强引用：就是为刚被new出来的对象所加的引用，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 （2）软引用：声明为软引用的类，是可被回收的对象，如果JVM内存并不紧张，这类对象可以不被回收，如果内存紧张，则会被回收。 此处有一个问题，既然被引用为软引用的对象可以回收，为什么不去回收呢？其实我们知道，Java中是存在缓存机制的，就拿字面量缓存来说，有些时候，缓存的对象就是当前可有可无的，只是留在内存中如果还有需要，则不需要重新分配内存即可使用，因此，这些对象即可被引用为软引用，方便使用，提高程序性能。 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。 MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); （3）弱引用：弱引用的对象就是一定需要进行垃圾回收的，不管内存是否紧张，当进行GC时，标记为弱引用的对象一定会被清理回收。 （4）虚引用：也成为幽灵引用或者欢迎引用，它是最弱的一种引用关系。虚引用弱的可以忽略不计，JVM完全不会在乎虚引用，其唯一作用就是做一些跟踪记录，辅助finalize函数的使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。 一个对象是否具有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。虚引用必须和引用队列关联使用，程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 ReferenceQueue\u003cString\u003e queue = new ReferenceQueue\u003cString\u003e(); PhantomReference\u003cString\u003e pr = new PhantomReference\u003cString\u003e(new String(\"hello\"), queue); ","date":"2020-11-15","objectID":"/jvm/:8:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"对象的三种状态 ","date":"2020-11-15","objectID":"/jvm/:8:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"垃圾回收算法 1 标记-清除算法（Mark-sweep） ​ 原理：标记存活的对象，统一回收未被标记的对象 ​ 缺点：执行效率不稳定：当有大量的对象是需要回收的，需要进行大量的标记和回收动作；内存空间碎片化：标记，清除后会产生大量不连续的空间碎片。以至于在后续程序中需要分配较大的对象时找不到足够大的连续空间 2 标记-复制算法（） ​ 原理：将内存划分为两块相同的大小，每次只能够使用其中的一块。当这一块内存用完了，则将还存活的对象复制到另一块内存上，然后将已经使用过的内存空间进行清除。 ​ 优点：能够保证空间的连续性，没有内存空间碎片化的问题。实现简单，运行高效。 ​ 缺点：当内存中存在较多存活的对象时，空间利用率低（适合于新生代，新生代的存活对象少） 一般Sun的JVM会将Eden区和Survivor区的比例调为8:1，保证有一块Survivor区是空闲的，这样，在垃圾回收的时候，将不需要进行回收的对象放在空闲的Survivor区，然后将Eden区和第一块Survivor区进行完全清理，这样有一个问题，就是如果第二块Survivor区的空间不够大怎么办？这个时候，就需要当Survivor区不够用的时候，暂时借持久代的内存用一下。此算法适用于新生代。 3 标记-整理算法（Mark-Compact） ​ 原理：标记存活的对象，将存活的对象移动到空间的一端，然后直接清理掉边界以外的内存。 ​ 优点：没有内存空间碎片化的问题；消除了在标记-复制算法中，内存空间减半的高额代价 ​ 缺点：效率要低于标记-复制算法，因为在移动对象的过程中，如果对象被其他对象引用，则还需要调整引用地址。移动过程中，需要全程暂停用户应用程序。（适合用于老年代，老年代的存活对象多） ","date":"2020-11-15","objectID":"/jvm/:8:4","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"小结 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。 标记清除 标记整理 复制 速率 中等 最慢 最快 空间开销 少（但会堆积碎片） 少（不堆积碎片） 通常需要活对象的2倍空间（不堆积碎片） 移动对象 否 是 是 综合我们可以找到，没有最好的算法，只有最合适的算法 ","date":"2020-11-15","objectID":"/jvm/:8:5","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"System.gc()的理解 在默认情况下，通过system.gc（）者Runtime.getRuntime().gc() 的调用，会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。 然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效) JVM实现者可以通过system.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc() 代码演示是否出发GC操作 /** * System.gc() * * @author: 陌溪 * @create: 2020-07-12-19:07 */ public class SystemGCTest { public static void main(String[] args) { new SystemGCTest(); // 提醒JVM进行垃圾回收 System.gc(); //System.runFinalization(); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"SystemGCTest 执行了 finalize方法\"); } } 运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize() SystemGCTest 执行了 finalize方法 手动GC来理解不可达对象的回收 代码如下所示： /** * 局部变量回收 * * @author: 陌溪 * @create: 2020-07-12-19:12 */ public class LocalVarGC { /** * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区 */ public void localvarGC1() { byte[] buffer = new byte[10*1024*1024]; System.gc(); } /** * 触发YoungGC的时候，已经被回收了 */ public void localvarGC2() { byte[] buffer = new byte[10*1024*1024]; buffer = null; System.gc(); } /** * 不会被回收，因为它还存放在局部变量表索引为1的槽中 */ public void localvarGC3() { { byte[] buffer = new byte[10*1024*1024]; } System.gc(); } /** * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了 */ public void localvarGC4() { { byte[] buffer = new byte[10*1024*1024]; } int value = 10; System.gc(); } /** * localvarGC5中的数组已经被回收 */ public void localvarGC5() { localvarGC1(); System.gc(); } public static void main(String[] args) { LocalVarGC localVarGC = new LocalVarGC(); localVarGC.localvarGC3(); } } ","date":"2020-11-15","objectID":"/jvm/:8:6","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"内存溢出和和内存泄漏 内存溢出（OOM）：没有空闲内存，并且垃圾回收器也无法提供更多的内存。 java虚拟机的堆内存设置不够 代码中创建了大量的对象，并且由于存在被引用，无法被垃圾回收器回收（在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。） 内存泄漏： ​ 严格来说，只有对象不被程序用到，但是垃圾回收器无法回收他们的情况才称为内存泄漏。 ​ 宽泛来说，实际中一些不好的实践会导致对象的生命过长，甚至导致OOM，也称为内存泄漏 强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象。意思就是你用资源的时候为他开辟了一段空间，当你用完时忘记释放资源了，这时内存还被占用着，一次没关系，但是内存泄漏次数多了就会导致内存溢出。 注意：内存泄漏有可能导致内存溢出; 尽管内存泄漏不会立刻引起程序的崩溃，但是一旦发生内存泄漏，内存就会被蚕食殆尽，最终导致内存溢出。 图示说明 Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的。后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开，从而导致没有办法被回收。 举例 单例模式 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 一些提供close的资源未关闭导致内存泄漏 数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。 ","date":"2020-11-15","objectID":"/jvm/:8:7","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"Stop The World stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。 分析工作必须在一个能确保一致性的快照中进行 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。 STW事件和采用哪款GC无关所有的GC都有这个事件。 哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。 STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。 开发中不要用system.gc() 会导致stop-the-world的发生。 并发和并行对比 并发，指的是多个事情，在同一时间段内同时发生了。 并行，指的是多个事情，在同一时间点上同时发生了。 并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。 只有在多CPU或者一个CPU多核的情况中，才会发生并行。 否则，看似同时发生的事情，其实都是并发执行的 垃圾回收的并行与并发 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old； 串行（Serial） 相较于并行的概念，单线程执行。 如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。\u003e用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； 如：CMS、G1 ","date":"2020-11-15","objectID":"/jvm/:8:8","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"安全点与安全区域 安全点 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。 Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。 如何在cc发生时，检查所有线程都跑到最近的安全点停顿下来呢？ 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制） 安全区域 Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 执行流程： 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止； ","date":"2020-11-15","objectID":"/jvm/:8:9","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"分代收集算法 根据对象不同的生命周期将内存（java堆）划分为不同的区域，垃圾回收器可以针对不同的区域采用不同的收集算法。 例如针对新生代对象朝生夕灭的特点，常常采用标记-复制算法；针对老年代对象生命周期长的特点常常采用标记-清除算法或者标记-整理算法 ","date":"2020-11-15","objectID":"/jvm/:9:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"Minor GC， Major GC，Full GC 部分收集（partial GC）：指不是完整收集整个java堆的垃圾收集，其中又分为： 新生代收集（Minor GC/Young GC）:针对新生代的收集 老年代收集（Major GC/Old GC）: 针对老年代的垃圾收集 混合收集（Mix GC）: 针对整个新生代和部分呢老年代的垃圾收集 整堆收集（Full GC）: 针对整个JAVA堆和方法区的垃圾收集 ","date":"2020-11-15","objectID":"/jvm/:9:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"经典垃圾收集器 新生代收集器：Serial、ParNew、Parallel Scavenge； 老年代收集器：Serial old、Parallel old、CMS； 整堆收集器：G1； 垃圾收集器的组合关系 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial old、ParNew/CMS、Parallel Scavenge/Serial 0ld、Parallel Scavenge/Parallel 01d、G1； 其中Serial o1d作为CMs出现\"Concurrent Mode Failure\"失败的后备预案。 （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366） （青色虚线）JDK14中：删除CMs垃圾回收器（JEP363） 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。 Serial收集器 / Serial old 收集器 Serial 标记-复制算法 新生代 串行 Serial old 标记-整理算法（标记-压缩） 老年代 串行 Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。 Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。 Serial收集器采用复制算法、串行回收和**“stop-the-World**“机制的方式执行内存回收。 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了串行回收和\"stop the World\"机制，只不过内存回收算法使用的是标记**-压缩**算法。 Serial old是运行在Client模式下默认的老年代的垃圾回收器 Serial 0ld在Server模式下主要有两个用途： 与新生代的Parallel scavenge配合使用 作为老年代CMS收集器的后备垃圾收集方案 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World） 优势：简单而高效（与其他收集器的单线程比），对于限定单个cPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 运行在client模式下的虚拟机是个不错的选择。 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。 在HotSpot虚拟机中，使用-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。 等价于新生代用Serial GC，且老年代用Serial old GC ","date":"2020-11-15","objectID":"/jvm/:9:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":" ParNew收集器 ParNew 标记-复制算法 新生代 并行 如果说serialGC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是serial收集器的多线程版本。 Par是Parallel的缩写，New：只能处理的是新生代 ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、“stop-the-World\"机制。 ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。 对于新生代，回收次数频繁，使用并行方式高效。 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源） 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？ 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作 在程序中，开发人员可以通过选项”-XX：+UseParNewGC\"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。 -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。 Parallel Scavenge收集器 / Parallel Scavenge old 收集器 -\u003e高吞吐量 Parallel Scavenge 标记-复制算法 新生代 并行 Parallel Scavenge old 标记-整理算法 老年代 并行 HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和\"Stop the World\"机制。 那么Parallel 收集器的出现是否多此一举？ 和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。 自适应调节策略也是Paralle1 Scavenge与ParNew一个重要区别。 高吞吐量则可以高效率地利用CPU时间**，尽快完成程序的运算任务**，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。 Paralle1收集器在JDK1.6时提供了用于执行老年代垃圾收集的Paralle1o1d收集器，用来代替老年代的serialold收集器。 Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和\"stop-the-World\"机制。 在程序吞吐量优先的应用场景中，IParalle收集器和Parallel old收集器的组合，在server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。 参数配置 -XX：+UseParallelGC 手动指定年轻代使用Paralle1并行收集器执行内存回收任务。 -XX：+UseParalleloldcc 手动指定老年代都是使用并行回收收集器。 分别适用于新生代和老年代。默认jdk8是开启的。 上面两个参数，默认开启一个，另一个也会被开启。（互相激活） -XX:ParallelGcrhreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。 在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8] -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STw的时间）。单位是毫秒。 为了尽可能地把停顿时间控制在MaxGCPauseMi11s以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。 -XX:GCTimeRatio垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。 取值范围（0，100）。默认值99，也就是垃圾回收时间不超过1。 与前一个-xx:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。 -XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMil1s），让虚拟机自己完成调优工作。 ","date":"2020-11-15","objectID":"/jvm/:9:4","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":" CMS收集器-\u003e低延迟 CMS 标记-清除算法 老年代 并发 在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：cMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 CMS的垃圾收集算法采用标记-清除算法，并且也会\"stop-the-world” 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。 CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记) 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。 并发标记（Concurrent-Mark）阶段：从Gc Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。 CMS为什么不使用标记整理算法？ 答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用 优点 并发收集 低延迟 缺点 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。 CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure\"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。 设置的参数 -XX：+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。 开启该参数后会自动将-xx：+UseParNewGC打开。即：ParNew（Young区用）+CMS（01d区用）+Serial old的组合。 -XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次cMs回收。JDK6及以上版本默认值为92% 如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。 -XX：+UseCMSCompactAtFullCollection用于指定在执行完Ful1 GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 -XX:CMSFullGCsBeforecompaction 设置在执行多少次Ful1GC后对内存空间进行压缩整理。 -XX:ParallelcMSThreads 设置cMs的线程数量。 CMs默认启动的线程数是（Paralle1GCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。 小结 HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同呢？ 请记住以下口令： 如果你想要最小化地使用内存和并行开销，请选Serial GC； 如果你想要最大化应用程序的吞吐量，请选Parallel GC； 如果你想要最小化GC的中断或停顿时间，请选CMs GC。 G1（Garbage First） 主要思想： 将堆内存分割成一系列（不需要连续）的区域（region），使用不同的region来表示新生代（Eden，Ssurvivor 0 ，Ssurvivor 1 ）和老年代。 避免在整个堆中进行全区域的垃圾收集，以region作为单次回收的最小单元。G1 跟踪各个region里面的垃圾堆积的“价值”大小，然后在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值价值最大的region。（价值即指回收所获得的空间大小以及回收所需时间的经验值） ","date":"2020-11-15","objectID":"/jvm/:9:5","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["Java学习笔记"],"content":"垃圾回收器总结 截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。 GC发展阶段：Serial=\u003e Parallel（并行）=\u003e CMS（并发）=\u003e G1 =\u003e ZGC 不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图 怎么选择垃圾回收器 Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？ 优先调整堆的大小让JVM自适应完成。 如果内存小于100M，使用串行收集器 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。 最后需要明确一个观点： 没有最好的收集器，更没有万能的收集 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 ","date":"2020-11-15","objectID":"/jvm/:9:6","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":["随笔"],"content":"2020-11-15创建了我的个人博客，并上传了之前做的一些笔记。 希望能够养成坚持做笔记，坚持更新博客的习惯。 最重要的是始终坚持独立思考，每天进步一点点！ ","date":"2020-11-15","objectID":"/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/:0:0","tags":null,"title":"我的第一篇博客","uri":"/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"categories":["技术分享与记录"],"content":"本文是基于ubuntu16.04进行搭建 ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"下载安装hugo 下载地址：https://github.com/gohugoio/hugo/releases/download/v0.56.0/hugo_0.56.0_Linux-64bit.deb 安装：sudo dpkg -i hugo_0.56.0_Linux-64bit.deb 注意如果直接使用 sudo apt install hugo 进行安装，安装的版本可能过低，导致一些主题不能够使用。要尽可能下载新版本！ 安装完成后可以使用 hugo version 来检查是否安装成功。 ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"生成站点 hugo new site /path /path站点表示路径，我这里设为了‘myblog’ , myblog中的结构 archetypes config.toml content data layouts static themes ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"创建文章 hugo new post/about.md 这是会在content/post文件夹下生成一个about.md文件 ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"安装皮肤 cd theme git clone https://github.com/vaga/hugo-theme-m10c.git hugo提供的皮肤可以在这里找到 ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"运行hugo //切换到根目录下 hugo server --theme=LoveIt --buildDrafts 这是你可以打开http://localhost:1313/ 在本地查看博客. ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"部署 这里尝试在github部署我的博客。 首先在github上新建一个仓库 注意仓库的名字为‘github的名字'+github.io (由于我之前已经建立过了，所以这里提示已经建立过了) 然后执行 hugo --theme=LoveIt --baseUrl=\"https://shilongshen.github.io/\" --buildDrafts 注意命令行中没有server。 此时将会在’myblog'下生成一个’public'文件夹,即为我们的Git仓库 cd public git init git add . git remote add origin https://github.com/shilongshen/shilongshen.github.io.git git commit -m 'first blog' git push -u origin master 随后我们就可以通过 https://shilongshen.github.io/ 访问我们的博客. ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["技术分享与记录"],"content":"文章的更新 //切换到根目录下 //创建一篇文章,或者是修改一篇文章 hugo new post/**.md //本地启动博客，检查内容，此步骤可以忽略 hugo server --theme=LoveIt --buildDrafts //确认无误后在远端进行更新 hugo --theme=LoveIt --baseUrl=\"https://shilongshen.github.io/\" --buildDrafts #这条命令会更新public文件夹，然后将public的内容推上仓库即可 cd public git add . git commit -m 'change' git push -u origin master ","date":"2020-11-15","objectID":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","tags":null,"title":"基于hugo的个人博客搭建","uri":"/%E5%9F%BA%E4%BA%8Ehugo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["深度学习论文阅读笔记"],"content":" 参考： 参考1 参考2 该文章基于GAN设计风格迁移模型。该模型能够自动学习，无监督的分离高层属性（例如 pose，identity）以及能对生成图像进行随机变化（例如雀斑，头发）并且 能够对生成图像的分辨率进行控制。 StyleGAN中的style借用自图像风格迁移，这篇文章是PG-GAN之后的，主要改变了生成器的结构实现无监督地生成可控性强的图像。 PG-GAN中是通过一层层地给生成器和判别器增添卷积层同时提高分辨率的方法来生成高质量图像的。StyleGAN的motivation就是发现这种渐进的方法其实能控制图像的不同特性，低分辨率也就是coarse层主要影响图像的姿态，脸型等高级特征，高分辨率主要影响背景发色等低级特征(结合感受野的概念理解，低分辨率的特征获取更多全局信息并加以处理，比如特征从线条经过多次卷积一步步会组合出形状，会更加抽象，具有更高级的语义信息)。但PG-GAN这种结构在递进添加层的时候没有任何控制条件，导致整体的特征和细微的特征间存在耦合，耦合就导致了图像可控性差，没办法对单个特征进行调节。StyleGAN于是寻找了一种无监督但又可控性强的方法：对不同level的卷积层进行操作。 ProGAN的网络框架： 在之前的传统的生成网络中，有一个问题存在，就是特征耦合，那么这个是什么呢？如上图左边，传统的生成网络，我们可以看到，其输入一个latent Z Z，一般为512的一个向量。假设这个向量代表一个人的脸，那么该向量就会存在特征耦合。因为一个脸是有很多特征的，并不是一个512维的向量就能完全表示的，如果非要表示，只能是这种方式，如下： 假设：维度1代表头发粗细，维度2代表皮肤颜色，维度3代表鼻子大小…，当512个维度全部是用完之后，其只能通过多个维度再去表示其他的特征，如：维度1与维度2综合起来表示了头发的颜色。这样，通过两个或者多个组合，512的向量，就能表示出接近无数的特征。 但是这样就很明显出现了一个问题，那就是我们怎么去控制我们想要图片的单个特征呢？如，我只想改变头发的粗细，但是又不能直接去修改第一个维度，因为第一个维度会影响其他的维度，可能会影响到皮肤的颜色，但是有的时候，我偏偏需要该表他头发的颜色，不修改皮肤的颜色。不同的特征是互相关联的（特征耦合）。 1 Introduction GAN能够生成高分辨率和高质量的图像，但是生成器仍然被视为一个黑箱子。尽管最近已经有了一些工作，但是对图像生成过程中变化因素的理解，例如随机特征的起源，仍然是缺乏的。latent space的性质也没有很好的被理解。 该文设计了一个能够设计了一个能够控制生成过程的生成器模型。生成器的输入为一个learned constant，根据latent code在每一个卷积层调整图像的style，从而直接控制不同尺度下图像特征的强度。通过将noise直接送入网络中，来实现从随机变化（）中进行高层属性（）的自动、无监督分离，并实现直观的特定尺度的混合和插值操作。 生成器首先将input latent code映射到intermediate latent space，这对于factors of variation在网络中是如何表达到有很重要的影响。input latent code的分布（input latent space）是符合training data的概率密度的，这会导致某种程度上信息的耦合。而intermediate latent space是没有这一限制的，因此可以进行信息的解耦。该文提出了两种新的评估latent space解耦程度的方法：感知路径长度和线性可分离性。该文的方法具有更高的线性度和更少的耦合度。 并且提出了了一个新的dataset of human faces（Flickr-Faces-HQ, FFHQ）。 2 style-based generator 传统的方法是将input code通过input layer送入生成器。该文抛弃了这个设计，完全忽略了输入层，而是从一个learned constant开始。给定latent space $\\mathcal{Z}$ 中的一个latent code $z$，非线性映射网络 $f:\\mathcal{Z \\rightarrow W }$, 将$z$映射为$w$：$w=f(z)$.其中$f$ 为8层的MLP。随后将$w$变换为styles:$y=(y_s,y_b)$来作为AdaIN的仿射参数： $$ AdaIN(x_i,y)=y_{(s,i)}{\\large(}\\frac{x_i-\\mu(x_i)}{\\sigma(x_i)}{\\large)}+y_{(b,i)} $$ $$ z\\rightarrow w \\rightarrow y (仿射参数)\\rightarrow style\\ x \\rightarrow content $$ $y_s$为$w$的方差，$y_b$为$w$的均值. 最后通过引入显示噪声输入，使生成器直接进行随机细节的生成。这些噪声是不相关的单通道图像，并且在生成器的每一层都输入一个专用噪声。利用学习后的perfeature缩放因子将噪声图像广播到所有的feature map上，然后将噪声图像加到相应卷积的输出中。 当latent code只用于生成器的输入层时，随着生成器的层数增多，它的影响应该会越来越微弱，无法对latent code进行解耦合。 StyleGAN中，生成器的输入变成了一个常量，而latent code分别作用于生成器的每一个卷积层后，以控制图像的生成。这里有两个重点： latent code作用于卷积层之前有一个变换，可以达到解耦和 解耦合后的latent code作用于每一卷积层，借鉴PG-GAN的递进概念，这些层所影响/控制的特征是不同的，于是latent code对不同level的特征分别进行了控制。 3 properties of style-based generator 生成器的结构使得能够通过特定尺度（生成不同分辨率的图像）的修改来控制合成图像风格。我们可以把映射网络和仿射变换看作是一种从已知分布（input latent space）中为每种风格进行采样的方法（从$z$求得$w$,利用$w$计算仿射参数$y=(y_s,y_b)$,因为生成器中共有18种不同分辨率的图像，所以共有18组仿射参数，这18组仿射参数对应了不同的style，这里的style表示的是姿态，脸型以及背景，颜色等特征。），而生成网络则基于styles生成新图像（通过AdaIN控制风格迁移）。每种风格的效果在网络中都是局部的，修改风格的特定子集只能影响图像的某些方面（不同的仿射参数只影响特定的特征）。 不同的仿射参数可以控制不同的风格，即一个仿射参数只能控制一种风格（局部(localize)的解释）。 生成器能够生成不同分辨率的图像，对不同分辨率的图像分别进行AdaIN控制。 从latent space采样并进行非线性映射和仿射变换的过程可以视作是从已学习到的分布中对某style图像采样，即每一层卷积后融入的style都是不同的，最后生成器相当于从这么多种styles的集合中生成一张新图像，这种方法使得每一种style产生的影响都是局部的(相当于把styles解耦和了，但是这里所谓的styles代表着什么呢？应该就是姿势，肤色到眼睛，嘴巴等特征吧)，这样就可以很方便地操控图像的各种特征了。 低分辨率（low-level）也就是coarse层主要影响图像的姿态，脸型等高级特征，高分辨率（high-level）主要影响背景发色等低级特征(结合感受野的概念理解，低分辨率的特征获取更多全局信息并加以处理，比如特征从线条经过多次卷积一步步会组合出形状，会更加抽象，具有更高级的语义信息) 3.1 style mixing 为了进一步加强styles的“localize”，应用了 mixing regularization，即在训练过程中使用两个随机的latent code（而不是一个latent code）来生成给定百分比的图像。我们在生成网络中随机选取一个点，来将一个latent code转换为另一个latent code（style mixing）。具体来说，给定两个input latent code $z1,z2$，通过$f$求得：$w1=f(z1),w2=f(z2)$,$w1,w2$分别控制不同的风格，$w1$应用在crossover point之前，$w2$应用到crossover point之后。 一个分辨率的图像中使用了两个AdaIN进行控制，进而实现style mixing。 为了进一步实现style的解耦和，文中还采用了mixing regularization的操作：在训练时，用两个latent code生成一部分图像，也就是一张图像不是由一个latent code生成的各种style控制的，而是两个latent code。两个latent code会有两个非线性映射后得到的w_1,w_2，在生成器中随机选取一个节点，该节点前使用w_1，节点后使用w_2。该方法可以阻止相邻styles的相关(大概是因为不同的latent code非线性映射后得到的style差距比一个latent code自己产生的要大，所以肯定styles间的关联更小，本身就更不耦合？)，这里其实并不太懂，但通过实验的图像能看出latent code在不同层改变时确实影响的是很准确的不同的特征，说明style的解耦和还蛮成功的 3.2 stochastic variation 在人","date":"2020-11-15","objectID":"/a-style-based-generator-architecture-for-generative-adversarial-networks/:0:0","tags":null,"title":"A Style-Based Generator Architecture for Generative Adversarial Networks","uri":"/a-style-based-generator-architecture-for-generative-adversarial-networks/"},{"categories":["深度学习论文阅读笔记"],"content":"该方法能够生成不同的姿态的人物图像以及改变人物的外观。而且这个模型能够在不改变shape的情况下从appearance distribution 中进行采样。 1 Approach 记$x$为dataset $X$中的一张图片，我们想要理解$x$中的object是如何被其shape $y$和appearance $z$所影响的。因此图像生成器可以被表示为最大化后验概率（极大似然估计：给定$y$和$z$，哪种$x$最有可能发生。） $$ arg\\ max\\ p(x|y,z) $$ 1.1 VAE based on latent shape and appearance $p(x|y,z)$可以视为隐变量(含两个隐变量)的生成模型，可以求得这个生成模型的联合概率分布$p(x,y,z)$。 $\\because$ $$ p(x|y,z)=\\frac{p(x,y,z)}{p(y,z)} $$ $\\therefore$ $$ p(x,y,z)=p(x|y,z)p(y,z) $$ 含隐变量的概率密度估计可以采用VAE的方法进行求解，求解过程包含了两个步骤推断和生成。实际上我们最终的目的是为了求出图像$x$的分布$p(x,\\theta),\\theta$为参数，给定样本$x$，其对数边际似然函数为 $$ \\log p(x,\\theta)=ELBO(q,x,\\theta,\\phi)+KL[q(y,z|x;\\phi),p(y,z|x;\\theta)] $$ 其中$q(y,z|x;\\phi)$为变分密度函数，$\\phi$为参数，ELBO为证据下界： $$ ELBO(q,x,\\theta,\\phi)=\\mathbb{E}_q\\log \\frac{p(x|y,z)p(y,z)}{q(y,z|x;\\phi)} $$ $$ \\begin{aligned} \\log p(x)\u0026=\\log \\int p(x,y,z)dz\\ dy\\ \u0026=\\log \\int \\frac{p(x,y,z)}{q(y,z|x)}q(y,z|x)dz\\ dy\\ \u0026\\geq \\int q(y,z|x)\\log \\frac{p(x,y,z)}{q(y,z|x)}dz\\ dy\\ \u0026= \\mathbb{E}_q\\log \\frac{p(x,y,z)}{q(y,z|x;\\phi)}\\ \u0026=\\mathbb{E}_q\\log \\frac{p(x|y,z)p(y,z)}{q(y,z|x;\\phi)} \\end{aligned} $$ 实际上 $$ \\begin{aligned} \\log p(x)\u0026=\\int q(y,z|x)\\log \\frac{p(x,y,z)}{q(y,z|x)}dz\\ dy-\\int q(y,z|x)\\log \\frac{p(y,z|x)}{q(y,z|x)}dz\\ dy\\ \u0026=ELBO+KL[q(y,z|x)||p(y,z|x)] \\end{aligned} $$ VAE最终的优化目标为最大化ELBO。 从VAE的角度来说我们最终是要学习到图像的分布$p(x)$，但是直接学习到图像的分布式比较困难的，因此引入了两个隐变量$y,z$。我们的第一步就是从训练数据$\\pmb{x}$中推断到隐变量$y,z$，即后验概率$p(y,z|\\pmb{x})$。然后再从$y,z$中学习到图像的分布$p(x|y,z)$。 在VAE中假设$p(y,z)$服从标准正态分布,即$p(y,z)\\sim \\mathcal{N}(0,1)$。但是这种假设无法将变量$y$和$z$分离，因此我们需要添加一个额外的信息将$y,z$进行分离。 1.2 CVAE with appearance 假设我们有一个估计函数$e$能够通过图像$x$来估计shape $y$，即$\\hat{y}=e(x)$。那么$\\hat{y}=e(x)$则通过最大化条件对数似然函数来得到： $$ \\begin{aligned} \\log p(x|\\hat{y})\u0026=\\log \\int _z p(x,z|\\hat{y})dz\\ \u0026=\\log \\int _z q(z|x,\\hat{y})\\frac{p(x,z|\\hat{y})}{q(z|x,\\hat{y})}dz\\ \u0026\\geq \\int _z q(z|x,\\hat{y})\\log \\frac{p(x,z|\\hat{y})}{q(z|x,\\hat{y})}dz\\ \u0026= \\mathbb{E}_q \\log \\frac{p(x,z|\\hat{y})}{q(z|x,\\hat{y})}\\ \u0026=\\mathbb{E}_q \\log \\frac{p(x|\\hat{y},z)p(z|\\hat{y})}{q(z|x,\\hat{y})} \\end{aligned} $$ $$ \\because\\ p(x,z|\\hat{y})=\\frac{p(x,\\hat{y},z)}{p(\\hat{y})}\\ p(x|\\hat{y},z)=\\frac{p(x,\\hat{y},z)}{p(\\hat{y},z)}\\ p(z|\\hat{y})=\\frac{p(\\hat{y},z)}{p(\\hat{y})}\\ $$ $$ \\therefore\\ p(x,z|\\hat{y})=p(x|\\hat{y},z)p(z|\\hat{y}) $$ 实际上 $$ \\begin{aligned} p(x|\\hat{y})\u0026=p(x,z|\\hat{y})\\frac{1}{p(z|x,\\hat{y})}\\ \\rightarrow\\frac{p(x,\\hat{y})}{p(\\hat{y})}\u0026=\\frac{p((x,\\hat{y},z))}{p(\\hat{y})}\\frac{p(x,\\hat{y})}{p(x,\\hat{y},z)}\\ 则有\\ \\log p(x|\\hat{y})\u0026=\\int q(z|x,\\hat{y})[\\log p(x,z|\\hat{y})-\\log p(z|x,\\hat{y})]dz\\ \u0026=\\int _z q(z|x,\\hat{y})\\log \\frac{p(x,z|\\hat{y})}{q(z|x,\\hat{y})}dz-\\int _z q(z|x,\\hat{y})\\log \\frac{p(z|x,\\hat{y})}{q(z|x,\\hat{y})}dz \\ \u0026=ELBO+KL[p(z|x,\\hat{y})||q(z|x,\\hat{y})] \\end{aligned} $$ 其中条件（先验）概率$p(z|\\hat{y})$可以从训练数据中估计得到(通过网络E进行估计)，并能够获得shape 和 appearance之间的关系。例如一个正在跑步的人更有可能穿T恤而不是西装。 现在的问题为如何求概率$p(x|\\hat{y},z)$以及概率$q(z|x,\\hat{y})$。这里使用神经网络$G_\\theta$来拟合$p(x|\\hat{y},z)$以及使用神经网络$F_\\phi$来拟合$q(z|x,\\hat{y})$。 $q(z|x,\\hat{y})$表示如何从给定图像$x$中推断appearance $z$。 $p(x|\\hat{y},z)$表示如何从隐变量$z,\\hat{y}$中采样得到图像$x$。 损失函数为: 此时想要最大化$p(x|\\hat{y})$,可转换为最大化证据下界$ELBO=\\mathbb{E}_q \\log \\frac{p(x|\\hat{y},z)p(z|\\hat{y})}{q(z|x,\\hat{y})}$,由Jensen不等式的性质，当且仅当$q(z|x,\\hat{y})=p(z|\\hat{y})$时，$ELBO$最大。这通过最小化KL散度来保证。 而损失函数的第二项为重构损失函数。 实际上 $$ \\begin{aligned} ELBO\u0026=\\int q(z|x,\\hat{y})\\log \\frac{p(x|\\hat{y},z)p(z|\\hat{y})}{q(z|x,\\hat{y})}dz\\ \u0026=\\int q(z|x,\\hat{y})\\log p(x|\\hat{y},z)dz+\\int q(z|x,\\hat{y})\\log \\frac{p(z|\\hat{y})}{q(z|x,\\hat{y})}dz\\ \u0026=\\mathbb{E}{q\\phi(z|x,\\hat{y})}[\\log p_\\theta(x|\\hat{y},z)]-KL[q_\\phi(z|x,\\hat{y})||p_\\theta(z|\\hat{y})] \\end{aligned} $$ 最终的目标为最大化ELBO。 $$ \\mathcal{L}(x,\\theta,\\phi)=-KL[q_\\phi(z|x,\\hat{y})||p_\\theta(z|\\hat{y})]+\\mathbb{E}_{q_\\phi(z|x,\\hat{y})}[\\log p_\\theta(x|\\hat{y},z)] $$ 1.3 Generator 首先建立$G_\\theta$。假设分布$p(x|\\hat{y},z)$有常值偏差，以及$G_\\theta(\\hat{y},z)$为$\\hat{y}$的确定函数。那么$G_\\theta(\\hat{y},z)$可以视为图像生成器，我们可以将损失函数的第二项进行替代，那么此时的损失函数为： $$ \\mathcal{L}(x,\\theta,\\phi)=-KL[q_\\phi(z|x,\\hat{y})||p_\\theta(z|\\hat{y})]+\\sum_k\\lambda_k||\\Phi_k(x)-\\Phi_k(G_\\theta(\\hat{y},z)||_1 $$ 其中$\\sum_k\\lambda","date":"2020-11-15","objectID":"/a-variational-u-net-for-conditional-appearance-and-shape-generation/:0:0","tags":null,"title":"A Variational U-Net for Conditional Appearance and Shape Generation","uri":"/a-variational-u-net-for-conditional-appearance-and-shape-generation/"},{"categories":["深度学习论文阅读笔记"],"content":"参考文献 注意到，这里评判的指标是志愿者将生成图像标记为真实图像的概率，也就是生成图像“欺骗”的概率（G2R） 参考文献 要点： 给出一组真实图像和一组生成图像（以不同的次序），让志愿者为每一张图像进行标记（该张图像是真实图像还是生成图像） 每一张图像只出现1秒 前10张图像由于warming up，会告知志愿者正确的结果 若有多个算法进行比较时，一组实验只进行测试一种算法 注意到评价的指标通常为R2G、G2R，即将真实图像标记为真实图像的概率以及将生成图像标记为生成图像的概率，也就是“fool rate”。 ","date":"2020-11-15","objectID":"/amt-perceptual-studies/:0:0","tags":null,"title":"AMT perceptual study","uri":"/amt-perceptual-studies/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了一种简单但高效的实时（转换速度更快）的能进行任意风格迁移的模型。该模型的核心为adaptive instance normalization (AdaIN) layer，AdaIN能够对齐content feature 与style feature的均值和方差。 1 Introduction 深度神经网络能够将图像的内容以及风格信息进行编码，而且图像的内容和风格是可分离的，因此可以实现在保存图像内容的同时对图像的风格进行改变。 现存的方法存在两个弊端：1.能够实现任意风格的迁移，但是速度较慢。2.速度较快，但是只能够实现单一风格的迁移。 在这篇文章中实现了速度快且能够实现任意风格转换。 AdaIN由instance normalization (IN)所启发。IN在feed-forward风格迁移中是十分高效的，IN的作用可以解释为：IN通过归一化包含图像风格信息的feature statistics（特征的统计特性，例如均值和方差）来进行风格归一化。 AdaINs是IN的拓展，其以内容和风格作为输入，通过调整内容的均值和方差来匹配风格输入d的均值和方差。 2 related work style transfer ​ 风格迁移问题起源于non-photo-realistic rendering（非真实性渲染：通过风格形式的艺术化加工。相对的真实性渲染强调其输出的外观尽可能的与目标图像相同。）,并且与纹理合成和转移密切相关。一些早期使用的方法包括了直方图匹配和非参数采样。这些方法通常依赖于低层次的统计特性并且不能够很好的捕获语义结构信息。Gray等人首次通过在深度神经网络中匹配卷积层的统计特性来进行风格迁移，并达到了十分出色的效果。 ​ Gray等人提出的网络框架由于需要最小化内容损失函数和风格损失函数来迭代更新图像，因此优化的过程十分的缓慢，在实际的应用中常常需要较长的时间来处理图像（文中并没有采用常用的梯度下降的方法，采用的是L-BFGS的优化算法，其实本身这个风格转换只是利用的VGG网络进行特征提取，实际上L-BFGS优化的是从一张由白噪声组成的图片，最终根据定义的损失优化得到最终的风格转换图片）。一种常见的解决为使用训练后的前馈神经网络将优化过程替代，这能够极快的提升处理图像的速度，实现实时的转换。然而这些基于前馈网络的方法存在着局限性：一个网络框架只能够生成有限风格的图像。 … 各种归一化方法图例 3 Background 如果一个机器学习算法在缩放全部或部分特征后不影响它的它的学习和预测，我们就称该算法具有尺度不变性。 从理论上，神经网络应该具有尺度不变性，可以通过参数的调整来适应不同特征的尺度．但尺度不同的输入特征会增加训练难度．假设一个只有一层的网络𝑦 = tanh(𝑤1𝑥1 + 𝑤2𝑥2 + 𝑏)，其中𝑥1 ∈ [0, 10]，𝑥2 ∈ [0, 1]．之前我们提到tanh 函数的导数在区间[−2, 2] 上是敏感的，其余的导数接近于0．因此，如果𝑤1𝑥1 + 𝑤2𝑥2 + 𝑏 过大或过小，都会导致梯度过小，难以训练．为了提高训练效率，我们需要使𝑤1𝑥1 + 𝑤2𝑥2 + 𝑏 在[−2, 2] 区间，因此需要将𝑤1 设得小一点，比如在[−0.1, 0.1] 之间．可以想象，如果数据维数很多时，我们很难这样精心去选择每一个参数．因此，如果每一个特征的尺度相似，比如[0, 1] 或者[−1, 1]，我们就不太需要区别对待每一个参数，从而减少人工干预。 除了参数初始化比较困难外，不同输入特征的尺度差异比较大时，梯度下降法的效率也会受到影响。 尺度不同会造成在大多数位置上的梯度方向并不是最优的搜索方向．当使用梯度下降法寻求最优解时，会导致需要很多次迭代才能收敛．如果我们把数据归一化为相同尺度，如图7.9b所示，大部分位置的梯度方向近似于最优搜索方向．这样，在梯度下降求解时，每一步梯度的方向都基本指向最小值，训练效率会大大提高 归一化（Normalization）方法泛指把数据特征转化为相同尺度的方法。 神经网络中几种常用的归一化方法： 最大最小值归一化 … 白化 … 标准化 将每一维的特征都调整为均值为0，方差为1.假设有$N$个样本${ \\pmb{x}^{(n)} }{n=1}^N$,对于每一维特征，我们先计算它的均值和方差： $$ \\mu=\\frac{1}{N}\\sum{n=1}^Nx^{(n)}\\ \\sigma^2=\\frac{1}{N}\\sum_{n=1}^N(x^{(n)}-\\mu) $$ 然后对数据进行标准化 $$ \\hat{x}^n=\\frac{x^{(n)}-\\mu}{\\sigma} $$ 将归一化应用到神经网络中： 逐层归一化 逐层归一化（Layer-wise Normalization）是将传统机器学习中的数据归一化方法应用到深度神经网络中，对神经网络中隐藏层的输入进行归一化，从而使得网络更容易训练． 批量归一化（Batch Normalization，BN） 批量归一化（Batch Normalization，BN）是一种有效的逐层归一化。 设神经网络第$l$层的输入为$a^{(l-1)}$,输出为$a^{(l)}$ $$ a^{(l)}=f(z^{(l)})=f(wa^{(l-1)}+b) $$ 对$z^{(l)}$实施归一化操作： $$ \\hat{z}^{(l)}=\\frac{z^{(l)}-\\mu[z^{(l)}]}{\\sqrt{\\sigma[z^{(l)}]+\\epsilon}} $$ $\\mu[z^{(l)}]$表示均值，$\\sigma^2[z^{(l)}]$表示方差。$z^{(l)}$的期望和方差通常是基于小批量样本的均值和方差近似估计，给定一个包含$K$个样本的小批量样本集合，均值和方差为： $$ \\mu[z^{(l)}]=\\frac{1}{K}\\sum_{k=1}^Kz^{(k,l)}\\ \\sigma^2[z^{(l)}]=\\frac{1}{K}\\sum_{k=1}^K{\\huge[}z^{(k,l)}-\\mu[z^{(k,l)}]{\\huge]}^2 $$ 对净输入𝒛(𝑙) 的标准归一化会使得其取值集中到0 附近，如果使用Sigmoid激活函数时，这个取值区间刚好是接近线性变换的区间，减弱了神经网络的非线性性质．因此，为了使得归一化不对网络的表示能力造成负面影响，可以通过一个**附加的缩放和平移变换改变取值区间**: $$ \\hat{z}^{(l)}=\\gamma{\\huge(}\\frac{z^{(l)}-\\mu[z^{(l)}]}{\\sqrt{\\sigma[z^{(l)}]+\\epsilon}}{\\huge)}+\\beta $$ … 3.1 BN 给定input batch $x \\in \\mathbb{R}^{N\\times C \\times H \\times W}$（相当于上述的$z$）， $$ BN(x)=\\gamma{\\huge(}\\frac{x-\\mu{(x)}}{\\sigma(x)}{\\huge)}+\\beta $$ $\\mu(x)$和$\\sigma(x)$如何计算？ 假设batchsize=N，即一次输入N张图片，其维度为$x\\in \\mathbb{R}^{C\\times H \\times W}$，然后将$x$重构为维度为$x\\in \\mathbb{R}^{C\\times (H \\times W)}$，然后将N张图片进行叠加，沿通道方向计算均值和方差。Batch Normalization是指N张图片的每一张图片的同一个通道一起进行Normalization操作。BN注重对每个batch进行归一化，从而保证数据分布的一致性。但是BN对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布； 其中每一个通道上的均值和方差的计算公式如下： $$ \\mu_c(x)=\\frac{1}{N}\\sum_{n=1}^N{\\huge[} \\frac{1}{HW}\\sum_{h=1}^H\\sum_{w=1}^Wx_{nchw} {\\huge]}\\ \\sigma_c(x)=\\sqrt{ \\frac{1}{N}\\sum_{n=1}^N{\\huge[} \\frac{1}{HW}\\sum_{h=1}^H\\sum_{w=1}^W(x_{nchw}-\\mu_{c}(x))^2 {\\huge]}+\\epsilon } $$ 3.2 IN $$ IN(x)=\\gamma{\\huge(}\\frac{x-\\mu{(x)}}{\\sigma(x)}{\\huge)}+\\beta $$ 其中每个通道上的均值和方差计算公式如下(Instance Normalization是指单张图片的单个通道单独进行Noramlization操作。)： $$ \\mu_{nc}(x)= \\frac{1}{HW}\\sum_{h=1}^H\\sum_{w=1}^Wx_{nchw} \\ \\sigma_{nc}(x)=\\sqrt{ \\frac{1}{HW}\\sum_{h=1}^H\\sum_{w=1}^W(x_{nchw}-\\mu_{nc}(x))^2 +\\epsilon } $$ ​ BN和IN的区别： batch norm是对一个batch里所有的图片的所有像素求均值和标准差。而instance norm是对单个图片的所有像素求均值和标准差。 BN适用于判别模型中，比如图片分类模型。因为BN注重对每个batch进行归一化，从而保证数据分布的一致性，而判别","date":"2020-11-15","objectID":"/arbitrary-style-transfer-in-real-time-with-adaptive-instance-normalization/:0:0","tags":null,"title":"Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization","uri":"/arbitrary-style-transfer-in-real-time-with-adaptive-instance-normalization/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了基于外观流（clothflow）的生成模型来进行姿态引导下的人物图像生成研究（以及虚拟试衣）。 通过估计source clothing 和target clothing之间的光流，能够的建立两者之间的几何变换。 共分为三个阶段: 第一阶段： 以条件姿态为指导，来生成target person semantic layout 来对生成过程提供丰富的指导。将姿态和外观进行解耦，使得clothflow生成更加空间相关的结果。 阶段二： 阶段二为clothflow flow 估计阶段（flow的作用是什么：用于表示原图像中的哪些像素可以被用于生成目标图像的二维坐标向量）。 使用上一阶段得到的target person semantic layout作为输入来得到cloth flow。source cloth region之后通过cloth flow进行warping，以解决几何变形。 预测的外观流提供了视觉对应关系的准确估计，并有助于无缝转移源衣服区域以合成目标图像。 阶段三： 生成模型以warped clothing region作为输入来对target pose进行渲染。 introduction 受到image-to-image translation工作的启发，一些工作直接将原图像和目标姿态作为输入，来生成目标图像。但是这些工作并没有考虑由于人体非刚性的特征引起的变形和遮挡问题，这导致了不能够生成精细的纹理细节。 为了解决geometric deformation问题以更好的进行appearance transfer，提出了两种不同的方法：deformation-based methods and DensePose-based methods. deformation-based methods estimate a transformation，包括了使用affine和TPS来对source image pixel或者是feature map进行deform，以解决由于姿态变化引起的不对齐问题。尽管通过这两种几何建模方法已经取得了很大的进步，但是这种方法的自由度不够高，不能够准确的进行deform。 DensePose-based methods能够将2Dpixel映射到3D body surface，这能够更容易的获得纹理信息。但是基于dense pose的方法生成的图像引入artifacts，例如在原图像和目标图像中有不对应的部分，生成的图像产生空洞。除此之外，基于dense pose的方法的计算量较大。 related work Warping-based Image Matching and Synthesis 在这篇文章中，我们的目标是将source cloth warp 成 target cloth。cloth region是非刚性的，source和target之间没有明确的对应关系。 Optical Flow Estimation 光流法常用于视频处理中，以两个连续的视频帧作为孪生神经网络的输入，之后将第一帧的pixel或feature warp成第二帧。 Conditional Layout Generation 生成目标图像的语义布局图来对外观生成进行指导（限制）。 $$ \\hat{s}t=G{layout}(I_s,s_s,p_t) $$ $s_t,s_s$分别表示目标图像和原图像的segmentation map，$\\hat{s}_t$表示生成目标图像的segmentation map。 为什么不直接用$s_t$？ Cascaded Clothing Flow Estimation 双金字塔结构：source feature pyramid以及target feature pyramid source feature pyramid：输入为$c_s:source \\ cloth;s_s$,通过下采样得到特征${ S_1,S2,S3,S4 }$ target feature pyramid：输入为$target \\ seg: \\ s_t$通过下采样得到特征${ T_1,T2,T3,T4 }$ 通过级联的方式计算clothing flow $F_1,F_2,F_3,F_4$。计算方式如下 $$ F_4=E_4([S_4,T_4])\\ F_3=\\mathcal{U}（F_4)+E_3(\\ [\\mathcal{W}\\ (S_3,\\mathcal{U}(F_4)\\ ),T_3]\\ )\\ F_2=\\mathcal{U}（F_3)+E_2(\\ [\\mathcal{W}\\ (S_2,\\mathcal{U}(F_3)\\ ),T_2]\\ )\\ F_1=\\mathcal{U}（F_2)+E_1(\\ [\\mathcal{W}\\ (S_1,\\mathcal{U}(F_2)\\ ),T_1]\\ ) $$ 其中$E_N$表示卷积层，$\\mathcal{U}(\\ .)$表示$a \\times 2$ nearest-neighbor upsampling。$\\mathcal{W}(S,F)$表示根据$F$使用双线性插值将feature map $S$进行warping，这使得网络能够通过反向传播进行训练。最后利用$F_1$将source cloth $c_s$进行warping：$c_s^\"=\\mathcal{W}\\ (c_s,\\mathcal{U}(F_1)\\ )$。最终的目标： Clothing Preserving Rendering 既然有I_t了为什么得不到s_t？ ","date":"2020-11-15","objectID":"/clothflow-a-flow-based-model-for-clothed-person-generation/:0:0","tags":null,"title":"ClothFlow A Folw-Based Model for Clothed Person Generation","uri":"/clothflow-a-flow-based-model-for-clothed-person-generation/"},{"categories":["深度学习论文阅读笔记"],"content":"1. Idea 可控性的图像生成 提出了具有两个独立pathways的生成器。其中一个pathway是用于pose encoding,另一个用于decomposed component encoding。 对于后者首先使用预训练的human parser从source person image 中自动地分离出component attributes（得到的是semantic layouts）。得到的component layouts之后通过multi-branch embeddings送入global texture encoder中（得到相应的latent code）。得到的latent code通过一种特殊的形式结合得到style code。之后这些表示component attribute的style code通过AdnIN中的仿射变换与pose code相结合。最后进行图像生成。 ","date":"2020-11-15","objectID":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/:0:1","tags":null,"title":"Controllable Person Image Synthesis with Attribute-Decomposed GAN","uri":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/"},{"categories":["深度学习论文阅读笔记"],"content":"2. Contribution 通过直接提供的的不同的源人物图像来控制人物图像属性的生成，解决pose和component attribute之间错综复杂的关系。 提出了attribute-decomposed GAN来进行人物属性合成。 通过利用off-the-shelf human parser 来提取component layouts，使得component attributes进行自动分离，解决了人物属性不高效的标注问题。 ","date":"2020-11-15","objectID":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/:0:2","tags":null,"title":"Controllable Person Image Synthesis with Attribute-Decomposed GAN","uri":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/"},{"categories":["深度学习论文阅读笔记"],"content":"3. Related work image synthesis person image synthesis 目前的person image synthesis方法只是将条件图像转换为具有目标姿态的图像。但是本文中的方法不仅仅能够对姿态进行控制，还能够对component attributes（例如头，上衣和裤子）进行控制。而且生成的图像具有更加真实的纹理和连续的ID信息。 ","date":"2020-11-15","objectID":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/:0:3","tags":null,"title":"Controllable Person Image Synthesis with Attribute-Decomposed GAN","uri":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/"},{"categories":["深度学习论文阅读笔记"],"content":"4. Method description 本文的目标生成具有用户控制属性（例如头发，上衣和裤子）的人物图像。与之前的属性编辑方式不同（之前的方法需要每一个属性都进行标注的标签数据），本文中通过精心设计的生成器来对component attributes进行自动和无监督的分离。因此本文中只需要无需对每一属性进行标注的人物图像训练数据。在训练期间，目标图像$p_t$和条件图像$I_s$送入生成器中，输出生成图像$I_g$。 4.1 Generator 生成器通过两个独立pathways将$p_t$和$I_s$表示为两个隐变量，分别称为pose encoding和decomposed component encoding。这两个pathways通过一系列的style blocks连接，style blocks将源人物图像的纹理风格嵌入到pose feature。 4.1.1 pose encoding 在pose pathways中$p_t$通过pose encoder映射到隐空间中，用$C_{pose}$表示，其中pose encoder有N个下采样卷积层构成（N=2）。 4.1.2 Decomposed component encoding 在source pathways中$I_s$通过一个称为decomposed component encoding（DCE）的模块映射到隐空间中，用$C_{sty}$表示。 DCE这一模块首先提取$I_s$的semantic map $S$ (通过预训练的human parser进行$S$的提取)，并将$S$转换为K个通道的heat map $M\\in R^{K\\times H\\times W}$。每一个通道$i$对应一个相应的component（例如上衣），用二进制掩模$M_i$来表示。其中K=8，分别表示（face，hair，paints,upper clothes，skirts,arm,leg,background） 有component $i$的解耦的人物图像$I_s^i$是通过将$I_s$和相应的$M_i$相乘得到的。 $$ I_s^i=I_s\\odot M_i $$ $I_s^i$之后被送入texture encoder $T_{enc}$来获取每一分支(不同的component)相应的style code $C_{sty}^i$。 $$ C_{sty}^i=T_{enc}(I_s^i) $$ 每一个分支的$T_{enc}$的权重的共享的，之后将每一个$C_{sty}^i$进行叠加得到最终的$C_{sty}$。 相比于直接将整个源人物图像进行编码，DCE将源人物图像解耦为不同component并将相应的隐编码进行结合得到最终的style code。DCE的好处有两个：1）该方法加快了模型的收敛速度，在较短的时间内获得了较好的仿真结果。由于由不同服装和姿势的人的图像组成的集合的复杂结构，很难用详细的纹理编码整个人，但只学习人的一个组成部分的特征要简单得多。此外，不同的组件可以共享相同的网络参数进行颜色编码，因此DCE隐式地为纹理学习提供了数据扩充。2）该方法可以进自动和无监督的属性分离而需要在训练集有任何的标注。DCE利用已有的human parser对人物进行空间解耦，在style code的固定位置进行特定attribute的学习。因此我们可以很容易的通过加入从不同source persons提取的期望的component codes来进行component attributes的控制。 对于texture encoder $T_{enc}$，本文引入了一种全局纹理编码的结构，通过将相应层中的VGG特征连接到我们的原始编码器。原始编码器中的参数值是可学习的，而VGG中的参数值是固定的。在COCO训练集上预训练的VGG网络有一定的全局属性和较强的泛化能力。但是和一般的风格迁移任务不同，该模型需要生成明确的结果，对于固定编码器的结构来说很难适用于该模型，因此引入了可学习编码器。 4.1.3 Texture style transfer texture style transfer的目的是将源人物图像纹理特征与目标姿态姿态进行结合，起到了连接pose code和style code的作用。这个transfer network由几个级联的style blocks构成，每一个style block都由一个fusion module 和具有AdaIN 的残差卷积块构成。以第t个style block进行分析，其输入为上一个style block的输出$F_{t-1}$和style code $C_{sty}$，其输出为 $$ F_t=\\varphi_t(F_{t-1},A)+F_{t-1} $$ 其中$\\varphi_t$表示卷积块，$F_0=C_{pose}$ 。共采用了**8个style blocks**（与解耦的8个component attributes相对应，如果想要对某个component attribute进行改变，就要将对应的component style code进行改变）。A表示AdaIN层中已学习到的仿射参数（缩放$\\mu$和变化$\\sigma$），其能够用于将特征规范化为期望的style。这些参数能够使用fusion module（FM）从style code$C_{sty}$中提取出来,FM是DCE中很重要的辅助模型。因为component codes是通过特殊的顺序进行叠加来构成style code的，这使得位置和component feature之间是高度相关的，这就强加了很多人为的干预，并导致了与网络本身的学习倾向的冲突。因此，我们引入了由3个全连接的层组成的FM，**前两个层允许网络通过线性重组灵活地选择所需的特征，最后一个层提供所需维度的参数**。**FM可以有效地分离特征，避免前向操作和后向反馈之间的冲突。** 如何通过style code计算AdaIN的参数$\\mu$和$\\sigma$：将维度为$64\\times 512$的style code经过FM重构为维度为$8192\\times 1$的特征，其上半部分的特征共4096维用于计算$\\mu$，下半部分用于计算$\\sigma$。由于共有8个style blocks，所以每个style blocks分给512维特征，且每个style block有两个AdaIN层，每一个AdaIN层分给64为特征用于计算AdaIN层参数。 4.1.4 person image reconstruction 解码器由N个反卷积层构成（N=2）。 4.2 Discriminators 判别器由$D_p$和$D_s$构成，$D_p$是由于保证$I_g$和$I_t$的人物姿态是对齐的，$D_s$是由于保证$I_g$和$I_s$的外观纹理是相同的。$D_p$和$D_s$采用patchGAN进行实施。 4.3 Training 损失函数包括对抗损失函数、L1损失函数、感知损失函数以及内容损失函数。总的损失函数为： $$ {\\cal{L}}{total}={\\cal{L}}{adv}+\\lambda_{rec}{\\cal{L}}_{rec}+\\lambda_{per}{\\cal{L}}_{per}+\\lambda_{CX}{\\cal{L}}_{CX} $$ L1损失函数 使用L1损失函数的目的是直接指导$I_g$和$I_s$的外观纹理相同,这避免了明显的颜色失真，加快了算法的收敛速度，获得满意的结果。 $$ \\cal{L}_{rec}=\\Vert G(I_s,p_t) -I_t\\Vert $$ 感知损失函数 除了需要在RGB空间中满足低层的约束外，还需要利用预训练的VGG来提取特定层的深层特征用于纹理匹配。由于视觉风格统计特性能够通过特征相关性来表示，所以本文中使用了特征的Gram矩阵来度量纹理相似性。Gram矩阵的计算为： $$ \\cal{G}(\\cal{F}^l(I_t))=[\\cal{F}^l(I_t)][\\cal{F}^l(I_t)]^T $$ 其中$\\cal{F}^l(I_t)$表示通过预训练的VGG提取的$I_t$的$l$层的特征。因此感知损失函数为： $$ {\\cal{L}_{per}}={\\Vert {\\cal{G}}{({\\cal{F}}^l {(G(I_s,p_t))})}-\\cal{G}(\\cal{F}^l(I_t))\\Vert} $$ 内容损失函数 内容损失函数最初被提出用于度量image translation任务中两张non-aligned图片的相似性。相比于pixel-level损失需要pixel-to-pixel alignment，内容损失函数允许相对目标的空间变形，能够得到更少纹理失真和更合理的结果。内容损失函数为： $$ {\\cal{L_{cx}}}=-log[CX({\\cal{F}^l(I_g)},{\\cal{F}^l(I_t)})] $$ 其中$l=relu{ 3_-2,4_-2}$，是通过VGG19提取出来的，$CX$表示匹配特征的相似度量函数，考虑了像素的语义平均值以及整张图片的内容。 工作的不足之处 只是用AdaIN将style code融入到pose中（实际上纹理细节会有缺失），实际上在纹理细节方面保持的不是那么的好，例如某些衣服的纹理保持的不是很好。 可改进的方向 是否可以利用source pose 来指导style code融入到target pose中？ 可不可以结合注意力机制，进行风格转换？ 注","date":"2020-11-15","objectID":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/:0:4","tags":null,"title":"Controllable Person Image Synthesis with Attribute-Decomposed GAN","uri":"/controllable-person-image-synthesis-with-attribute-decomposed-gan/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了一种基于深度学习的姿态引导下的图像生成方法。 该方法的核心是能够基于单一图像估计出完整身体的纹理。 ","date":"2020-11-15","objectID":"/coordinate-based-texture-inpainting-for-pose-guided-human-image-generation/:0:0","tags":null,"title":"Coordinate-based Texture Inpainting for Pose-Guided Human Image Generation","uri":"/coordinate-based-texture-inpainting-for-pose-guided-human-image-generation/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了一种建立两张图像间密集语义对应关系的模型（ANC-Net）, non-isotrppic（非各向同性） 4D convolution kernel – 核心， multi-scale self-similarity module orthogonal loss ANC-Net 以两张图像作为输入，输出为4D correlation map – 包含两张图像间所有可能匹配的匹配分数。 Method 网络结构如图所示。 输入$(I^s,I^t)$ feature extractor $\\mathcal{F}$ -\u003e输出 $F^s$和$F^t$ multi-scale self-similarity $\\mathcal{S}$ -\u003e输出 multi-scale self-similarity $S^s$和$S^t$-\u003ecaptures the complex self-similarity feature map We can then obtain the 4D correlation map $C_s$ from $S^s$ and $S^t$ , and the 4D correlation map $C_f$ from $F^s$ and $F^t$ . However, $C_s$ and $C_f$ are often noisy as they lack the constraints to enforce the correspondence validity, and thus are unreliable for directly extracting correspondences. ANC module $\\mathcal{N}$ -\u003e a stack of non-isotropic 4D convolutions -\u003etakes $C_s$ and $C_f $ as inputs , refining them by considering neighbourhoods with varying sizes. Finally, the ANC module combines the refined correlation maps by simply summing up the two, producing a single 4D correlation map $\\bar{C}$ from which reliable correspondences can be retrieved. ","date":"2020-11-15","objectID":"/correspondence-networks-with-adaptive-neighbourhood-consensus/:0:0","tags":null,"title":"Correspondence Networks with Adaptive Neighbourhood Consensus","uri":"/correspondence-networks-with-adaptive-neighbourhood-consensus/"},{"categories":["深度学习论文阅读笔记"],"content":"Multi-scale self-similarity 给定特征$F\\in \\mathbb{R}^{h_f\\times \\omega_f \\times d}$ , self-similarity map 度量每一个特征位置之间的局部相似性。 计算$F$中位置$(i,j)$处的特征$f_{i,j}$的self - similarity map 的方法是计算与它自身和它邻域之间的余弦相似性。 如上图所示，考虑一个特征$f_{i,j}$的$3\\times 3$邻域，可以计算得到$3\\times 3$个self-similarity scores，将其进行向量化，最终可以得到self-similarity features map $S_0\\in \\mathbb{R}^{h_f \\times \\omega_f \\times 9}$。 为了进一步得到不同self-similarity features 之间的相关性，对$S_0$进行两次zero-padding convolution 操作，分别得到$S_1$和$S_2$。然后将三个不同尺寸的feature map $S_0, S_1 ,S_2$进行叠加得到$S$，其作为最后一层的输入。 ","date":"2020-11-15","objectID":"/correspondence-networks-with-adaptive-neighbourhood-consensus/:1:0","tags":null,"title":"Correspondence Networks with Adaptive Neighbourhood Consensus","uri":"/correspondence-networks-with-adaptive-neighbourhood-consensus/"},{"categories":["深度学习论文阅读笔记"],"content":"Adaptive neighborhood consensus 什么是4D卷积核？ 各向同性的4D卷积核被用于修正4D correlation map 。各向同性的4D卷积核可以被认为建立了两张图像相同尺寸的两个邻域。 然而在实际的图像中的物体，有变化的尺寸和形状，描述相同语义的两个邻域可能有不同的尺寸。因此使用相同尺寸的邻域可能会引入噪声（例如不相关的背景）。为了解决这一问题引入了ANC module ，其包含了一系列的非各向同性4D卷积核。 在模型中，为了解决物体变化的尺寸和形状，将各向同性4D卷积核与非各向同性4D卷积核相结合，使得模型能够动态的决定使用哪一个卷积核 ","date":"2020-11-15","objectID":"/correspondence-networks-with-adaptive-neighbourhood-consensus/:2:0","tags":null,"title":"Correspondence Networks with Adaptive Neighbourhood Consensus","uri":"/correspondence-networks-with-adaptive-neighbourhood-consensus/"},{"categories":["深度学习论文阅读笔记"],"content":"Most likely matches ","date":"2020-11-15","objectID":"/correspondence-networks-with-adaptive-neighbourhood-consensus/:3:0","tags":null,"title":"Correspondence Networks with Adaptive Neighbourhood Consensus","uri":"/correspondence-networks-with-adaptive-neighbourhood-consensus/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了一种新颖的图像翻译网络框架。 cross-domain correspondence network： 网络的输入为style input和content input，由于style input和content input在结构上是不对齐的，为了建立style input和content input之间的对应关系，提出了一种cross-domain correspondence network,如图所示： 该部分首先通过特征金字塔网络提取多尺度图像特征（这能够利用到局部和全局的图像内容），之后将提取到的多尺度特征通过下采样网络映射到相同的域$S$中（只有当$x_s$和$y_s$在同一个域时才能用某种相似性度量方法进行匹配（对齐））。数学表达式如下： $$ x_s=\\mathcal{F}{A\\rightarrow S}(x_A;\\theta{A\\rightarrow S}) \\quad x_s\\in\\mathbb{R}^{HW \\times C}\\ y_s=\\mathcal{F}{B\\rightarrow S}(x_B;\\theta{B\\rightarrow S}) \\quad y_s\\in\\mathbb{R}^{HW \\times C} $$ 接下来使用空间自注意力机制操作计算$x_s$与$y_s$间pixel与pixel之间的相关性，如下图所示: translation network： cross-domain correspondence network的输出视为将content input warping 之后的结果，translation network采用了类似style GAN的网络结构，如下图所示： 与style GAN不同的是，这里将AdaIN模块进行了替换，替换的模块为SPADE block与PN的结合，表达式为： $$ \\alpha {h,w}^i(r{y \\rightarrow x}) \\times\\frac{F_{c,h,w}^i-\\mu_{h,w}^i}{\\sigma_{h,w}^i}+\\beta_{h,w}^i(r_{y \\rightarrow x}) $$ $F_{c,h,w}^i$为输入值，注意此处的统计特征$\\mu_{h,w}^i$和$\\sigma_{h,w}^i$是在空间方向进行统计的，目的是为了保存$r_{y \\rightarrow x}$的结构信息。 损失函数： 该文采用了无监督的训练方式。 总的网络结构： ","date":"2020-11-15","objectID":"/cross-domain-correspondence-learning-for-exemplar-based-image-translation/:0:0","tags":null,"title":"Cross-domain Correspondence Learning for Exemplar-based Image Translation","uri":"/cross-domain-correspondence-learning-for-exemplar-based-image-translation/"},{"categories":["深度学习论文阅读笔记"],"content":"姿态引导下的图像生成研究就是要在保留原图像外观的同时将原图像中人物的姿态转换为目标姿态。这一任务需要对原图像进行空间转换。但实际上基于卷积的神经网络更擅长于特征的提取而不擅长于特征的空间转换，所以单纯的使用卷积神经网络并不能很好的完成这一任务。 这篇文章提出了一种global-flow local-attention 模型进行姿态应引导下的图像生成研究。具体来说第一步使用全局流场估计器计算原图像和目标图像之间的全局相关性，以此来预测flow fileds。第二步为使用从feature maps提取出来的flowed local patch pairs来计算局部注意力系数。第三步为使用局部注意力机制作为content aware sampling method来进行图像的外观渲染。 该文将注意力机制和流场操作相结合，使得每一个输出位置只与原图像的局部特征块相关 将目标图像视为原图像的变形结果 该文的观点是将目标图像视为原图像的变形结果，每一个输出位置只与原图像的局部特征相关。 Introduction 图像的空间转换可以用于解决许多输入图像和目标图像空间不对齐的图像生成任务，这些不对齐可能是由于姿态变换或者是视角的变换。这一类任务包括了姿态引导下的图像生成研究 卷积神经网络使用共享参数的卷积核来计算输出，这也是卷积神经网络的一个重要特性，称为平移等变（equivariance to transformation），这意味着当输入发生平移空间变化时，输出也会发生平移相同的空间变化。这一特性对于输入输出的空间结构是对齐的任务来说是十分有益的，例如图像分割，图像检测以及图像翻译。但是这一特性也限制了卷积神经网络对输入数据进行空间变换。 卷积神经网络具有平移等变得性质，但是并不能够对旋转、缩放等操作具有等变性，特别是对于人体这种非刚体，卷积神经网络并不能对输入数据进行空间变换 STN的通过引入空间转换模块来解决这一问题，该模块对全局转换参数进行回归，并通过仿射转换来扭曲输入特征。但是，由于它假定了源和目标之间的全局仿射变换，因此该方法无法处理非刚性对象的变换。 注意力机制通过利用非局部信息，建立特征之间的长程依赖。但是对于空间转换任务，目标图像和原图像在空间上是不对齐的，每一个输出图像上位置与原图像上的位置有明确的对应关系。因此原图像和目标图像之间的注意力权重矩阵应该是一个稀疏矩阵。 基于流场的操作通过为每一个输出位置采样一个局部的原图像块会迫使注意力权重矩阵变为稀疏矩阵。这些方法预测二维坐标偏移量，指定可以对源中的哪些位置进行采样以生成目标。 然而为了稳定训练，大多数的基于流场的方法会在像素级别扭曲数据，这会限制模型生成新的内容。由于需要生成全分辨率流场，因此难以提取大的运动。在特征级别进行输入数据的扭曲能够解决这一问题，然而，这些网络很容易陷入局部最小值由于以下两个原因：（1）输入特征和流场相互限制。没有准确的流场，输入特征无法获得合理的梯度，没有如果没有合理的特征，网络也无法提取相似性以生成正确的流场。（2）常用的双线性采样方法提供的不良梯度传播进一步导致训练中的不稳定。 Approach 对于姿态引导下的图像生成研究，目标图像是原图像的变形结果，这意味着目标图像中的每一个点是与原图像中的某个特定的局部区域唯一对应。 该文设计了global-flow local-attention 网络结构来合理的对原图像特征进行采样和重构。网络包含两个部分：全局流场估计器F和局部自然纹理渲染器G。F负责估计原图像和目标图像的运动（差别），其生成全局流场w和二进制掩模m。利用w和m，G利用局部注意力模块将原图像的纹理渲染在目标图像。 Global Flow Filed Estimator $$ w,m=F(x_s,p_s,p_t) $$ 其中$x_s$表示原图像，$p_s$表示原图像姿态，$p_t$表示目标姿态。$w$包含了原图像和目标图像的坐标偏移量。$m$的值在0至1之间，表示原图像中是否存在目标位置的信息。F为全卷积网络，w和m权重共享。 由于真实的坐标偏移量是未知的，这里使用了sampling correctness loss来计算$w$。$v_s,v_t$分别表示原图像和目标图像通过预训练的VGG19的特定层提取出来的特征。$v_{s,w}=w(v_s)$表示$v_s$通过$w$转换之后的结果。sampling correctness loss计算$v_{s,w}$和$v_t$之间的余弦相似性。 $$ \\mathcal{L}_c=\\frac{1}{N}\\sum_{l\\in \\Omega}exp(-\\frac{\\mu(v_{s,w}^l,v_t^l)}{\\mu_{max}^l}) $$ $\\mu$表示余弦相似度。$\\Omega$表示特征图中的所有的N个点，$l$表示其中的一个点$(x,y)$。$\\mu_{max}^l$表示正则项。也就是说需要对**所有的点**计算余弦相似度，然后再求平均值。 ​ sampling correctness loss能够限制流场采样语义相关的区域。由于图像领域之间的变形是高度相关的，如果能够将这种关系提取出来是十分有益的，因此进一步在流场中添加了正则项。令$c_t$表示目标特征的二位坐标。$\\mathcal{N}(c_t,l)$表示$c_t$的$n\\times n$个领域图像块，假设$\\mathcal{N}(c_t,l)$和$\\mathcal{N}(c s,l)$之间的变换为仿射变换 $$ T_l=A_l S_l $$ $T_l$表示$\\mathcal{N}(C_l,l)$的坐标集合，$S_l$表示$\\mathcal{N}(c_s,l)$的坐标集合，$A_l$表示仿射参数，通过最小二乘法计算出来 $$ \\hat{A_l}=(S_l^HS_l)^{-1}S_l^HT_l $$ 因此正则损失函数为 $$ \\mathcal{L}r=\\sum{l\\in\\Omega}|| T_l-\\hat{A}_lS_l ||^2 $$ Local Neural Texture Renderer 纹理渲染器的目标是将原图像中的信息进行空间转换，生成图像 $$ \\hat{x}_t=G(x_s,p_t,w,m) $$ 信息转换在局部注意力模块中进行。这一模块的作用是将原图像的纹理渲染在目标姿态上。 令$f_t$和$f_s$分别表示$p_t$和$x_s$经过下采样提取出来的特征。首先通过双线性插值提取出局部图像块$\\mathcal{N}(f_t,l)$和$\\mathcal{N}(f_s,l+w^l)$。之后使用核预测网络（就是全连接层）来生成注意力权重矩阵$k_l$。 $$ k_l=M(\\mathcal{N}(f_t,l),\\mathcal{N}(f_s,l+w^l)) $$ 最后将对应的原图像块$\\mathcal{N}(f_s,l+w^l)$与注意力权重矩阵相乘（注意此时只是将坐标$l$处的特征进行了处理） $$ f_{attn}^l=P(k_l\\otimes \\mathcal{N}(f_s,l+w^l)) $$ $P$表示平均池化操作。总的the warped feature map $f_{attn}$ 通过在每一个位置重复上述步骤获得。 由于遮挡的情况，原图像和目标图像之间并不是每一个位置都能对应。为了使这些不对应的地方生成新的内容，利用了之前获得的掩模$m$。(掩模的作用是当原图像和目标图像的位置对应时就在该位置为1，没有对应就为0) $$ f_{out}=(1-m)*f_t+m*f_{attn} $$ 此处主要的贡献在于通过content-aware sampling operation（即引入了注意力机制）进行source feature的warping（代替了原先的双线性插值方法） 损失函数 略 实验的实施细节 实验前需要确定的是：局部注意力模块的个数；局部图像块$\\mathcal{N}(f_t,l)$和$\\mathcal{N}(f_s,l+w^l)$的大小；一个局部图像块要进行几次attention操作，即一个局部图像块要分隔成几部分（进行warped操作的小图像块大小） 对于Deepfashion，采用两个局部注意力模块；局部图像块的大小分别为64、 32；局部图像块进行warped操作的小图像块大小分别为3,5 分阶段训练：首先训练$F$,再训练整个模型 总结 1.通过这种仿射操作确实能够生成逼真的图片，但是这样将图像分成一个一个小图像块进行操作，计算量是不是太大了？ 2.之前提到的稀疏注意力我认为指的是进行一个一个小图像块的注意力操作，而不是进行一整个图像的注意力操作 3.在局部注意力模块中，是以原图像路径作为主路径，因为实际上是将图像与注意力权矩阵进行了相乘，最后得到的是warped后的图像特征。个人认为这和PATN的想法基本上是一致的，不同的是在2中提到的，PATN进行的是一整个图像的注意力操作，而该问进行的是一个一个小图像块的操作。所以可以理解为这是对PATN方法的一个改进。 4.把local warp做的很细，做到每一个点进行warping（实际上是对小的patch进行warping） ","date":"2020-11-15","objectID":"/deep-image-spatial-transformation-for-person-image-generation/:0:0","tags":null,"title":"Deep Image Spatial Transformation for Person Image Generation","uri":"/deep-image-spatial-transformation-for-person-image-generation/"},{"categories":["深度学习论文阅读笔记"],"content":"该工作为根据提供的两张视频帧和草图，来来生成连续的视频帧。 将粗糙的草图进行简化，提取出主要的结构 建立草图与图像之间的语义对应关系： 2.1 通过以两帧图片为条件的transformation module来将草图中的大部分空白区域进行填充， 2.2 然后通过来两个独立的特征提取模块将图像和草图映射到一个common space 2.3 为了解决遮挡问题，通过两张图像间光流来估计occlusion mask,并通过blending module使用mask来动态的从两帧之间挑选和结合像素。（合成与草图空间结构一样的视频帧） 利用 arbitrary-time frame interpolation module生成任意中间的视频帧 利用video post processing进一步改善结果 Sketch Simplification and Generation 由于草图可能是粗糙且随意的，所以通过该模块来将草图多余的细节清除，只留下清晰的线条。采用的是现有的方法。 Sketch-guided Frame Synthesis ","date":"2020-11-15","objectID":"/deep-sketch-guided-cartoon-video-synthesis/:0:0","tags":null,"title":"Deep Sketch-guided Cartoon Video Synthesis","uri":"/deep-sketch-guided-cartoon-video-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"2.1 通过以两帧图片为条件的transformation module来将草图中的大部分空白区域进行填充： The transformer consists of several dilated residual ","date":"2020-11-15","objectID":"/deep-sketch-guided-cartoon-video-synthesis/:0:1","tags":null,"title":"Deep Sketch-guided Cartoon Video Synthesis","uri":"/deep-sketch-guided-cartoon-video-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"2.2 然后通过来两个独立的特征提取模块将图像和草图映射到一个common space ","date":"2020-11-15","objectID":"/deep-sketch-guided-cartoon-video-synthesis/:0:2","tags":null,"title":"Deep Sketch-guided Cartoon Video Synthesis","uri":"/deep-sketch-guided-cartoon-video-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"2.3 利用现有的光流预测模型预测光流，注意：预测的光流为双向光流：$f_{0-t}，f_{t-1}$。 损失函数：","date":"2020-11-15","objectID":"/deep-sketch-guided-cartoon-video-synthesis/:0:3","tags":null,"title":"Deep Sketch-guided Cartoon Video Synthesis","uri":"/deep-sketch-guided-cartoon-video-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"该文为人物的时尚编辑 网络包含三个部分： Free-form Parsing Network Parsing-aware Inpainting Network Attention Normalization Layers Free-form Parsing Network 给定不完整的人体语义分析图以及任意的草图和笔画，能够合成完整的人体语义分析图。 网络结构 ： U-net 输入： an incomplete parsing map, 2. a binary sketch that describes the structure of the removed region 3. a noise sampled from the Gaussian distribution, 4. sparse color strokes 5. a mask. 注意：相同的incomplete parsing map和不同的sketch和strokes能够合成不同的parsing map,这意味这parsing generation model是可控的。 Parsing-aware Inpainting Network 网络结构： 输入： Incomplete image + composed mask -\u003e partial conv encoder Synthesized parsing -\u003e standard conv encoder Attention Normalization Layers 网络结构： 数学表达式： 其中 ​ $\\alpha$：leaned attention map ​ $\\beta$ : bias Sketch+Color+Noise -\u003eConv-\u003eConv -\u003eSigmoid-\u003e leaned attention map Sketch+Color+Noise -\u003eConv-\u003eConv-\u003e bias Attention normalization layers有效性的解释： The effectiveness of ANLs is due to their inherent characteristics. Similar to SPADE, ANLs also can avoid washing away semantic information in activations, since the attention map and bias are spatially-varying. Moreover, the multi-scale ANLs can not only adapt the various scales of activations during upsampling but also extract coarse-to-fine semantic information from external data, which guide the fashion editing more precisely. avoid washing away semantic information in activations - \u003e attention map and bias are spatially-varying can not only adapt the various scales of activations during upsampling but also extract coarse-to-fine semantic information from external data -\u003e多尺寸的激活值，以及从“粗到细”的语义信息 与SPADE的比较： ","date":"2020-11-15","objectID":"/fashion-editing-with-adversarial-parsing-learning/:0:0","tags":null,"title":"Fashion Editing with Adversarial Parsing Learning","uri":"/fashion-editing-with-adversarial-parsing-learning/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 注意到图c，此时生成器的损失函数是平稳上升的，训练过程是稳定的（在实际的GAN训练过程中，生成器的损失函数是上升的，判别器的损失函数是下降的？还是生成器和判别器的损失函数最终都是下降的？）从该论文的观点来看似乎是前者是正确的。 但是可以肯定的是，如果生成器的损失函数出现了a，b的情况就表示GAN的训练过程是不稳定的。 DCGAN验证实验 code ","date":"2020-11-15","objectID":"/gan_______________________________________________________________/:0:0","tags":null,"title":"GAN训练中生成器损失函数的变化应该是怎么样的？","uri":"/gan_______________________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"实验1：没有进行谱归一化 训练过程中损失函数的变化： 真实图像和生成图像的对比： 从损失函数的变化来看，生成器的损失函数是逐渐增大的，而判别器的损失函数似乎并没有发生多大的变化。从生成图像来看，生成的图像虽然不太逼真，但是似乎并没有发生模型崩溃的情况，似乎可以认定训练过程是稳定的。 ","date":"2020-11-15","objectID":"/gan_______________________________________________________________/:1:0","tags":null,"title":"GAN训练中生成器损失函数的变化应该是怎么样的？","uri":"/gan_______________________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 Hinge loss专用于二分类问题，标签值y=±1，预测值$\\hat{y}\\in R$。该二分类问题的目标函数的要求如下： 当$\\hat{y}$大于等于+1或者小于等于-1时，都是分类器确定的分类结果，此时的损失函数loss为0；而当预测值$\\hat{y}\\in (-1,1)$时，分类器对分类结果不确定，loss不为0。显然，当时$\\hat{y}=0$,loss达到最大值。 对于输出y=±1，当前$\\hat{y}$的损失为**： $$ \\mathcal{L}=max(0,1-y \\cdot \\hat{y}) $$ 上式是Hinge loss在二分类问题的的变体，可以看做双向Hinge loss。难以理解的话，可以先看单方向的hinge loss。以y=+1，为例。当y⩾1时，loss为0，否则loss线性增大。函数图像如下所示： ","date":"2020-11-15","objectID":"/hinge-loss/:0:0","tags":null,"title":"hinge loss","uri":"/hinge-loss/"},{"categories":["深度学习论文阅读笔记"],"content":"人体解析是指将在图像中捕获的人分割成多个语义上一致的区域，例如， 身体部位和衣物。作为一种细粒度的语义分割任务，它比仅是寻找人体轮廓的人物分割更具挑战性。 人体解析对于以人为中心的分析非常重要，并且具有许多工业上的应用，例如，虚拟现实，视频监控和人类行为分析等等。 ","date":"2020-11-15","objectID":"/human-parser/:0:0","tags":null,"title":"human parser","uri":"/human-parser/"},{"categories":["深度学习论文阅读笔记"],"content":"直观理解： 对于当前运行的程序one.py而言，name 变量的值是”main\"。 如果two.py调用了one.py，即import one，那么对one.py而言__name__变量的值是”one\"，对于two.py而言__name__变量的值是”main\"。 背后原因： 有时我们写了可以直接被执行的模块（.py文件），但是在另一个程序中调用它时，我们其实只是想用一用里面写好的函数，而不是全都执行一遍。那么我们就可以把执行的部分放到if name == ‘main’ 中进行判断。 如果if name == ‘main’ 为真，就说明我们是在直接执行这个模块，那么所有的操作都要运行一遍；但如果为假，就说明我们是引用了这个模块，只有在需要用到它的函数时，才会被调用执行。 定义一个py文件：one.py\rdef func():\rprint(\"func() in one.py\")\r#此时\"__name__\"等于“__main_-”\r if __name__ == \"__main__\":\rprint(\"one.py is being run directly\")\relse:\rprint(\"one.py is being imported into another module\")\r 运行one.py的结果如下：\rone.py is being run directly\r 定义一个py文件：two.py\rimport one\r#此时将会运行one.py的else部分。因为对于one.py来说“__name__”不等于“__main__”。\r #输出为one.py is being imported into another module\r #也就是说当一个py文件被别的py文件调用时，它的\"__name__\"属性不等于\"__main__\"\r print(\"top-level in two.py\")\rone.func()\rif __name__ == \"__main__\":\rprint(\"two.py is being run directly\")\relse:\rprint(\"two.py is being imported into another module\")\r 运行two.py的结果如下\rone.py is being imported into another module\rtop-level in two.py\rfunc() in one.py\rtwo.py is being run directly\r ","date":"2020-11-15","objectID":"/if-__name____main__%E7%9A%84%E7%90%86%E8%A7%A3/:0:0","tags":null,"title":"if __name__=='__main__'的理解","uri":"/if-__name____main__%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Java学习笔记"],"content":"Java简介 Java将源代码编译成一种“字节码”，虚拟机（JVM）负责加载字节码并执行。 名词解释 JDK：Java Development Kit JRE：Java Runtime Environment 简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。 在JDK的bin目录下可以找到很多可执行文件： javac : 这是java的编译器，它用于把java源文件（以.java后缀结尾）编译成java字节码文件（以.class后缀结尾）； java : 这其实就是虚拟机（JVM）,负责执行java字节码。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:0:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"第一个java程序 public class Hello{ public static mean(String[] args){ System.out.println(\"hello,world!\"); } } 在java程序中 public class Hello{ ... } 为类的定义，Hello为类名，public表示这个类是公开的。 在类中定义了方法： public static mean(String[] args){ ... } 方法是可执行代码块，mean为方法名，用()括起来的是方法参数，这里的参数类型为String[],参数名为args,public，static用来修饰方法，表明该方法为公开静态方法，void为方法的返回类型，{}中间为方法的代码，这才是真正执行的代码，必须以;结尾。 把代码保存为文件时，文件名必须和类名Hello一样，为Hello.java。 如何运行Java程序 注意javac是编译器，java是虚拟机 $ javac Hello.java 当前目录会产生Hello.class文件（字节码文件） $ java Hello \u003ehello,world! 注意：给虚拟机传递的的参数是类名Hello。 Java程序基础 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Java程序基本结构 /** *注释 */ public class Hello{ public static main(String[] args){ ...//真正执行的语句，必须以`;`结尾 } }//class定义结束 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"变量和数据类型 在java中变量分为两种：基本类型变量和引用类型变量 先讨论基本类型变量。 在java中，变量必须先定义再使用。 变量有一个重要特点是可以重新赋值。 //重新赋值变量 public class Main{ public static void main(String[] args){ int x=100;//定义int类型变量x，并赋予初始值100 System.out.println(x); x=200;//对x重新赋值 System.out.println(x); } } 变量不但可以重新赋值，还可以赋值给其他变量。 public class Main{ public static void main(String[] args){ int x=100;//定义int类型变量x，并赋予初始值100 System.out.println(x); x=200;//对x重新赋值 System.out.println(x); int n=x;//赋值给其他变量 System.out.println(x); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"基本数据类型 整数类型 ：byte,short,int,long 浮点数 ：float,double 字符类型：char 布尔类型：boolean 计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit,它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。 一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。 不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数： ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘ 整型 java只定义了带符号的整型，最高位的bit表示符号位(0表示正数，1表示负数)。各种整型能表示的最大范围： byte : -128~127 short :-32768 ~ 32767 int: -2147483648 ~ 2147483647 long: -9223372036854775808 ~ 9223372036854775807 浮点数 下面是定义浮点数的例子： float f1=3.14f; double d1=1.79e308; 对于float类型，需要加上后缀f。 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 布尔类型 bloolean b1=true; 字符类型 字符类型char表示一个字符。 public class Main{ public static void main(String[] args){ char a='A'; char zh='中'; System.out.println(a); System.out.println(zh); } } 注意char类型使用单引号'，且仅有一个字符，要和双引号\"的字符串类型区分开。 再讨论引用类型。 引用类型 除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是String字符串： String s=\"hello\" 引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置。(引用变量在栈内存，指向的对象在堆内存) 常量 定义变量时如果加上final修饰符，就变成常量： final double PI=3.14; double r=50; double area=PI*r*r; PI=300;//error! 常量在定义时进行初始化后就不可再次赋值。 var关键字 有些时候，类型的名字太长，写起来比较麻烦。例如： StringBuilder sb=new StringBuilder 这个时候，如果想省略变量类型，可以使用var关键字： var sb = new StringBuilder(); 编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。 变量的作用范围 在语句块中定义的变量有一个作用域，就是从定义处开始，到语句块结束。超出作用域引用这些变量，编译器就会报错。 { ... int i = 0; // 变量i从这里开始定义 ... { ... int x = 1; // 变量x从这里开始定义 ... { ... String s = \"hello\"; // 变量s从这里开始定义 ... } // 变量s作用域到此结束 ... // 注意，这是一个新的变量s，它和上面的变量同名， // 但是因为作用域不同，它们是两个不同的变量: String s = \"hi\"; ... } // 变量x和s作用域到此结束 ... } // 变量i作用域到此结束 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:3:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"整数运算 整数运算的除法只能得到结果的整数部分： int x=12345/67;//184 求余运算： int y=12345%67;//17 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"溢出 要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果： public class Main{ public static void main(String[] args){ int x = 2147483640; int y = 15; int sum = x + y; System.out.println(sum); // -2147483641 } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"自增/自减 ++对一个整数进行加1操作，--对一个整数进行减1操作。 public class Main{ public static void main(String[] args){ int x=3300; n++; System.out.println(n); } } \u003e\u003e3301 注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"移位运算 左移\u003c\u003c,右移\u003e\u003e 如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数： int n = -536870912; int a = n \u003e\u003e 1; // 11110000 00000000 00000000 00000000 = -268435456 int b = n \u003e\u003e 2; // 11111000 00000000 00000000 00000000 = -134217728 int c = n \u003e\u003e 28; // 11111111 11111111 11111111 11111110 = -2 int d = n \u003e\u003e 29; // 11111111 11111111 11111111 11111111 = -1 还有一种无符号的右移运算，使用\u003e\u003e\u003e，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行\u003e\u003e\u003e右移，它会变成正数，原因是最高位的1变成了0 int n = -536870912; int a = n \u003e\u003e\u003e 1; // 01110000 00000000 00000000 00000000 = 1879048192 int b = n \u003e\u003e\u003e 2; // 00111000 00000000 00000000 00000000 = 939524096 int c = n \u003e\u003e\u003e 29; // 00000000 00000000 00000000 00000111 = 7 int d = n \u003e\u003e\u003e 31; // 00000000 00000000 00000000 00000001 = 1 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"位运算 与，或，非，异或 与运算的规则是，必须两个数同时为1，结果才为1： n = 0 \u0026 0; // 0 n = 0 \u0026 1; // 0 n = 1 \u0026 0; // 0 n = 1 \u0026 1; // 1 或运算的规则是，只要任意一个为1，结果就为1： n = 0 | 0; // 0 n = 0 | 1; // 1 n = 1 | 0; // 1 n = 1 | 1; // 1 非运算的规则是，0和1互换： n = ~0; // 1 n = ~1; // 0 异或运算的规则是，如果两个数不同，结果为1，否则为0： n = 0 ^ 0; // 0 n = 0 ^ 1; // 1 n = 1 ^ 0; // 1 n = 1 ^ 1; // 0 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"类型的自动提升和强制转型 在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int： public class Main { public static void main(String[] args) { short s = 1234; int i = 123456; int x = s + i; // s自动转型为int short y = s + i; // 编译错误! } } 也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short： int i = 12345; short s = (short) i; // 12345 要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:4:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"浮点数运算 浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。 在计算机中，浮点数虽然表示的范围大，但是，浮点数有个非常重要的特点，就是浮点数常常无法精确表示。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:5:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"类型提升 如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:5:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"溢出 整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值： NaN表示Not a Number Infinity表示无穷大 -Infinity表示负无穷大 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:5:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"类型强转 可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如： int n1=(int) 12.3//12 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:5:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"布尔运算 对于布尔类型boolean，永远只有true和false两个值。 布尔运算是一种关系运算，包括以下几类： 比较运算符：\u003e，\u003e=，\u003c，\u003c=，==，!= 与运算 \u0026\u0026 或运算 || 非运算 ! boolean b=5\u003e3//true int age =12; boolean isTeenager = age\u003e6 \u0026\u0026 age\u003c12 //注意isTeenager是布尔类型，等号右边（age\u003e6 \u0026\u0026 age\u003c12）成立时，isTeenager=true,如果不成立isTeenager=false ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:6:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"短路运算 布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。 因为false \u0026\u0026 x的结果总是false，无论x是true还是false，因此，与运算在确定第一个值为false后，不再继续计算，而是直接返回false。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:6:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"三元运算符 b?x:y，根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。 注意到三元运算b ? x : y会首先计算b，如果b为true，则只计算x，否则，只计算y。此外，x和y的类型必须相同，因为返回值不是boolean，而是x和y之一。 public class Main{ public static void main(String[] args){ int n=-100; int x=n\u003e=0?n:-n; System.out.println(x);//100 } } 上述语句的意思是，判断n \u003e= 0是否成立，如果为true，则返回n，否则返回-n。这实际上是一个求绝对值的表达式。 练习： public class Main{ public static void main(String[] args){ int age =7; boolean isTeenager = age\u003e=6 \u0026\u0026 age\u003c=12; System.out.println(isTeenager ? \"yes\" : \"no\"); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:6:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符和字符串 在Java中，字符和字符串是两个不同的类型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符 字符类型char是基本数据类型，它是character的缩写。一个char保存一个Unicode字符。 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符串 和char类型不同，字符串类型String是引用类型，我们用双引号\"...\"表示字符串。一个字符串可以存储0个到任意个字符。 因为字符串使用双引号\"...\"表示开始和结束，那如果字符串本身恰好包含一个\"字符怎么表示？例如，\"abc\"xyz\"，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符\\： String s =\"abc\\\"xyz\";//包含7个字符: a, b, c, \", x, y, z 常见的转义字符包括： \\\" 表示字符\" \\' 表示字符' \\\\ 表示字符\\ \\n 表示换行符 \\r 表示回车符 \\t 表示Tab \\u#### 表示一个Unicode编码的字符 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符串的连接 Java的编译器对字符串做了特殊照顾，可以使用+连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如： public class Main{ public static void main(String[] args){ String s1=\"Hello\"; String s2=\"World\"; String s=s1+\" \"+s2+\"!\"; System.out.println(s); } } 如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接： public class Main { public static void main(String[] args) { int age = 25; String s = \"age is \" + age; System.out.println(s); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"不可变特性 public class Main { public static void main(String[] args) { String s = \"hello\"; System.out.println(s); // 显示 hello s = \"world\"; System.out.println(s); // 显示 world } } 观察执行结果，难道字符串s变了吗？其实变的不是字符串，而是变量s的“指向”。 执行String s = \"hello\";时，JVM虚拟机先创建字符串\"hello\"，然后，把字符串变量s指向它： s │ ▼ ┌───┬───────────┬───┐ │ │ \"hello\" │ │ └───┴───────────┴───┘ 紧接着，执行s = \"world\";时，JVM虚拟机先创建字符串\"world\"，然后，把字符串变量s指向它： s ──────────────┐ │ ▼ ┌───┬───────────┬───┬───────────┬───┐ │ │ \"hello\" │ │ \"world\" │ │ └───┴───────────┴───┴───────────┴───┘ 原来的字符串\"hello\"还在，只是我们无法通过变量s访问它而已。因此，字符串的不可变是指字符串内容不可变。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"空值null 引用类型的变量可以指向一个空值null，表示不存在，即不指向任何对象。 String s1=null;// s1是null String s2;// 没有赋初值值，s2也是null String s3=s1;// s3也是null String s4=\"\";// s4指向空字符串，不是null 练习： 请将一组int值视为字符的Unicode编码，然后将它们拼成一个字符串： public class Main{ public static void main(String[] args){ int a=72; int b=105; int c=65281; a1=(char)a;//类型强转为字符 b1=(char)b; c1=(char)c; String s=\"\"+a1+b1+c1;//为什么要加“” ？ 由于a1,b1,c1是字符，而s为字符串，\"\" + (char)a +(char)b +(char)c 首先执行空字符串与 (char)a 的加运算，右操作数会被转换成字符串类型。后续操作同理，最后计算结果也是 String 类型，才可以赋值给 String 类型的 s。 System.out.println(s); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:7:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"数组类型 可以使用数组来表示“一组”int类型。代码如下： public class Main{ public static void main(String[] args){ int[] ns = new int [5]; ns[0]=1; ns[1]=2; ns[2]=3; ns[3]=4; ns[4]=5; System.out.println(ns[0]);//1 } } 定义一个数组类型的变量，使用数组类型“类型[]”，例如，int[]。和单个基本类型变量不同，数组变量初始化必须使用new int[5]表示创建一个可容纳5个int元素的数组。 Java的数组有几个特点： 数组所有元素初始化为默认值，整型都是0，浮点型是0.0，布尔型是false； 数组一旦创建后，大小就不可改变。 要访问数组中的某一个元素，需要使用索引。数组索引从0开始，例如，5个元素的数组，索引范围是0~4。 可以修改数组中的某一个元素，使用赋值语句，例如，ns[1] = 79;。 可以用数组变量.length获取数组大小： public class Main{ public static void main(String[] args){ int[] ns = new int [5]; ns[0]=1; ns[1]=2; ns[2]=3; ns[3]=4; ns[4]=5; System.out.println(ns[0]);//1 System.out.println(ns.length);//5 } } 也可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如： public class Main{ public static void main(String[] args){ int[] ns = new int[] {1,2,3,4,5}; //还可以简化为： int[] ns = {1,2,3,4,5}; } } 注意数组是引用类型，并且数组大小不可变。我们观察下面的代码： public class Main { public static void main(String[] args) { // 5位同学的成绩: int[] ns; ns = new int[] { 68, 79, 91, 85, 62 }; System.out.println(ns.length); // 5 ns = new int[] { 1, 2, 3 }; System.out.println(ns.length); // 3 } } 数组大小变了吗？看上去好像是变了，但其实根本没变。 对于数组ns来说，执行ns = new int[] { 68, 79, 91, 85, 62 };时，它指向一个5个元素的数组： ns │ ▼ ┌───┬───┬───┬───┬───┬───┬───┐ │ │68 │79 │91 │85 │62 │ │ └───┴───┴───┴───┴───┴───┴───┘ 执行ns = new int[] { 1, 2, 3 };时，它指向一个新的3个元素的数组： ns ──────────────────────┐ │ ▼ ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ │68 │79 │91 │85 │62 │ │ 1 │ 2 │ 3 │ │ └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 但是，原有的5个元素的数组并没有改变，只是无法通过变量ns引用到它们而已。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:8:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符串数组 如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？ 字符串是引用类型，因此我们先定义一个字符串数组： String[] names = {\"ABC\", \"XYZ\",\"zoo\"}; 对于String[]类型的数组变量names，它实际上包含3个元素，但每个元素都指向某个字符串对象： ┌─────────────────────────┐ names │ ┌─────────────────────┼───────────┐ │ │ │ │ │ ▼ │ │ ▼ ▼ ┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐ │ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │ └───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 对names[1]进行赋值，例如names[1] = \"cat\";，效果如下： ┌─────────────────────────────────────────────────┐ names │ ┌─────────────────────────────────┐ │ │ │ │ │ │ ▼ │ │ ▼ ▼ ┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐ │ │░░░│░░░│░░░│ │ \"ABC\" │ │ \"XYZ\" │ │ \"zoo\" │ │ \"cat\" │ │ └───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘ │ ▲ └─────────────────┘ 这里注意到原来names[1]指向的字符串\"XYZ\"并没有改变，仅仅是将names[1]的引用从指向\"XYZ\"改成了指向\"cat\"，其结果是字符串\"XYZ\"再也无法通过names[1]访问到了。 流程控制 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:8:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"输入和输出 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:9:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"输出 在前面的代码中，我们总是使用System.out.println()来向屏幕输出一些内容。 println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()： public class Main{ public static void main(String[] args){ System.out.print(\"A,\"); System.out.print(\"B,\"); } } \u003e\u003eA,B, ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:9:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"格式化输出 如果要把数据显示成我们期望的格式，就需要使用格式化输出的功能。格式化输出使用System.out.printf()，通过使用占位符%，printf()可以把后面的参数格式化成指定格式： public class Main{ public static void main(String[] args){ double d= 3.1415926; System.out.printf(\"%.2f\\n\",d); } } 占位符 说明 %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 注意，由于%表示占位符，因此，连续两个%%表示一个%字符本身。 占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位： public class Main { public static void main(String[] args) { int n = 12345000; System.out.printf(\"n=%d, hex=%08x\", n, n); // 注意，两个%占位符必须传入两个数 } } \u003e\u003en=12345000, hex=00bc5ea8 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:9:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"输入 import java.util.Scanner; public class hello { public static void main(String[] args) { Scanner scanner = new Scanner((System.in));//创建Scanner对象 System.out.printf(\"input your name:\");//打印提示 String name = scanner.nextLine();//读取一行输入并获取字符串 System.out.printf(\"%s\", name);//格式化输出 } } 首先，我们通过import语句导入java.util.Scanner，import是导入某个类的语句，必须放到Java源代码的开头，后面我们在Java的package中会详细讲解如何使用import。 然后，创建Scanner对象并传入System.in。System.out代表标准输出流，而System.in代表标准输入流。直接使用System.in读取用户输入虽然是可以的，但需要更复杂的代码，而通过Scanner就可以简化后续的代码。 有了Scanner对象后，要读取用户输入的字符串，使用scanner.nextLine()，要读取用户输入的整数，使用scanner.nextInt()。Scanner会自动转换数据类型，因此不必手动转换。 练习： 请帮小明同学设计一个程序，输入上次考试成绩（int）和本次考试成绩（int），然后输出成绩提高的百分比，保留两位小数位（例如，21.75%）。 import java.util.Scanner; public class hello { public static void main(String[] args) { Scanner scanner = new Scanner((System.in)); System.out.print(\"input your last score:\"); int last_score = scanner.nextInt(); System.out.print(\"input your now score:\"); int now_score = scanner.nextInt(); float per=((float)now_score-(float)last_score)/(float)last_score; System.out.printf(\"%.2f%%\", per*100); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:9:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"if判断 前面讲过了浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用==判断不靠谱,正确的方法是利用差值小于某个临界值来判断： public class Main{ public static void main(String[] args){ double x=1-9.0/10; if (Math.abs(x-0.1)\u003c0.00001){ System.out.println(\"x is 0.1\"); } else{ System.out.println(\"x is not 0.1\"); } } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:10:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"判断引用类型相等 要判断引用类型的变量内容是否相等，必须使用equals()方法： public class Main{ public static void main(String[] args){ String s1=\"hello\"; String s2=\"HELLO\".toLowerCase(); if (s1.equals(s2)){ System.out.println(\"s1 equals s2\"); } else{ System.out.println(\"s1 not equals s2\"); } } } 注意：执行语句s1.equals(s2)时，如果变量s1为null，会报NullPointerException，要避免NullPointerException错误，可以利用短路运算： public class Main{ public static void main(String[] args){ String s1=\"hello\"; String s2=\"HELLO\".toLowerCase(); if (s1!=null \u0026\u0026 s1.equals(s2)){ System.out.println(\"s1 equals s2\"); } else{ System.out.println(\"s1 not equals s2\"); } } } 练习： 请用if ... else编写一个程序，用于计算体质指数BMI，并打印结果。 BMI = 体重(kg)除以身高(m)的平方 BMI结果： 过轻：低于18.5 正常：18.5-25 过重：25-28 肥胖：28-32 非常肥胖：高于32 import java.util.Scanner; public class hello { public static void main(String[] args) { Scanner scanner = new Scanner((System.in)); System.out.print(\"input your weight(kg)：\"); float w = scanner.nextFloat(); System.out.print(\"input your height(m):\"); float h = scanner.nextFloat(); float BMI = w / (h * h); if (BMI \u003c 18.5) { System.out.printf(\"过轻,%.3f\", BMI); } else if (18.5 \u003c= BMI \u0026\u0026 BMI \u003c 25) { System.out.printf(\"正常,%.3f\", BMI); } else if (25 \u003c= BMI \u0026\u0026 BMI \u003c 28) { System.out.printf(\"过重,%.3f\", BMI); } else if (28 \u003c= BMI \u0026\u0026 BMI \u003c 32) { System.out.printf(\"肥胖,%.3f\", BMI); } else { System.out.printf(\"非常肥胖,%.3f\", BMI); } } } JAVA中\u0026\u0026和\u0026、||和|（短路与和逻辑与、短路或和逻辑或）的区别？ 首先名称是不同的 ＆＆逻辑与　｜｜逻辑或　它们都是逻辑运算符 ＆　按位与　｜　按位或　它们都是位运算符 ｉｆ（ａ＝＝１＆＆ｂ＝＝２）　这是说既要满足ａ＝１也要满足ｂ＝２ ｉｆ（ａ＝＝１｜｜ｂ＝＝２）　这是说或者满足ａ＝１或者要满足ｂ＝２ 而ａ＆ｂ或者ａ｜ｂ则是二进制的与或运算 ＆同为１时为１，否则为０ ｜同为０时为０，否则为１ ＆＆逻辑与　也叫做短路与　因为只要当前项为假，它就不往后判断了，直接认为表达式为假 ｜｜逻辑或　也叫做短路或　因为只要当前项为真，它也不往后判断了，直接认为表达式为真 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:10:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"switch多重选择 import java.util.Scanner; public class hello{ public static void main(String[] args){ // int option=1; Scanner scanner =new Scanner((System.in)); System.out.print(\"input option:\"); int option=scanner.nextInt(); switch (option){ case 1: System.out.println(\"it is 1\"); break; case 2: System.out.println(\"it is 2\"); break; default: System.out.println(\"None\"); break; } } } 使用switch时，如果遗漏了break，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，switch语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要break语句： public class Main { public static void main(String[] args) { String fruit = \"apple\"; switch (fruit) { case \"apple\" -\u003e System.out.println(\"Selected apple\"); case \"pear\" -\u003e System.out.println(\"Selected pear\"); case \"mango\" -\u003e { System.out.println(\"Selected mango\"); System.out.println(\"Good choice!\"); } default -\u003e System.out.println(\"No fruit selected\"); } } } 注意新语法使用-\u003e，如果有多条语句，需要用{}括起来。不要写break语句，因为新语法只会执行匹配的语句，没有穿透效应。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:11:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"yield 大多数时候，在switch表达式内部，我们会返回简单的值。 但是，如果需要复杂的语句，我们也可以写很多语句，放到{...}里，然后，用yield返回一个值作为switch语句的返回值： public class Main{ public static void main(String[] args){ String fruit=\"orange\"; int opt=switch(fruit){ case \"apple\"-\u003e1; case \"bear\"-\u003e2; default -\u003e{ int code=fruit.hashCode(); yield code;// switch语句返回值 } }; System.out.println(\"opt=\"+opt); } } 练习： 使用switch实现一个简单的石头、剪子、布游戏。 import java.util.Scanner; public class hello { public static void main(String[] args) { Scanner scanner = new Scanner((System.in)); System.out.print(\"please input:Scissors or rock or cloth:\"); // System.out.print(\"please input:\"); String geature = scanner.nextLine(); // String fruit=\"orange\"; // a=Math.random(); int opt = switch (geature) { case \"Scissors\" -\u003e 1; case \"rock\" -\u003e 2; case \"cloth\" -\u003e 3; default -\u003e 0; }; if (opt == 0) { System.out.println(\"error input!\"); } else { System.out.println(\"your choice is:\" + geature); int random_num = (int) (1 + Math.random() * 3);//Math.random()返回大于等于0小于1的随机数，double型 switch (random_num) { case 1 -\u003e System.out.println(\"random_geature is Scissors\"); case 2 -\u003e System.out.println(\"random_geature is rock\"); case 3 -\u003e System.out.println(\"random_geature is cloth\"); default -\u003e System.out.println(\"error random_geature\"); } int score = opt - random_num; System.out.printf(\"score is :%d\\n\", score); switch (score) { case 0 -\u003e System.out.println(\"Tie\"); case -1, 2 -\u003e System.out.println(\"loss\");//当有多个条件满足时 case 1, -2 -\u003e System.out.println(\"win\"); default -\u003e System.out.println(\"error\"); } } } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:11:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"while循环 练习： 使用while计算从m到n的和： public class Main { public static void main(String[] args) { int sum = 0; int m = 20; int n = 100; // 使用while计算M+...+N: while (m\u003c=n) { sum=sum+m; m++; } System.out.println(sum); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:12:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"do while 循环 在Java中，while循环是先判断循环条件，再执行循环。而另一种do while循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是： do { 执行循环语句 } while (条件表达式); 可见，do while循环会至少循环一次。 练习： 使用do while循环计算从m到n的和。 public class Main{ public static void main(String[] args){ int sum=0; int m=20; int n=100; do{ sum=sum+m; m++; }while(m\u003c=n); System.out.println(sum); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:13:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"for 循环 for循环的功能非常强大，它使用计数器实现循环。for循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为i。 for (初始条件; 循环检测条件; 循环后更新计数器) { // 执行语句 } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:14:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"for each循环 for循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素： int [] ns={1,2,3,4,5}; for(int i=0;i\u003cns.length;i++){ System.out.println(ns[i]); } 但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种for each循环，它可以更简单地遍历数组： public class Main{ public static void main(String[] args){ int [] ns={1,2,3,4,5}; for(int n:ns){ System.out.println(n); } } } 和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。for each循环的写法也更简洁。但是，for each循环无法指定遍历顺序，也无法获取数组的索引。 除了数组外，for each循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的List、Map等。 练习1： 给定一个数组，请用for循环倒序输出每一个元素： public class Main{ public static void main(String[] args){ int [] ns={1,2,3,4,5}; int length=ns.length-1; //System.out.println(length); for (int i=length;i\u003e=0;i--){ System.out.println(ns[i]); } } } 练习2： 利用for each循环对数组每个元素求和： public class Main{ public static void main(String[] args){ int[] ns={1,2,3,4,5}; int sum=0; for(int n:ns){ sum=sum+n; } System.out.println(sum); } } 练习3： 圆周率π可以使用公式计算： $\\frac{\\pi}{4}=1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+\\frac{1}{9}-…$ 请利用for循环计算π： public class hello { public static void main(String[] args) { double pi=0; int n=1; double q=0; double w=0; for(int i=0;i\u003c1000000;i++){ q=Math.pow(-1,i); // System.out.println(q); w=(double)1/n; // System.out.println(w); pi=pi+q*w; n+=2; } System.out.println(4*pi); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:14:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"break 和continue ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:15:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"break 在循环过程中，可以使用break语句跳出当前循环。 break语句通常都是配合if语句使用。要特别注意，break语句总是跳出自己所在的那一层循环。例如： public class Main { public static void main(String[] args) { for (int i=1; i\u003c=10; i++) { System.out.println(\"i = \" + i); for (int j=1; j\u003c=10; j++) { System.out.println(\"j = \" + j); if (j \u003e= i) { break; } } // break跳到这里 System.out.println(\"breaked\"); } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:15:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"continue break会跳出当前循环，也就是整个循环都不会执行了。而continue则是提前结束本次循环，直接继续执行下次循环。 public class Main{ public static void main(String[] args){ int sum=0; for (int i=1;i\u003c=10;i++){ System.out.println(\"begin i=\"+i); if(i%2==0){ continue; } System.out.println(\"end i=\"+i); } } } 数组操作 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:15:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"遍历数组 通过for循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的for循环可以完成一个数组的遍历： public class Main{ public static void main(String[] args){ int[] ns={1,2,3,4,5}; for(int i=0;i\u003cns.length;i++){ int n=ns[i]; System.out.println(n); } } } 第二种方式是使用for each循环，直接迭代数组的每个元素： public class Main{ public static void main(String[] args){ int[] ns={1,2,3,4,5}; for(int n:ns){ System.out.println(n); } } } 注意：在for (int n : ns)循环中，变量n直接拿到ns数组的元素，而不是索引。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:16:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"打印数组内容 使用for each循环打印也很麻烦。幸好Java标准库提供了Arrays.toString()，可以快速打印数组内容： import java.util.Arrays; public class Main{ public static void main(String[] args){ int[] ns={1,2,3,4,5}; System.out.println(Arrays.toString(ns)); } } 练习： 请按倒序遍历数组并打印每个元素： public class Main{ public static void main(String[] args){ int [] ns={1,2,3,4,5}; int length=ns.length-1; //System.out.println(length); for (int i=length;i\u003e=0;i--){ System.out.println(ns[i]); } } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:16:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"数组排序 对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。 我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序： import java.util.Arrays; public class hello { public static void main(String[] args) { int[] ns = {28, 12, 89, 73, 65, 18, 96, 50, 8, 36};//有10个数字，要进行10-1=9趟排序，每i趟要进行10-i次排序 // 排序前: System.out.println(Arrays.toString(ns)); System.out.println(ns.length); for (int i = 0; i \u003c ns.length - 1; i++) {//控制共9趟排序(0~8)，i表示第i趟 System.out.println(i); for (int j = 0; j \u003c ns.length - 1 - i; j++) {//控制每i趟进行10-i次比较， /* * i=0表示第1趟，要进行9次排序，j=0~8; * i=1表示第2趟，要进行8次排序，j=0~7; * ... * i=8表示第9趟，要进行1次排序，j=0; * */ if (ns[j] \u003e ns[j + 1]) { // 交换ns[j]和ns[j+1]: int tmp = ns[j]; ns[j] = ns[j + 1]; ns[j + 1] = tmp; } } } // 排序后: System.out.println(Arrays.toString(ns)); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:17:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"冒泡算法： 参考 0.如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。 1.原理：比较两个相邻的元素，将值大的元素交换到右边 2.思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。 　(1)第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。 　(2)比较第2和第3个数，将小数 放在前面，大数放在后面。 　…… 　(3)如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成 　(4)在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。 　(5)在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。 　(6)依次类推，每一趟比较次数减少依次 4.算法分析： 　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数 　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。 实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的Arrays.sort()就可以排序： import java.util.Arrays; public class Main{ public static void main(String[] args){ int[] ns={1,2,,3,4,5}; Arrays.sort(ns); System.out.println(Arrays.toString(ns));//toString():打印数组内容 } } 练习： 请思考如何实现对数组进行降序排序： import java.util.Arrays; public class Main{ public static void main(String[] args){ int[] ns={1,2,3,4,5,6,7,8}; System.out.print(Array.toString(ns)); for(int i=0;i\u003cns.length-1;i++){ for (int j=0;j\u003cns.length-1-i;j++){ if(ns[j]\u003cns[j+1]){ int tmp=int ns[j]; ns[j+1]=ns[j]; ns[j]=ns[j+1]; ns[j+1]=tmp; } } } System.out.println(Arrays.toString(ns)); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:17:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多维数组 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:18:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"二维数组 二维数组就是数组的数组。定义一个二维数组如下： public class Main{ public static void main(String[] args){ int[][] ns={ {1,2,3,4}; {5,6,7,8}; {9,10,11,12}; } System.out.println(ns.length);//3 } } 因为ns包含3个数组，因此，ns.length为3。实际上ns在内存中的结构如下： ┌───┬───┬───┬───┐ ┌───┐ ┌──\u003e│ 1 │ 2 │ 3 │ 4 │ ns ─────\u003e│░░░│──┘ └───┴───┴───┴───┘ ├───┤ ┌───┬───┬───┬───┐ │░░░│─────\u003e│ 5 │ 6 │ 7 │ 8 │ ├───┤ └───┴───┴───┴───┘ │░░░│──┐ ┌───┬───┬───┬───┐ └───┘ └──\u003e│ 9 │10 │11 │12 │ └───┴───┴───┴───┘ 访问二维数组的某个元素需要使用array[row][col]，例如： System.out.println(ns[1][2]);//7 要打印一个二维数组，可以使用两层嵌套的for循环,或者使用Java标准库的Arrays.deepToString()： import java.util.Arrays; public class Main { public static void main(String[] args) { int[][] ns = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }; System.out.println(Arrays.deepToString(ns)); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:18:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"三维数组 int[][][]={ { {1,2,3}, {4,5,6}, {7,8,9} }, { {10,11}, {12,13} }, { {14,15,16}, {17,18} } } 它在内存中的结构如下： ┌───┬───┬───┐ ┌───┐ ┌──\u003e│ 1 │ 2 │ 3 │ ┌──\u003e│░░░│──┘ └───┴───┴───┘ │ ├───┤ ┌───┬───┬───┐ │ │░░░│─────\u003e│ 4 │ 5 │ 6 │ │ ├───┤ └───┴───┴───┘ │ │░░░│──┐ ┌───┬───┬───┐ ┌───┐ │ └───┘ └──\u003e│ 7 │ 8 │ 9 │ ns ────\u003e│░░░│──┘ └───┴───┴───┘ ├───┤ ┌───┐ ┌───┬───┐ │░░░│─────\u003e│░░░│─────\u003e│10 │11 │ ├───┤ ├───┤ └───┴───┘ │░░░│──┐ │░░░│──┐ ┌───┬───┐ └───┘ │ └───┘ └──\u003e│12 │13 │ │ └───┴───┘ │ ┌───┐ ┌───┬───┬───┐ └──\u003e│░░░│─────\u003e│14 │15 │16 │ ├───┤ └───┴───┴───┘ │░░░│──┐ ┌───┬───┐ └───┘ └──\u003e│17 │18 │ └───┴───┘ 如果我们要访问三维数组的某个元素，例如，ns[2][0][1]，只需要顺着定位找到对应的最终元素15即可。 练习： 使用二维数组可以表示一组学生的各科成绩，请计算所有学生的平均分： public class hello{ public static void main(String[] args){ int[][] scores = { { 82, 90, 91 }, { 68, 72, 64 }, { 95, 91, 89 }, { 67, 52, 60 }, { 79, 81, 85 }, }; double average=0; // System.out.println(scores[0].length); int num= scores[0].length; for(int i=0;i\u003cscores.length;i++){ for(int j=0;j\u003cnum;j++){ average+=scores[i][j]; } } average=average/15; System.out.println(average); if (Math.abs(average-77.733333)\u003c0.000001){ System.out.println(\"测试成功\"); } else{ System.out.println(\"测试失败\"); } } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:18:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"命令行参数 Java程序的入口是main方法，而main方法可以接受一个命令行参数，它是一个String[]数组。 这个命令行参数由JVM接收用户输入并传给main方法： public class Main { public static void main(String[] args) { for (String arg : args) { System.out.println(arg); } } } 面向对象编程 面向对象的基本概念，包括： 类 实例 方法 面向对象的实现方式，包括： 继承 多态 Java语言本身提供的机制，包括： package classpath jar 以及Java标准库提供的核心类，包括： 字符串 包装类型 JavaBean 枚举 常用工具类 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:19:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"面向对象基础 class和instance 所以，只要理解了class和instance的概念，基本上就明白了什么是面向对象编程。 class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型： 而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同： 定义class 在Java中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person { public String name; public int age; } 一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。 public是用来修饰字段的，它表示这个字段可以被外部访问。 创建实例 构造对象 指定初始状态 对对象应用方法 使用new构造一个对象 定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。 new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例： Person ming = new Person(); 上述代码创建了一个Person类型的实例，并通过变量ming指向它。 注意区分Person ming是定义Person类型的变量ming，而new Person()是创建Person实例 ming 表示对象变量，类型是Person，注意对象变量并没有实际包含一个对象，而仅仅引用一个对象 new Person() 构造了一个Person()类型的对象，并且它的值是对新创建对象的引用，这个引用储存在ming中。 可以将java对象变量理解为C++中的对象指针。 有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用变量.字段，例如： ming.name = \"Xiao Ming\"; // 对字段name赋值 ming.age = 12; // 对字段age赋值 System.out.println(ming.name); // 访问字段name Person hong = new Person(); hong.name = \"Xiao Hong\"; hong.age = 15; 上述两个变量分别指向两个不同的实例，它们在内存中的结构如下： ┌──────────────────┐ ming ──────\u003e│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ └──────────────────┘ ┌──────────────────┐ hong ──────\u003e│Person instance │ ├──────────────────┤ │name = \"Xiao Hong\"│ │age = 15 │ └──────────────────┘ 两个instance拥有class定义的name和age字段，且各自都有一份独立的数据，互不干扰。 练习： 请定义一个City类，该class具有如下字段: name: 名称，String类型 latitude: 纬度，double类型 longitude: 经度，double类型 class City{ public String name; public double latitude; public double longitude; } public class Main{ public static void main(String[] args){ City beijing=new City(); beijing.name=\"beijing\"; beijing.latitude=39.903; beijing.longitude=116.401; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"方法 一个class可以包含多个field，例如，我们给Person类就定义了两个field： class Person { public String name; public int age; } 但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写： Person ming = new Person(); ming.name = \"Xiao Ming\"; ming.age = -99; // age设置为负数 显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问： class Person { private String name; private int age; } 把field从public改成private，外部代码不能访问这些field，那我们定义这些field有什么用？怎么才能给它赋值？怎么才能读取它的值？ 所以我们需要使用方法（method）来让外部代码可以间接修改field： public class Main{ public static void main(String[] args){ Person ming=new Person; ming.setname(\"xiaoming\"); ming.setAge(12); } } class Person{ private String name; private int age; public getname(){//读方法getter return this.name; } public void setname(String name){//写方法setter this name=name; } public getage(){ return this.age; } public void setAge(int age){ this age=age; } } 定义方法 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return。 private方法 有public方法，自然就有private方法。和private字段一样，private方法不允许外部调用，那我们定义private方法有什么用？ 定义private方法的理由是内部方法是可以调用private方法的。例如： public class Main{ public static void main(String[] args){ Person ming=new Penson(); ming.setBirth(2008); System.out.println(ming.getAge()); } } class Person{ private String name; private int birth; public void setBirth(int birth){ this.birth=birth; } public int getAge(){ return calcAge(2019);//调用private方法 } //private方法 private int calcAge(int currentYear){ return currentYear-this.birth; } } 观察上述代码，calcAge()是一个private方法，外部代码无法调用，但是，内部方法getAge()可以调用它。 此外，我们还注意到，这个Person类只定义了birth字段，没有定义age字段，获取age时，通过方法getAge()返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心Person实例在内部到底有没有age字段。 this变量 this的两个用途： 引用隐式参数 调用该类的其他构造方法 this 表示当前实例filed 在方法内部，可以使用一个隐含的变量this，它始终指向当前实例。因此，通过this.field就可以访问当前实例的field。 如果没有命名冲突，可以省略this。例如： class Person { private String name; public String getName() { return name; // 相当于this.name } } 但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上this： class Person { private String name; public void setName(String name) { this.name = name; // 前面的this不可少，少了就变成局部变量name了 } } 方法参数 方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如： class Person { ... public void setNameAndAge(String name, int age) { ... } } 调用这个setNameAndAge()方法时，必须有两个参数，且第一个参数必须为String，第二个参数必须为int： Person ming = new Person(); ming.setNameAndAge(\"Xiao Ming\"); // 编译错误：参数个数不对 ming.setNameAndAge(12, \"Xiao Ming\"); // 编译错误：参数类型不对 ming.setNameAndAge(\"Xiao Ming\",12);//正确 可变参数 可变参数用类型...定义，可变参数相当于数组类型： class Group { private String[] names; public void setNames(String... names) { this.names = names; } } 上面的setNames()就定义了一个可变参数。调用时，可以这么写： Group g = new Group(); g.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String g.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个String g.setNames(\"Xiao Ming\"); // 传入1个String g.setNames(); // 传入0个String 参数绑定 调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。 那什么是参数绑定？ 我们先观察一个基本类型参数的传递： public class Main { public static void main(String[] args) { Person p = new Person(); int n = 15; // n的值为15 p.setAge(n); // 传入n的值 System.out.println(p.getAge()); // 15 n = 20; // n的值改为20 System.out.println(p.getAge()); // 15 } } class Person { private int age; public int getAge() { return this.age; } public void setAge(int age) { this.age = age; } } 修改外部的局部变量n，不影响实例p的age字段，原因是setAge()方法获得的参数，复制了n的值，因此，p.age和局部变量n互不影响。 结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。（注意字符是基本类型，字符串是引用类型） public class Main { public static void main(String[] args) { Person p = new Person(); String[] fullname ={ \"Homer\", \"Simpson\" }; p.setName(fullname); // 传入fullname数组//传入的是数组的指向 System.out.println(p.getName()); // \"Homer Simpson\" fullname[0] = \"Bart\"; // fullname数组的第一个元素修改为\"Bart\" System.out.println(p.getName()); // \"Bart Simpson\" } } class Person { private String[] name; public String getName() { return this.name[0] + \" \" + this.name[1]; } public void setName(String[] name) { this.name = name; } } 注意到setName()的参数现在是一个数组。一开始，把fullname数组传进去，然后，修改fullname数组的内容，结果发现，实例p的字段p.name也被修改了！ 结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"构造方法 构造方法与类同名 每个类可以有一个以上的构造方法 构造方法可以有0个，1个或多个参数 构造器没有返回值 构造器总是伴随new操作一起调用 能否在创建对象实例时就把内部字段全部初始化为合适的值？ 完全可以。 这时，我们就需要构造方法。 创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建Person实例的时候，一次性传入name和age，完成初始化： public class hello{ public static void main(String[] args){ Person p=new Person(\"xiaoming\",16);//在创建实例时，直接完成初始化 System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person{ private String name; private int age; public Person(String name,int age){//构造方法 this.name=name; this.age=age; } public String getName(){ return this.name; } public int getAge(){ return this.age; } } 由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有void），调用构造方法，必须用new操作符。 默认构造方法 是不是任何class都有构造方法？是的。 那前面我们并没有为Person类编写构造方法，为什么可以调用new Person()？ 原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样： class Person { public Person() { } } 要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就不再自动创建默认构造方法. 在Java中，创建对象实例的时候，按照如下顺序进行初始化： 先初始化字段，例如，int age = 10;表示字段初始化为10，double salary;表示字段默认初始化为0，String name;表示引用类型字段默认初始化为null； 执行构造方法的代码进行初始化。 多构造方法 可以定义多个构造方法，在通过new操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分： class Person{ private String name; private int age; public Person(String name,int age){ this.name=name; this.age=age; } public Person(String name){ this.name=name; } public Person(){ } } 如果调用new Person(\"Xiao Ming\", 20);，会自动匹配到构造方法public Person(String, int)。 如果调用new Person(\"Xiao Ming\");，会自动匹配到构造方法public Person(String)。 如果调用new Person();，会自动匹配到构造方法public Person()。 一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)： class Person{ private String name; private int age; public Person(String name;int age){ this.name=name; this.age=age; } public Person(String name){ this(name,16);//调用另一个构造方法Person(String,int) } public Person(){ this(\"unnamed\");//调用另一个构造方法Person(String) } } 练习： 请给Person类增加(String, int)的构造方法： public class Main{ public static void main(String[] args){ Person p=new Person(\"xiaoming\",16); System.out.println(p.getName()); System.out.println(p.getAge()); } } class Person{ private String name; private int age; public Person(String name,int age){ this.name=name; this.age=age; } public getName(){ return this.name; } public getAge(){ return this.age; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"方法重载 在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。例如，在Hello类中，定义多个hello()方法： class Hello { public void hello() { System.out.println(\"Hello, world!\"); } public void hello(String name) { System.out.println(\"Hello, \" + name + \"!\"); } public void hello(String name, int age) { if (age \u003c 18) { System.out.println(\"Hi, \" + name + \"!\"); } else { System.out.println(\"Hello, \" + name + \"!\"); } } } 这种方法名相同，但各自的参数不同，称为方法重载（Overload）。 练习： public class hello{ public static void main(String[] args){ Person ming=new Person(); Person hong=new Person(); ming.setName(\"ming\"); hong.setname(\"xiao\",\"hong\"); System.out.println(ming.getName()); System.out.println(hong.getName()); } } class Person{ private String name; private String name1; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public void setname(String name,String name1){//方法重载 this.name=name+\" \"+name1; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"继承 一个子类只能够继承唯一一个父类 继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让Student从Person继承时，Student就获得了Person的所有功能，我们只需要为Student编写新增的功能。 Java使用extends关键字来实现继承： class Person { private String name; private int age; public String getName() {...} public void setName(String name) {...} public int getAge() {...} public void setAge(int age) {...} } class Student extends Person { // 不要重复name和age字段/方法, // 只需要定义新增score字段/方法: private int score; public int getScore() { … } public void setScore(int score) { … } } 可见，通过继承，Student只需要编写额外的功能，不再需要重复代码。 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！ 继承树 注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ │ ┌───────────┐ │ Student │ └───────────┘ Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。 类似的，如果我们定义一个继承自Person的Teacher，它们的继承树关系如下： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Person │ └───────────┘ ▲ ▲ │ │ │ │ ┌───────────┐ ┌───────────┐ │ Student │ │ Teacher │ └───────────┘ └───────────┘ protected 继承有个特点，就是子类无法访问父类的private字段或者private方法。例如，Student类就无法访问Person类的name和age字段： class Person { private String name; private int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // 编译错误：无法访问name字段 } } 这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把private改为protected。用protected修饰的字段可以被子类访问： class Person { protected String name; protected int age; } class Student extends Person { public String hello() { return \"Hello, \" + name; // OK! } } 因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。 super super的两个用途： 调用父类的方法 调用父类的构造方法（必须放在子类构造方法的第一条语句） super关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。例如： class Student extends Person { public String hello() { return \"Hello, \" + super.name; } } 实际上，这里使用super.name，或者this.name，或者name，效果都是一样的。编译器会自动定位到父类的name字段。 但是，在某些时候，就必须使用super。我们来看一个例子： public class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 12, 89); } } class Person { protected String name; protected int age; public Person(String name, int age) { this.name = name; this.age = age; } } class Student extends Person { protected int score; public Student(String name, int age, int score) {//构造方法 this.score = score; } } 运行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。 这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(); // 自动调用父类的构造方法 this.score = score; } } 但是，Person类并没有无参数的构造方法，因此，编译失败。 解决方法是调用Person类存在的某个构造方法。例如： class Student extends Person { protected int score; public Student(String name, int age, int score) { super(name, age); // 调用父类的构造方法Person(String, int) this.score = score; } } 这样就可以正常编译了！ 因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。 这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。 向上转型 父类变量可以引用父量对象，也可以引用任意一个子类对象 子类类型转换为父类类型 因为子类的功能比父类多，所以向上转型是可以的。 如果一个引用变量的类型是Student，那么它可以指向一个Student类型的实例： Student s = new Student(); 如果一个引用类型的变量是Person，那么它可以指向一个Person类型的实例： Person p = new Person(); 现在问题来了：如果Student是从Person继承下来的，那么，一个引用类型为Person的变量，能否指向Student类型的实例？ Person p = new Student(); // ??? 测试一下就可以发现，这种指向是允许的！ 这是因为Student继承自Person，因此，它拥有Person的全部功能。Person类型的变量，如果指向Student类型的实例，对它进行操作，是没有问题的！ 这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。 向上转型实际上是把一个子类型安全地变为更加抽象的父类型： Student s = new Student(); Person p = s; // upcasting, ok Object o1 = p; // upcasting, ok Object o2 = s; // upcasting, ok 注意到继承树是Student \u003e Person \u003e Object，所以，可以把Student类型转型为Person，或者更高层次的Object。 向下转型 父类类型转换为子类类型 Person p1 = new Student(); // upcasting, ok Person p2 = new Person(); Student s1 = (Student) p1; // ok Student s2 = (Student) p2; // runtime error! ClassCastException! 如果测试上面的代码，可以发现： Person类型p1实际指向Student实例，Person类型变量p2实际指向Person实例。在向下转型的时候，把p1转型为Student会成功，因为p1确实指向Student实例，把p2转型为Student会失败，因为p2的实际类型是Person，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。 因此，","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多态 多态实现的三种充要条件： 继承 重写（覆写）父类方法 父类引用指向子类对象 在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。 例如，在Person类中，我们定义了run()方法： class Person { public void run() { System.out.println(\"Person.run\"); } } 在子类Student中，覆写这个run()方法： class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); } } 如果方法签名相同，并且返回值也相同，就是Override。 加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。 现在，我们考虑一种情况，如果子类覆写了父类的方法： // override public class Main { public static void main(String[] args) { Person p = new Student(); p.run(); // 应该打印Student.run } } class Person { public void run() { System.out.println(\"Person.run\"); } } class Student extends Person { @Override public void run() { System.out.println(\"Student.run\"); } } Student.run 那么，一个实际类型为Student，引用类型为Person的变量，调用其run()方法，调用的是Person还是Student的run()方法？ 运行一下上面的代码就可以知道，实际上调用的方法是Student的run()方法。因此可得出结论： Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。 这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。 多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如： Person p = new Student(); p.run(); // 调用Student run()方法 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？ 我们还是来举栗子。 假设我们定义一种收入，需要给它报税，那么先定义一个Income类： class Income{ protected double income; public double getTax(){ return income*0.1; } } 对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()： class Salay extends Income{ @override public double getTax(){ if (income\u003c=5000){ return 0; } return (income-5000)*0.2; } } 如果你享受国务院特殊津贴，那么按照规定，可以全部免税： class StateCouncilSpecialAllowance extends Income { @Override public double getTax() { return 0; } } 现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写： public double totalTax(Income... incomes) { double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } 来试一下： public class Main { public static void main(String[] args) { // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税: Income[] incomes = new Income[] { new Income(3000), new Salary(7500), new StateCouncilSpecialAllowance(15000) }; System.out.println(totalTax(incomes)); } public static double totalTax(Income... incomes) {//该方法传入的参数是可变参数 double total = 0; for (Income income: incomes) { total = total + income.getTax(); } return total; } } class Income { protected double income; public Income(double income) { this.income = income; } public double getTax() { return income * 0.1; // 税率10% } } class Salary extends Income { public Salary(double income) { super(income); } @Override public double getTax() { if (income \u003c= 5000) { return 0; } return (income - 5000) * 0.2; } } class StateCouncilSpecialAllowance extends Income { public StateCouncilSpecialAllowance(double income) { super(income); } @Override public double getTax() { return 0; } } 观察totalTax()方法：利用多态，totalTax()方法只需要和Income打交道，它完全不需要知道Salary和StateCouncilSpecialAllowance的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从Income派生，然后正确覆写getTax()方法就可以。把新的类型传入totalTax()，不需要修改任何代码。 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。 覆写Object方法 因为所有的class最终都继承自Object，而Object定义了几个重要的方法： toString()：把instance输出为String； equals()：判断两个instance是否逻辑相等； hashCode()：计算一个instance的哈希值。 在必要的情况下，我们可以覆写Object的这几个方法。例如： class Person { ... // 显示更有意义的字符串: @Override public String toString() { return \"Person:name=\" + name; } // 比较是否相等: @Override public boolean equals(Object o) { // 当且仅当o为Person类型: if (o instanceof Person) { Person p = (Person) o; // 并且name字段相同时，返回true: return this.name.equals(p.name); } return false; } // 计算hash: @Override public int hashCode() { return this.name.hashCode(); } } 调用super super的两个用途： 调用父类的方法 调用父类的构造方法（必须放在子类构造方法的第一条语句） 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过super来调用。例如： class Person { protected String name; public String hello() { return \"Hello, \" + name; } } Student extends Person { @Override public String hello() { // 调用父类的hello()方法: return super.hello() + \"!\"; } } final 用final修饰的字段在初始化后不能被修改 用final修饰的方法在初始化后不能被覆写 用final修饰的类在初始化后不能被继承 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override： class Person { protected String name; public final String hello() { return \"Hello,","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"抽象类 如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法： 什么是方法签名： 完整的描述一个方法需要指出方法名以及参数类型，这叫做方法的签名。返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回类型不同的方法。 class Person { public abstract void run(); } 把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，Person类也无法被实例化。编译器会告诉我们，无法编译Person类，因为它包含抽象方法。 必须把Person类本身也声明为abstract，才能正确编译它： abstract class Person { public abstract void run(); } 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类： Person p = new Person(); // 编译错误 无法实例化的抽象类有什么用？ 因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。 例如，Person类定义了抽象方法run()，那么，在实现子类Student的时候，就必须覆写run()方法： package demo; public class hello{ public static void main(String[] args){ Person p=new Student(); p.run(); } } abstract class Person{//抽象类 public abstract void run();//抽象方法 } class Student extends Person{ @Override public void run() { System.out.println(\"Student run\"); } } 面向抽象编程 当我们定义了抽象类Person，以及具体的Student、Teacher子类的时候，我们可以通过抽象类Person类型去引用具体的子类的实例： Person s = new Student(); Person t = new Teacher(); 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型： // 不关心Person变量的具体子类型: s.run(); t.run(); 同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型： // 同样不关心新的子类是如何实现run()方法的： Person e = new Employee(); e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。 面向抽象编程的本质就是： 上层代码只定义规范（例如：abstract class Person）； 不需要子类就可以实现业务逻辑（正常编译）； 具体的业务逻辑由不同的子类实现，调用者并不关心。 package demo; abstract class Person{ private String name; private int age; public Person(String name,int age){ this.name=name; this.age=age; } public abstract String getDescription(); } class Student extends Person{ public Student(String name,int age){ super(name,age); } @Override public String getDescription() { return String.format(\"an student\"); } } public class Main{ public static void main(String[] args){ Person s=new Student(\"xiaoming\",18); System.out.println(s.getDescription()); } } 练习： 用抽象类给一个有工资收入和稿费收入的小伙伴算税。 package demo; public class hello{ public static void main(String[] args){ Income[] incomes=new Income[]{ // new Income(3000), new Salay(7500), new State(1000) }; System.out.println(totalTex(incomes)); } public static double totalTex(Income...incomes){ double total=0; for (Income income:incomes){ total=total+ income.getTax(); } return total; } } abstract class Income{ protected double income; public Income(double income){ this.income=income;//初始化收入 } public abstract double getTax();//子类必须实现的规范 } class Salay extends Income{ public Salay(double income){ super(income);//必须显示调用父类的构造方法 } @Override public double getTax() { if (income\u003c5000){ return 0; } return (income-5000)*0.2; } } class State extends Income{ public State(double income){ super(income); } @Override public double getTax() { return this.income*0.1; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:6","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"接口 一个类可以实现一个或多个接口 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式定义。 在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。 如果一个抽象类没有字段，所有方法全部都是抽象方法： abstract class Person { public abstract void run(); public abstract String getName(); } 就可以把该抽象类改写为接口：interface。 在Java中，使用interface可以声明一个接口： interface Person { void run(); String getName(); } 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。 当一个具体的class去实现一个interface时，需要使用implements关键字。举个例子： 在接口声明中，所有方法都自动为public，不过在实现接口时，必须把方法声明为public。 package demo; interface Person{ void run(); String getName(); } class Student implements Person{ private String name; public Student(String name){ this.name=name; } @Override public void run() { System.out.println(\"Student sun\"); } @Override public String getName() { return name; } } public class hello{ public static void main(String[] args){ Student s=new Student(\"XIAOHONG\"); s.run(); } } 我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface，例如： class Student implements Person, Hello { // 实现了两个interface ... } 术语 注意区分术语： Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。 抽象类和接口的对比如下： abstract class interface 继承 只能extends一个class 可以implements多个interface 字段 可以定义实例字段 不能定义实例字段 抽象方法 可以定义抽象方法 可以定义抽象方法 非抽象方法 可以定义非抽象方法 可以定义default方法 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:7","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":" 接口继承 一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。例如： interface Hello { void hello(); } interface Person extends Hello { void run(); String getName(); } 此时，Person接口继承自Hello接口，因此，Person接口现在实际上有3个抽象方法签名，其中一个来自继承的Hello接口。 继承关系 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系： ┌───────────────┐ │ Iterable │ └───────────────┘ ▲ ┌───────────────────┐ │ │ Object │ ┌───────────────┐ └───────────────────┘ │ Collection │ ▲ └───────────────┘ │ ▲ ▲ ┌───────────────────┐ │ └──────────│AbstractCollection │ ┌───────────────┐ └───────────────────┘ │ List │ ▲ └───────────────┘ │ ▲ ┌───────────────────┐ └──────────│ AbstractList │ └───────────────────┘ ▲ ▲ │ │ │ │ ┌────────────┐ ┌────────────┐ │ ArrayList │ │ LinkedList │ └────────────┘ └────────────┘ 在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象： List list = new ArrayList(); // 用List接口引用具体子类的实例 Collection coll = list; // 向上转型为Collection接口 Iterable it = coll; // 向上转型为Iterable接口 default方法 在接口中，可以定义default方法。例如，把Person接口的run()方法改为default方法： public class Main { public static void main(String[] args) { Person p = new Student(\"Xiao Ming\"); p.run(); } } interface Person { String getName(); default void run() { System.out.println(getName() + \" run\"); } } class Student implements Person { private String name; public Student(String name) { this.name = name; } public String getName() { return this.name; } } //Xiao Ming run **实现类可以不必覆写default方法。**default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。 default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。 package demo; public class hello{ public static void main(String[] args){ System.out.println(totalTex()); } public static double totalTex(){ Salay s =new Salay(7500); State s1=new State(10000); return s.getTex()+ s1.getTex(); } } interface Income{//定义接口 double getTex();//子类必须实现的规范 } class Salay implements Income{ private double income; public Salay(double income){ this.income=income; } @Override public double getTex() { if (income\u003c5000){ return 0; } return (income-5000)*0.2; } } class State implements Income{ private double income; public State(double income){ this.income=income; } @Override public double getTex() { return this.income*0.1; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:8","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"静态字段和静态方法 class Employee{ private static int nextId=1;//静态域 private int id;//实例域 } 每一个雇员对象都有一个自己的id域，但是这个类的所有实例将共享一个nextId域。换句话说，如果有1000个Employee类的对象，则有1000个实例域id。但是，只有一个静态域nextId。即使没有一个Employee类的对象，静态域nextId也存在，它属于类，而不属于任何独立的对象。 在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。 还有一种字段，是用static修饰的字段，称为静态字段：static field。 实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。举个例子： class Person{ public String name; public int age; public static int number;//定义静态字段 } 我们来看看下面的代码： public class Main { public static void main(String[] args) { Person ming = new Person(\"Xiao Ming\", 12); Person hong = new Person(\"Xiao Hong\", 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); } } class Person { public String name; public int age; public static int number; public Person(String name, int age) { this.name = name; this.age = age; } } //88 //99 对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例： ming ──\u003e│Person instance │ ├──────────────────┤ │name = \"Xiao Ming\"│ │age = 12 │ │number ───────────┼──┐ ┌─────────────┐ └──────────────────┘ │ │Person class │ │ ├─────────────┤ ├───\u003e│number = 99 │ ┌──────────────────┐ │ └─────────────┘ hong ──\u003e│Person instance │ │ ├──────────────────┤ │ │name = \"Xiao Hong\"│ │ │age = 15 │ │ │number ───────────┼──┘ └──────────────────┘ 虽然实例可以访问静态字段，但是它们指向的其实都是Person class的静态字段。所以，所有实例共享一个静态字段。 因此，不推荐用实例变量.静态字段去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。 推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。对于上面的代码，更好的写法是： Person.number = 99; System.out.println(Person.number); 静态方法 静态方法通过类名调用，静态方法只能访问静态字段 有静态字段，就有静态方法。用static修饰的方法称为静态方法。 调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。例如： public class Main{ public static void main(String[] args){ Person.setNumber(99);//通过类名调用 System.out.println(Person.number);//通过类名.静态字段来调用 } } class Person{ public static int number; public static void setNumber(int value){ number=value; } } 因为静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。 通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。 通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。 静态方法经常用于工具类。例如： Arrays.sort() Math.random() 静态方法也经常用于辅助方法。注意到Java程序的入口main()也是静态方法。 接口的静态字段 因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型： public interface Person { public static final int MALE = 1; public static final int FEMALE = 2; } 实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为： public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2; } 编译器会自动把该字段变为public static final类型。 练习： 给Person类增加一个静态字段count和静态方法getCount，统计实例创建的个数。 package demo; public class hello{ public static void main(String[] args){ Person s1=new Person(); Person s2=new Person(); Person s3=new Person(); System.out.println(Person.getCount()); } } class Person{ public static int count=0; public Person(){//每创建一个实例，count加1 Person.count++; } public static int getCount(){ return Person.count; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:9","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"包 在前面的代码中，我们把类和接口命名为Person、Student、Hello等简单名字。 在现实中，如果小明写了一个Person类，小红也写了一个Person类，现在，小白既想用小明的Person，也想用小红的Person，怎么办？ 如果小军写了一个Arrays类，恰好JDK也自带了一个Arrays类，如何解决类名冲突？ 在Java中，我们使用package来解决名字冲突。 Java定义了一种名字空间，称之为包：package。一个类总是属于某个包，类名（比如Person）只是一个简写，真正的完整类名是包名.类名。 例如： 小明的Person类存放在包ming下面，因此，完整类名是ming.Person； 小红的Person类存放在包hong下面，因此，完整类名是hong.Person； 小军的Arrays类存放在包mr.jun下面，因此，完整类名是mr.jun.Arrays； JDK的Arrays类存放在包java.util下面，因此，完整类名是java.util.Arrays。 在定义class的时候，我们需要在第一行声明这个class属于哪个包。 小明的Person.java文件： package ming; // 申明包名ming public class Person { } 在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。 包可以是多层结构，用.隔开。例如：java.util。 没有定义包名的class，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。 我们还需要按照包结构把上面的Java文件组织起来。假设以package_sample作为根目录，src作为源码目录，那么所有文件结构就是： package_sample └─ src ├─ hong //包名 │ └─ Person.java //类名 │ ming //包名 │ └─ Person.java └─ mr //包名 └─ jun └─ Arrays.java 即所有Java文件对应的目录层次要和包的层次一致。 编译后的.class文件也需要按照包结构存放。如果使用IDE，把编译后的.class文件放到bin目录下，那么，编译的文件结构就是： package_sample └─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 包作用域 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域。例如，Person类定义在hello包下面： package hello; public class Person{ //包作用域 void hello(){//不用`public`、`protected`、`private`修饰 System.out.println(\"Hello\"); } } import 在一个class中，我们总会引用其他的class。例如，小明的ming.Person类，如果要引用小军的mr.jun.Arrays类，他有三种写法： 第一种，直接写出完整类名，例如： package ming; public class Person{ public void run(){ mr.jun.Arrays=new mr.jun.Arrays(); } } 很显然，每次写完整类名比较痛苦。 因此，第二种写法是用import语句，导入小军的Arrays，然后写简单类名： package ming; import mr.jun.Arrays; public class Person{ public void run(){ Arrays arrays= new Arrays(); } } 在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）： // Person.java package ming; // 导入mr.jun包的所有class: import mr.jun.*; public class Person { public void run() { Arrays arrays = new Arrays(); } } 我们一般不推荐这种写法，因为在导入了多个包后，很难看出Arrays类属于哪个包。 还有一种import static的语法，它可以导入可以导入一个类的静态字段和静态方法： package main; // 导入System类的所有静态字段和静态方法: import static java.lang.System.*; public class Main { public static void main(String[] args) { // 相当于调用System.out.println(…) out.println(\"Hello, world!\"); } } import static很少使用。 ava编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时： 如果是完整类名，就直接根据完整类名查找这个class； 如果是简单类名，按下面的顺序依次查找： 查找当前package是否存在这个class； 查找import的包是否包含这个class； 查找java.lang包是否包含这个class。 如果按照上面的规则还无法确定类名，则编译报错。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:10","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"作用域 在Java中，我们经常看到public、protected、private这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。 public 定义为public的class、interface可以被其他任何类访问： package abc; public class Hello { public void hi() { } } 上面的Hello是public，因此，可以被其他包的类访问： package xyz; class Main { void foo() { // Main可以访问Hello Hello h = new Hello(); } } 定义为public的field、method可以被其他类访问，前提是首先有访问class的权限： package abc; public class Hello { public void hi() { } } 上面的hi()方法是public，可以被其他类调用，前提是首先要能访问Hello类： package xyz; class Main { void foo() { Hello h = new Hello(); h.hi(); } } private 定义为private的field、method无法被其他类访问： package abc; public class Hello { // 不能被其他类调用: private void hi() { } public void hello() { this.hi(); } } 实际上，确切地说，private访问权限被限定在class的内部，而且与方法声明顺序无关。推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法： package abc; public class Hello { public void hello() { this.hi(); } private void hi() { } } 由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限： public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); } // private方法: private static void hello() { System.out.println(\"private hello!\"); } // 静态内部类: static class Inner { public void hi() { Main.hello(); } } } 定义在一个class内部的class称为嵌套类（nested class），Java支持好几种嵌套类。 protected protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类： package abc; public class Hello { // protected方法: protected void hi() { } } 上面的protected方法可以被继承的类访问： package xyz; class Main extends Hello { void foo() { Hello h = new Hello(); // 可以访问protected方法: h.hi(); } } package 最后，包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。 package abc; // package权限的类: class Hello { // package权限的方法: void hi() { } } 只要在同一个包，就可以访问package权限的class、field和method： package abc; class Main { void foo() { // 可以访问package权限的类: Hello h = new Hello(); // 可以调用package权限的方法: h.hi(); } } 注意，包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。 局部变量 在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。 package abc; public class Hello { void hi(String name) { // ① String s = name.toLowerCase(); // ② int len = s.length(); // ③ if (len \u003c 10) { // ④ int p = 10 - len; // ⑤ for (int i=0; i\u003c10; i++) { // ⑥ System.out.println(); // ⑦ } // ⑧ } // ⑨ } // ⑩ } 我们观察上面的hi()方法代码： 方法参数name是局部变量，它的作用域是整个方法，即①～⑩； 变量s的作用域是定义处到方法结束，即②～⑩； 变量len的作用域是定义处到方法结束，即③～⑩； 变量p的作用域是定义处到if块结束，即⑤～⑨； 变量i的作用域是for循环，即⑥～⑧。 使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。 final Java还提供了一个final修饰符。final与访问权限不冲突，它有很多作用。 用final 修饰class 可以阻止被继承 public final class Hello{ ... } 用final修饰method可以阻止被子类覆写： public class Hello{ protected final void hello(){ ... } } 用final修饰field可以阻止被重新赋值： public class Hello{ protected final int n=0; } 用final修饰局部变量可以阻止被重新赋值： public class Hello{ protected void hello(final int t){ t=1;//error! } } 最佳实践 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法。 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:11","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"classpath 和 jar classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。 因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。 所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用\"\"括起来，可能长这样： C:\\work\\project1\\bin;C:\\shared;\"D:\\My Documents\\project1\\bin\" 在Linux系统上，用:分隔，可能长这样： /usr/shared:/usr/local/bin:/home/liaoxuefeng/bin … 不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。 jar包 如果有很多.class文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。 jar包就是用来干这个事的，它可以把package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。 jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中： java -cp ./hello.jar abc.xyz.Hello 这样JVM会自动在hello.jar文件里去搜索某个类。 那么问题来了：如何创建jar包？ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从.zip改为.jar，一个jar包就创建成功。 假设编译输出的目录结构是这样： package_sample └─ bin ├─ hong │ └─ Person.class │ ming │ └─ Person.class └─ mr └─ jun └─ Arrays.class 这里需要特别注意的是，jar包里的第一层目录，不能是bin，而应该是hong、ming、mr。如果在Windows的资源管理器中看，应该长这样： 如果长这样： 说明打包打得有问题，JVM仍然无法从jar包中查找正确的class，原因是hong.Person必须按hong/Person.class存放，而不是bin/hong/Person.class。 jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令： java -jar hello.jar jar包还可以包含其它jar包，这个时候，就需要在MANIFEST.MF文件里配置classpath了。 在大型项目中，不可能手动编写MANIFEST.MF文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如Maven，可以非常方便地创建jar包。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:12","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"模块 从Java 9开始，JDK又引入了模块（Module）。 什么是模块？这要从Java 9之前的版本说起。 我们知道，.class文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆.class文件，很不便于管理，所以，jar文件就是class文件的容器。 在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M。 如果是自己开发的程序，除了一个自己的app.jar以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样： java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main 如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出ClassNotFoundException。 所以，jar只是用于存放class的容器，它并不关心class之间的依赖。 从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块。 为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的rt.jar分拆成了几十个模块，这些模块以.jmod扩展名标识，可以在$JAVA_HOME/jmods目录下找到它们： java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod … 这些.jmod文件每一个都是一个模块，模块名就是文件名。例如：模块java.base对应的文件就是java.base.jmod。模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从Object直接或间接继承而来。 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。 编写模块 那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以oop-module工程为例，它的目录结构如下： oop-module ├── bin ├── build.sh └── src ├── com │ └── itranswarp │ └── sample │ ├── Greeting.java │ └── Main.java └── module-info.java 其中，bin目录存放编译后的class文件，src目录存放源码，按包名的目录结构存放，仅仅在src目录下多了一个module-info.java这个文件，这就是模块的描述文件。在这个模块中，它长这样： module hello.world { requires java.base; // 可不写，任何模块都会自动引入java.base requires java.xml; } 其中，module是关键字，后面的hello.world是模块的名称，它的命名规范与包一致。花括号的requires xxx;表示这个模块需要引用的其他模块名。除了java.base可以被自动引入外，这里我们引入了一个java.xml的模块。 当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，Main.java代码如下 package com.itranswarp.sample; // 必须引入java.xml模块后才能使用其中的类: import javax.xml.XMLConstants; public class Main { public static void main(String[] args) { Greeting g = new Greeting(); System.out.println(g.hello(XMLConstants.XML_NS_PREFIX)); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:20:13","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"java核心类 字符串 StringBuilder StringJoiner 包装类型 JavaBean 枚举 常用工具类 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"字符串和编码 String 在Java中，String是一个引用类型，它本身也是一个class。但是，Java编译器对String有特殊处理，即可以直接用\"...\"来表示一个字符串： String s1 = \"Hello!\"; 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的： String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'}); 因为String太常用了，所以Java提供了\"...\"这种字符串字面量表示方法。 Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。 public class Main{ public static class main(String[] args){ String s= \"Hello\"; System.out.println(s); s=s.toUpperCase(); System.out.println(s); } } 字符串比较 当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用equals()方法而不能用==。 public class Main{ public static class main(String[] args){ String s1=\"Helllo\"; String s2=\"Hello\"; System.out.println(s1==s2); System.out.println(s1.equals(s2)); } } //true //true 从表面上看，两个字符串用==和equals()比较都为true，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然s1和s2的引用就是相同的。 所以，这种==比较返回true纯属巧合。换一种写法，==比较就会失败： public class Main{ public static class main(String[] args){ String s1=\"Hello\"; String s2=\"Hello\"; System.out.println(s1==s2); System.out.println(s1.equals(s2)); } } //false //true 结论：两个字符串比较，必须总是使用equals()方法。 要忽略大小写比较，使用equalsIgnoreCase()方法。 String类还提供了多种方法来搜索子串、提取子串。常用的方法有： //是否包含字串 \"Hello\".contains(\"ll\"); //true 注意到contains()方法的参数是CharSequence而不是String，因为CharSequence是String的父类。 搜索子串的更多的例子： \"Hello\".indexof(\"l\");//2 \"Hello\".lastIndex(\"l\");//3 \"Hello\".startWith(\"He\");//true \"Hello\".endWith(\"lo\");//true 提取字串的例子; \"Hello\".substring(2);//\"llo\" \"Hello\".substring(2,4);//\"ll\"-\u003e[2,4)-\u003e取第二第三个元素 去除首尾空白字符 使用trim() 方法可以移除字符串首尾空白字符。空白字符包括空格，\\t，\\r，\\n： \"\\tHello\\r\\n\".trim();//\"Hello\" 注意：trim()并没有改变字符串的内容，而是返回了一个新字符串。 另一个strip()方法也可以移除字符串首尾空白字符。它和trim()不同的是，类似中文的空格字符\\u3000也会被移除： \"\\u3000Hello\\u3000\".strip(); // \"Hello\" \" Hello \".stripLeading(); // \"Hello \" \" Hello \".stripTrailing(); // \" Hello\" String还提供了isEmpty()和isBlank()来判断字符串是否为空和空白字符串： \"\".isEmpty(); // true，因为字符串长度为0 \" \".isEmpty(); // false，因为字符串长度不为0 \" \\n\".isBlank(); // true，因为只包含空白字符 \" Hello \".isBlank(); // false，因为包含非空白字符 替换字符 要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换： String s=\"Hello\"; s.replace('l','w');//\"Hewwo\"-\u003e所有字符'l'被替换为'w' 另一种是通过正则表达式替换： String s= \"A,,B;C,D\"; s.replaceAll(\"[\\\\,\\\\;\\\\s]+\",\",\");//\"A,B,C,D\" 上面的代码通过正则表达式，把匹配的子串统一替换为\",\"。关于正则表达式的用法我们会在后面详细讲解。 分割字符串 要分割字符串，使用split()方法，并且传入的也是正则表达式： String s=\"A,B,C,D\"; String[] ss=s.split(\"\\\\,\");//{\"A\",\"B\",\"C\",\"D\"} 拼接字符串 拼接字符串使用静态方法join()，它用指定的字符串连接字符串数组： String[] arr={\"A\",\"B\",\"C\",\"D\"}; String s=String.join(\"***\",arr);//\"A***B***C\" 格式化字符串 字符串提供了formatted()方法和format()静态方法，可以传入其他参数，替换占位符，然后生成新的字符串： public class Main{ public static class main(String[] args){ String s=\"Hi %s,your score is %d!\"; System.out.println(s.formatted(\"Alice\",80)); System.out.println(Srtring.format(\"Hi %s,your score is %.2f!\",\"Bob\",95.5)); } } 有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有： %s：显示字符串； %d：显示整数； %x：显示十六进制整数； %f：显示浮点数。 占位符还可以带格式，例如%.2f表示显示两位小数。如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型。 类型转换 要把任意基本类型或引用类型转换为字符串，可以使用静态方法valueOf()。这是一个重载方法，编译器会根据参数自动选择合适的方法 String.valueof(123);//\"123\" String.valueof(true);//\"true\" 要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为int类型： int n1=Integer.parseInt(\"123\");//123 int n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255 字符串转换为boolean类型： boolean b1=Boolean.parseBoolean(\"true\");//true boolean b2=Boolean.parseBoolean(\"false\");//false 转换为char[] String和char[]类型可以互相转换，方法是： char[] cs=\"Hello\".toVharArray();//String-\u003echar[] String s=new String(cs);//char[]-\u003eString 如果修改了char[]数组，String并不会改变： public class Main { public static void main(String[] args) { char[] cs = \"Hello\".toCharArray(); String s = new String(cs); System.out.println(s);//Hello cs[0] = 'X'; System.out.println(s);//Hello } } 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组。 从String的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。 package demo; import java.util.Arrays; public class hello{ public static void main(String[] args) { int[] score={1,2,3,4}; // int[] abc=score.clone(); // System.out.println(Arrays.toString(score)); Score s=new Score(score); score[2]=99; System.out.println(","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"StringBuilder Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。 考察下面的循环代码： String s = \"\"; for (int i = 0; i \u003c 1000; i++) { s = s + \",\" + i; } 虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率 为了能高效拼接字符串，Java标准库提供了StringBuilder，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象： StringBuilder sb=new StringBuilder(1024); for (int i-0;i\u003c1000;i++){ sb.append(','); sb.append(i); } String s=sb.toString(); StringBuilder还可以进行链式操作： public class Main{ public static void main(String[] args){ var sb=new StringBuilder(1024); sb.append(\"Mr\") .append(\"Bob\") .append(\"!\") .insert(0,\"Hello, \"); System.out.println(sb.toString()); } } 练习： 请使用StringBuilder构造一个INSERT语句： package demo; import java.util.Arrays; public class hello { public static void main(String[] args) { String[] fields = {\"name\", \"position\", \"salary\"}; String table = \"employee\"; String insert = buildInsertSql(table, fields); System.out.println(insert); String s = \"INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)\"; System.out.println(s.equals(insert) ? \"测试成功\" : \"测试失败\"); } private static String buildInsertSql(String table, String[] fields) { var bb = new StringBuilder(1024); // bb.append(\"INSERT INTO employee (name, position, salary) VALUES (?, ?, ?)\"); bb.append(\"INSERT INTO \") .append(table) .append(\" (\") // .append(fields[0]) // .append(\", \") // .append(fields[1]) // .append(\", \") // .append(fields[2]) .append(String.join(\", \", fields)) .append(\") \") .append(\"VALUES (?, ?, ?)\"); String s = bb.toString(); return s; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"StringJoiner 用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： package demo; import java.util.StringJoiner; public class hello{ public static void main(String[] args){ String[] names={\"Bob\",\"Alice\",\"Grace\"}; var sj=new StringJoiner(\", \" , \"Hello \",\"!\"); for (String name :names){ sj.add(name); } System.out.println(sj.toString()); } } \u003e\u003eHello Bob, Alice, Grace! String.join() String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便： String[] names = {\"Bob\", \"Alice\", \"Grace\"}; var s = String.join(\", \", names); 练习： 请使用StringJoiner构造一个SELECT语句： package demo; import java.util.StringJoiner; public class hello{ public static void main(String[] args){ String[] fileds={\"name\",\"position\",\"salary\"}; String table=\"employee\"; String select=buildSelect(table,fileds); System.out.println(select); System.out.println(\"SELECT name, position, salary FROM employee\".equals(select) ? \"测试成功\" : \"测试失败\"); } private static String buildSelect(String table, String[] fileds) { var s=new StringJoiner(\", \",\"SELECT \", \" FROM \"+table); for (String name:fileds){ s.add(name); } return s.toString(); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"包装类型 我们已经知道，Java的数据类型分两种： 基本类型：byte，short，int，long，boolean，float，double，char 引用类型：所有class和interface类型 引用类型可以赋值为null，表示空，但基本类型不能赋值为null： String s = null; int n = null; // compile error! 比如，想要把int基本类型变成一个引用类型，我们可以定义一个Integer类，它只包含一个实例字段int，这样，Integer类就可以视为int的包装类（Wrapper Class）： public class Integer{ private int value; public Integer(int value){ this.value=value; } public int intValue(){ return this.value; } } 定义好了Integer类，我们就可以把int和Integer互相转换： Integer n=null; Integer n2=new Integer(99); int n3=n2.intvalue(); 实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型： 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 我们可以直接使用，并不需要自己去定义： public class Main { public static void main(String[] args) { int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(\"100\"); System.out.println(n3.intValue()); } } Auto Boxing 因为int和Integer可以互相转换： int i=100; Integer.valueof(int) int x=n; 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。 装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException： 不变类 所有的包装类型都是不变类。我们查看Integer的源码可知，它的核心代码如下： public final class Integer { private final int value; } 因此，一旦创建了Integer对象，该对象就是不变的。 对两个Integer实例进行比较要特别注意：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较： public class Main{ public static void main(String[] args){ Integer x=127; Integer y=127; Integer m=99999; Integer n=99999; System.out.println(\"x==y:\"+(x==y));//true System.out.println(\"m==n:\"+(x==y));//false System.out.println(\"x==y:\"+(x.equals(y)));//true System.out.println(\"m==n:\"+(m.equals(n)));//true } } 仔细观察结果的童鞋可以发现，==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);，为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer。 因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： 方法1：Integer n = new Integer(100); 方法2：Integer n = Integer.valueOf(100); 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。 我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。 进制转换 Integer类本身还提供了大量方法，例如，最常用的静态方法parseInt()可以把字符串解析成一个整数： int x1=Integer.parseInt(\"100\");//100 int x2=Integer.parseInt(\"100\",16);//256,按16进制解析 Integer还可以把整数格式化为指定进制的字符串： public class Main { public static void main(String[] args) { System.out.println(Integer.toString(100)); // \"100\",表示为10进制 System.out.println(Integer.toString(100, 36)); // \"2s\",表示为36进制 System.out.println(Integer.toHexString(100)); // \"64\",表示为16进制 System.out.println(Integer.toOctalString(100)); // \"144\",表示为8进制 System.out.println(Integer.toBinaryString(100)); // \"1100100\",表示为2进制 } } 注意：上述方法的输出都是String，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。int n = 100在内存中总是以4字节的二进制表示： ┌────────┬────────┬────────┬────────┐ │00000000│00000000│00000000│01100100│ └────────┴────────┴────────┴────────┘ 我们经常使用的System.out.println(n);是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用Integer.toHexString(n)则通过核心库自动把整数格式化为16进制。 这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。 ava的包装类型还定义了一些有用的静态变量 // boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段: Boolean t = Boolean.TRUE; Boolean f = Boolean.FALSE; // int可表示的最大/最小值: int max = Integer.MAX_VALUE; // 2147483647 int min = Integer.MIN_VALUE; // -2147483648 // long类型占用的bit和byte数量: int sizeOfLong = Long.SIZE; // 64 (bits) int bytesOfLong = Long.BYTES; // 8 (bytes) 最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型： // 向上转型为Number: Number num = new Integer(999); // 获取byte, int, long, float, double: byte b = num.byteValue(); int n = num.intValue(); long ln = num.longValue(); float f = num.floatValue(); double d = num.doubleValue(); 处理无符号整型 在Java中，并没有无符号整型（Unsigned）的基本数据类型。byte、short、int和long都是带符号整型，最高位是符号位。而C语言则提供了C","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"JavaBean 在Java中，有很多class的定义都符合这样的规范： 若干private实例字段； 通过public方法来读写实例字段。 例如： public class Person{ private String name; private int age; public String getname(){//读 return this.name; } public int getAge(){//读 return this.age; } public void setAge(int age){//写 this.age=age; } } 如果读写方法符合以下这种命名规范： // 读方法: public Type getXyz()//无参数 // 写方法: public void setXyz(Type value)//有参数 那么这种class被称为JavaBean. 上面的字段是xyz，那么读写方法名分别以get和set开头，并且后接大写字母开头的字段名Xyz，因此两个读写方法名分别是getXyz()和setXyz()。 boolean字段比较特殊，它的读方法一般命名为isXyz()： // 读方法: public boolean isChild() // 写方法: public void setChild(boolean value) 我们通常把一组对应的读方法（getter）和写方法（setter）称为属性（property）。例如，name属性： 对应的读方法是String getName() 对应的写方法是setName(String) 只有getter的属性称为只读属性（read-only），例如，定义一个age只读属性： 对应的读方法是int getAge() 无对应的写方法setAge(int) 类似的，只有setter的属性称为只写属性（write-only）。 很明显，只读属性很常见，只写属性不常见。 属性只需要定义getter和setter方法，不一定需要对应的字段。例如，child只读属性定义如下： public class Person{ private String name; private int age; public String getname(){//读 return this.name; } public int getAge(){//读 return this.age; } public void setAge(int age){//写 this.age=age; } public boolean isChild(){ return age\u003c=6; } } 可以看出，getter和setter也是一种数据封装的方法。 JavaBean的作用 JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 通过IDE，可以快速生成getter和setter。例如，在Eclipse中，先输入以下代码： public class Person { private String name; private int age; } 然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成getter和setter方法的字段，点击确定即可由IDE自动完成所有方法代码。 枚举JavaBean属性 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector： public class Main { public static void main(String[] args) throws Exception { BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(\" \" + pd.getReadMethod()); System.out.println(\" \" + pd.getWriteMethod()); } } } class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"枚举类 在Java中，我们可以通过static final来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的int表示： public class Weekday { public static final int SUN = 0; public static final int MON = 1; public static final int TUE = 2; public static final int WED = 3; public static final int THU = 4; public static final int FRI = 5; public static final int SAT = 6; } 使用常量的时候，可以这么引用： if (day == Weekday.SAT || day == Weekday.SUN) { // TODO: work at home } 也可以把常量定义为字符串类型，例如，定义3种颜色的常量： public class Color { public static final String RED = \"r\"; public static final String GREEN = \"g\"; public static final String BLUE = \"b\"; } 使用常量的时候，可以这么引用： String color = ... if (Color.RED.equals(color)) { // TODO: } 无论是int常量还是String常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如： if (weekday == 6 || weekday == 7) { if (tasks == Weekday.MON) { // TODO: } } 上述代码编译和运行均不会报错，但存在两个问题： 注意到Weekday定义的常量范围是0~6，并不包含7，编译器无法检查不在枚举中的int值； 定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。 enum 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用enum来定义枚举类： package demo; import java.beans.*; public class hello { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(\"work at home\"); } else { System.out.println(\"work at office\"); } } } enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT; } 注意到定义枚举类是通过关键字enum实现的，我们只需依次列出枚举的常量名。 和int定义的常量相比，使用enum定义枚举有如下好处： 首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过： int day = 1; if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '==' } 其次，不可能引用到非枚举的值，因为无法通过编译。 最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值： Weekday x = Weekday.SUN; // ok! Weekday y = Color.RED; // Compile error: incompatible types enum的比较 使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。 这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较： if (day == Weekday.FRI) { // ok! } if (day.equals(Weekday.SUN)) { // ok, but more code! } enum类型 通过enum定义的枚举类，和其他的class有什么区别？ 答案是没有任何区别。enum定义的类型就是class，只不过它有以下几个特点： 定义的enum类型总是继承自java.lang.Enum，且无法被继承； 只能定义出enum的实例，而无法通过new操作符创建enum的实例； 定义的每个实例都是引用类型的唯一实例； 可以将enum类型用于switch语句。 例如，我们定义的Color枚举类： public enum Color { RED, GREEN, BLUE; } 编译器编译出的class大概就像这样： public final class Color extends Enum { // 继承自Enum，标记为final class // 每个实例均为全局唯一: public static final Color RED = new Color(); public static final Color GREEN = new Color(); public static final Color BLUE = new Color(); // private构造方法，确保外部无法调用new操作符: private Color() {} } 所以，编译后的enum类和普通class并没有任何区别。但是我们自己无法按定义普通class那样来定义enum，必须使用enum关键字，这是Java语法规定的。 因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法： name() 返回常量名，例如： String s = Weekday.SUN.name(); // \"SUN\" ordinal() 返回定义的常量的顺序，从0开始计数，例如： int n = Weekday.MON.ordinal(); // 1 改变枚举常量定义的顺序就会导致ordinal()返回值发生变化。例如： public enum Weekday { SUN, MON, TUE, WED, THU, FRI, SAT; } 和 public enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } 的ordinal就是不同的。如果在代码中编写了类似if(x.ordinal()==1)这样的语句，就要保证enum的枚举顺序不能变。新增的常量必须放在最后。 switch 最后，枚举类可以应用在switch语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比int、String类型更适合用在switch语句中： public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(\"Today is \" + day + \". Work at office!\"); break; case SAT: case SUN: System.out.println(\"Today is \" + day + \". Work at home!\"); break; default: throw new RuntimeException(\"cannot process \" + day); } } } enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:6","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"记录类 使用String、Integer等类型的时候，这些类型都是不变类，一个不变类具有以下特点： 定义class时使用final，无法派生子类； 每个字段使用final，保证创建实例后无法修改任何字段。 假设我们希望定义一个Point类，有x、y两个变量，同时它是一个不变类，可以这么写： public final class Point { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } } 为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写equals()和hashCode()，这里演示Point不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。 record 从Java 14开始，引入了新的Record类。我们定义Record类时，使用关键字record。把上述Point类改写为Record类，代码如下： public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); } } public record Point(int x, int y) {} ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:7","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"BigInteger 在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。 如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数： BigInteger bi = new BigInteger(\"1234567890\"); System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000 对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： BigInteger i1 = new BigInteger(\"1234567890\"); BigInteger i2 = new BigInteger(\"12345678901234567890\"); BigInteger sum = i1.add(i2); // 12345678902469135780 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。 也可以把BigInteger转换成long型： BigInteger i = new BigInteger(\"123456789000\"); System.out.println(i.longValue()); // 123456789000 System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range 使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。 BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。 小结 BigInteger用于表示任意大小的整数； BigInteger是不变类，并且继承自Number； 将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:8","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"BigDecimal 和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。 BigDecimal bd = new BigDecimal(\"123.4567\"); System.out.println(bd.multiply(bd)); // 15241.55677489 BigDecimal用scale()表示小数位数，例如： BigDecimal d1 = new BigDecimal(\"123.45\"); BigDecimal d2 = new BigDecimal(\"123.4500\"); BigDecimal d3 = new BigDecimal(\"1234500\"); System.out.println(d1.scale()); // 2,两位小数 System.out.println(d2.scale()); // 4 System.out.println(d3.scale()); // 0 通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal： BigDecimal d1 = new BigDecimal(\"123.4500\"); BigDecimal d2 = d1.stripTrailingZeros(); System.out.println(d1.scale()); // 4 System.out.println(d2.scale()); // 2,因为去掉了00 BigDecimal d3 = new BigDecimal(\"1234500\"); BigDecimal d4 = d3.stripTrailingZeros(); System.out.println(d3.scale()); // 0 System.out.println(d4.scale()); // -2 如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。 可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断： package demo; import java.math.BigDecimal; import java.math.RoundingMode; public class hello{ public static void main(String[] args){ BigDecimal d1=new BigDecimal(\"123.454556\"); BigDecimal d2=d1.setScale(4, RoundingMode.HALF_UP);//四舍五入，123.4546 BigDecimal d3=d1.setScale(4,RoundingMode.DOWN);//直接截断，123.4545 System.out.println(d2); System.out.println(d3); } } 对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断： BigDecimal d1 = new BigDecimal(\"123.456\"); BigDecimal d2 = new BigDecimal(\"23.456789\"); BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入 BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽 还可以对BigDecimal做除法的同时求余数： package demo; import java.math.BigDecimal; import java.math.RoundingMode; public class hello{ public static void main(String[] args){ BigDecimal d1=new BigDecimal(\"12.3\"); BigDecimal d2=new BigDecimal(\"0.12\"); BigDecimal[] dr =d1.divideAndRemainder(d2); System.out.println(dr[0]); System.out.println(dr[1]); } } //public record point(int x,int y){} 调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数： BigDecimal n = new BigDecimal(\"12.75\"); BigDecimal m = new BigDecimal(\"0.15\"); BigDecimal[] dr = n.divideAndRemainder(m); if (dr[1].signum() == 0) { // n是m的整数倍 } 比较BigDecimal 在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等： BigDecimal d1 = new BigDecimal(\"123.456\"); BigDecimal d2 = new BigDecimal(\"123.45600\"); System.out.println(d1.equals(d2)); // false,因为scale不同 System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2 System.out.println(d1.compareTo(d2)); // 0 必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:9","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"常用工具类 Math Math.abs(-11);//11 Math.max(100,10);//100 Math.min(100,10);//10 Main.pow(2,2);//4 Main.sqrt(2);//1.414... Main.exp(2);//7.389 Main.log(4);//以e为底的对数 Main.log10(100);//以10为底的对数 Math.sin(3.14); // 0.00159... Math.cos(3.14); // -0.9999... Math.tan(3.14); // -0.0015... Math.asin(1.0); // 1.57079... Math.acos(1.0); // 0.0 double pi = Math.PI; // 3.14159... double e = Math.E; // 2.7182818... Math.sin(Math.PI / 6); // sin(π/6) = 0.5 生成一个随机数x，x的范围是0 \u003c= x \u003c 1： Math.random(); // 0.53907... 每次都不一样 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下： public class Main{ public static void main(String[] args){ double x=Math.random();//[0,1) double min=10; doublemax=50; double y=x*(max-min)+min;//[10,50) long n=(long)y; System.out.println(y); System.out.println(n); } } Random Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。 要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()： Random r = new Random(); r.nextInt(); // 2071575453,每次都不一样 r.nextInt(10); // 5,生成一个[0,10)之间的int r.nextLong(); // 8811649292570369305,每次都不一样 r.nextFloat(); // 0.54335...生成一个[0,1)之间的float r.nextDouble(); // 0.3716...生成一个[0,1)之间的double 有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。 这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。 如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列： package demo; import java.math.BigDecimal; import java.math.RoundingMode; import java.util.Random; public class hello{ public static void main(String[] args){ Random r=new Random(123456); for (int i=0;i\u003c10;i++){ System.out.println(r.nextInt(100)); } } } 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。 SecureRandom 有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的： SecureRandom sr=new SecureRandom(); System.out.println(sr.nextInt(100)); SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器 异常处理 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:21:10","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"java的异常 在计算机程序运行的过程中，总是会出现各种各样的错误。 有一些错误是用户造成的，比如，希望用户输入一个int类型的年龄，但是用户的输入是abc： // 假设用户输入了abc： String s = \"abc\"; int n = Integer.parseInt(s); // NumberFormatException! 程序想要读写某个文件的内容，但是用户已经把它删除了： // 用户删除了该文件： String t = readFile(\"C:\\\\abc.txt\"); // FileNotFoundException! 还有一些错误是随机出现，并且永远不可能避免的。比如： 网络突然断了，连接不到远程服务器； 内存耗尽，程序崩溃了； 用户点“打印”，但根本没有打印机； …… 所以，一个健壮的程序必须处理各种各样的错误。 所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。 调用方如何获知调用失败的信息？有两种方法： 方法一：约定返回错误码。 例如，处理一个文件，如果返回0，表示成功，返回其他整数，表示约定的错误码： int code = processFile(\"C:\\\\test.txt\"); if (code == 0) { // ok: } else { // error: switch (code) { case 1: // file not found: case 2: // no read permission: default: // unknown error: } } 因为使用int类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。 方法二：在语言层面上提供一个异常处理机制。 Java内置了一套异常处理机制，总是使用异常来表示错误。 异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了： try { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 因为Java的异常是class，它的继承关系如下： ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │ ┌─────────────────┐ ┌─────────────────┐┌───────────┐ │OutOfMemoryError │... │RuntimeException ││IOException│... └─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ 从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如： OutOfMemoryError：内存耗尽 NoClassDefFoundError：无法加载某个Class StackOverflowError：栈溢出 而Exception则是运行时的错误，它可以被捕获并处理。 某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如： NumberFormatException：数值类型的格式错误 FileNotFoundException：未找到文件 SocketException：读取网络失败 Exception又分为两大类： RuntimeException以及它的子类； 非RuntimeException（包括IOException、ReflectiveOperationException等等） Java规定： 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。 注意：编译器对RuntimeException及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析。 派生于Error或RuntimeException类的所有异常称为非受查异常，所有其他的异常受查异常 编译器为受查异常提供了异常处理器 捕获异常 捕获异常使用try...catch语句，把可能发生异常的代码放到try {...}中，然后使用catch捕获对应的Exception及其子类 public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { try { // 用指定编码转换String为byte[]: return s.getBytes(\"GBK\"); } catch (UnsupportedEncodingException e) { // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException: System.out.println(e); // 打印异常信息 return s.getBytes(); // 尝试使用用默认编码 } } } 如果我们不捕获UnsupportedEncodingException，会出现编译失败的问题： public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) { return s.getBytes(\"GBK\"); } } 编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是return s.getBytes(\"GBK\");。意思是说，像UnsupportedEncodingException这样的Checked Exception，必须被捕获。 这是因为String.getBytes(String)方法定义是： public byte[] getBytes(String charsetName) throws UnsupportedEncodingException { ... } 在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。 在toGBK()方法中，因为调用了String.getBytes(String)方法，就必须捕获UnsupportedEncodingException。我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查： public class Main { public static void main(String[] args) { byte[] bs = toGBK(\"中文\"); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { return s.getBytes(\"GBK\"); } } 上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用return s.getBytes(\"GBK\");的问题，而是byte[] bs = toGBK(\"中文\");。因为在main()方法中，调用toGBK()，没有捕获它声明的可能抛出的UnsupportedEnc","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"声明异常 声明受查异常： 方法应该在首部声明(throws)所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类受查异常。（告诉编译器可能发生什么错误） public FileInputStream(String name) throws FileNotFoundException class Person{ ... public Image loadImage(String s) throws IOException{ } } 总之，一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控（Error）,要么应该避免发生。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"捕获异常 在Java中，凡是可能抛出异常的语句，都可以用try ... catch捕获。把可能发生异常的语句放在try { ... }中，然后使用catch捕获对应的Exception及其子类。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多catch语句 可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。 简单地说就是：多个catch语句只有一个能被执行。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(e); } catch (NumberFormatException e) { System.out.println(e); } } 存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。例如： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(\"IO error\"); } catch (UnsupportedEncodingException e) { // 永远捕获不到 System.out.println(\"Bad encoding\"); } } 对于上面的代码，UnsupportedEncodingException异常是永远捕获不到的，因为它是IOException的子类。当抛出UnsupportedEncodingException异常时，会被catch (IOException e) { ... }捕获并执行。 因此，正确的写法是把子类放到前面： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"finally语句 无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？ 可以把执行语句写若干遍：正常执行的放到try中，每个catch再写一遍。例如： public static void main(String[] args) { try { process1(); process2(); process3(); System.out.println(\"END\"); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); System.out.println(\"END\"); } catch (IOException e) { System.out.println(\"IO error\"); System.out.println(\"END\"); } } 上述代码无论是否发生异常，都会执行System.out.println(\"END\");这条语句。 那么如何消除这些重复的代码？Java的try ... catch机制还提供了finally语句，finally语句块保证有无错误都会执行。上述代码可以改写如下： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (UnsupportedEncodingException e) { System.out.println(\"Bad encoding\"); } catch (IOException e) { System.out.println(\"IO error\"); } finally { System.out.println(\"END\"); } } 注意finally有几个特点： finally语句不是必须的，可写可不写； finally总是最后执行。 如果没有发生异常，就正常执行try { ... }语句块，然后执行finally。如果发生了异常，就中断执行try { ... }语句块，然后跳转执行匹配的catch语句块，最后执行finally。 可见，finally是用来保证一些代码必须执行的 某些情况下，可以没有catch，只使用try ... finally结构。例如： void process(String file) throws IOException { try { ... } finally { System.out.println(\"END\"); } } 因为方法声明了可能抛出的异常，所以可以不写catch。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"捕获多种异常 如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条catch子句： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(\"Bad input\"); } catch (NumberFormatException e) { System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); } } 因为处理IOException和NumberFormatException的代码是相同的，所以我们可以把它两用|合并到一起： public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException | NumberFormatException e) { // IOException或NumberFormatException System.out.println(\"Bad input\"); } catch (Exception e) { System.out.println(\"Unknown error\"); } } 练习 package demo; public class hello { public static void main(String[] args) { String a = \"12\"; String b = \"x9\"; try { int c = stringToInt(a); int d = stringToInt(b); System.out.println(c * d); } catch (NumberFormatException q) { System.out.println(q); } // TODO: 捕获异常并处理 } static int stringToInt(String s) { return Integer.parseInt(s); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:22:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"抛出异常 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:23:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"异常的传播 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个try ... catch被捕获为止： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { process2(); } static void process2() { Integer.parseInt(null); // 会抛出NumberFormatException } } 通过printStackTrace()可以打印出方法的调用栈，类似： java.lang.NumberFormatException: null at java.base/java.lang.Integer.parseInt(Integer.java:614) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.process2(Main.java:16) at Main.process1(Main.java:12) at Main.main(Main.java:5) printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，从下往上看，调用层次依次是： main()调用process1()； process1()调用process2()； process2()调用Integer.parseInt(String)； Integer.parseInt(String)调用Integer.parseInt(String, int)。 查看Integer.java源码可知，抛出异常的方法代码如下： public static int parseInt(String s, int radix) throws NumberFormatException { if (s == null) { throw new NumberFormatException(\"null\"); } ... } 并且，每层调用均给出了源代码的行号，可直接定位。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:23:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"抛出异常 当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。 如何抛出异常？参考Integer.parseInt()方法，抛出异常分两步： 创建某个Exception的实例； 用throw语句抛出。 下面是一个例子： void process2(String s) { if (s==null) { NullPointerException e = new NullPointerException(); throw e; } } 实际上，绝大部分抛出异常的代码都会合并写成一行： void process2(String s) { if (s==null) { throw new NullPointerException(); } } 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： void process1(String s) { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } void process2(String s) { if (s==null) { throw new NullPointerException(); } } 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： void process1(String s) { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } void process2(String s) { if (s==null) { throw new NullPointerException(); } } 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈： 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了： void process1(String s) { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(); } } void process2(String s) { if (s==null) { throw new NullPointerException(); } } 当process2()抛出NullPointerException后，被process1()捕获，然后抛出IllegalArgumentException()。 如果在main()中捕获IllegalArgumentException，我们看看打印的异常栈： 打印出的异常栈类似： java.lang.IllegalArgumentException at Main.process1(Main.java:15) at Main.main(Main.java:5) 这说明新的异常丢失了原始异常信息，我们已经看不到原始异常NullPointerException的信息了。 为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去，新的Exception就可以持有原始Exception信息。对上述代码改进如下： public class Main { public static void main(String[] args) { try { process1(); } catch (Exception e) { e.printStackTrace(); } } static void process1() { try { process2(); } catch (NullPointerException e) { throw new IllegalArgumentException(e); } } static void process2() { throw new NullPointerException(); } } 运行上述代码，打印出的异常栈类似： java.lang.IllegalArgumentException: java.lang.NullPointerException at Main.process1(Main.java:15) at Main.main(Main.java:5) Caused by: java.lang.NullPointerException at Main.process2(Main.java:20) at Main.process1(Main.java:13) 注意到Caused by: Xxx，说明捕获的IllegalArgumentException并不是造成问题的根源，根源在于NullPointerException，是在Main.process2()方法抛出的。 在代码中获取原始异常可以使用Throwable.getCause()方法。如果返回null，说明已经是“根异常”了。 有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！ 如果我们在try或者catch语句块中抛出异常，finally语句是否会执行？例如： public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); } } } 上述代码执行结果如下： catched finally Exception in thread \"main\" java.lang.RuntimeException: java.lang.NumberFormatException: For input string: \"abc\" at Main.main(Main.java:8) Caused by: java.lang.NumberFormatException: For input string: \"abc\" at ... 第一行打印了catched，说明进入了catch语句块。第二行打印了finally，说明执行了finally语句块。 因此，在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:23:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"异常屏蔽 如果在执行finally语句时抛出异常，那么，catch语句的异常还能否继续抛出？例如： public class Main { public static void main(String[] args) { try { Integer.parseInt(\"abc\"); } catch (Exception e) { System.out.println(\"catched\"); throw new RuntimeException(e); } finally { System.out.println(\"finally\"); throw new IllegalArgumentException(); } } } 执行上述代码，发现异常信息如下： catched finally Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) 这说明finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。 在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出： public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\"abc\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } } 当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它： Exception in thread \"main\" java.lang.IllegalArgumentException at Main.main(Main.java:11) Suppressed: java.lang.NumberFormatException: For input string: \"abc\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:6) 通过Throwable.getSuppressed()可以获取所有的Suppressed Exception。 绝大多数情况下，在finally中不要抛出异常。因此，我们通常不需要关心Suppressed Exception。 练习 package demo; public class hello { public static void main(String[] args) { try { System.out.println(tax(2000, 0.1));//可能发生异常的语句 // System.out.println(tax(-200, 0.1)); // System.out.println(tax(2000, -0.1)); } catch (Exception e) {//捕获异常 System.out.println(\"error\"); } } static double tax(int salary, double rate) { // TODO: 如果传入的参数为负，则抛出IllegalArgumentException if (salary \u003c 0 || rate \u003c 0) { throw new IllegalArgumentException();//抛出异常 } else { return salary * rate; } } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:23:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"自定义异常 Java标准库定义的常用异常包括： Exception │ ├─ RuntimeException │ │ │ ├─ NullPointerException │ │ │ ├─ IndexOutOfBoundsException │ │ │ ├─ SecurityException │ │ │ └─ IllegalArgumentException │ │ │ └─ NumberFormatException │ ├─ IOException │ │ │ ├─ UnsupportedCharsetException │ │ │ ├─ FileNotFoundException │ │ │ └─ SocketException │ ├─ ParseException │ ├─ GeneralSecurityException │ ├─ SQLException │ └─ TimeoutException 当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出IllegalArgumentException： static void process1(int age) { if (age \u003c= 0) { throw new IllegalArgumentException(); } } 在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： public class BaseException extends RuntimeException { } 其他业务类型的异常就可以从BaseException派生： public class UserNotFoundException extends BaseException { } public class LoginFailedException extends BaseException { } ... 自定义的BaseException应该提供多个构造方法： public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); } } 上述构造方法实际上都是原样照抄RuntimeException。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:24:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"NullPointException 在所有的RuntimeException异常中，Java程序员最熟悉的恐怕就是NullPointerException了。 NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的，例如： public class Main{ public static void main(String[] args){ String s= null; System.out.println(s.toLowerCase()) } } /* Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.toLowerCase()\" because \"\u003clocal1\u003e\" is null at Main.main(Main.java:5) */ 指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地说是Null Reference，不过两者区别不大。 处理NullPointerException 如果遇到NullPointerException，我们应该如何处理？首先，必须明确，NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误： // 错误示例: 捕获NullPointerException try { transferMoney(from, to, amount); } catch (NullPointerException e) { } 好的编码习惯可以极大地降低NullPointerException的产生，例如： 成员变量在定义时初始化： public class Person{ private String name=\"\"; } 使用空字符串\"\"而不是默认的null可避免很多NullPointerException，编写业务逻辑时，用空字符串\"\"表示未填写比null安全得多。 返回空字符串\"\"、空数组而不是null： public String[] readLineFromFile(String file){ if (getFileSize(file)==0){ //返回空数组而不是null return new String[0]; } } 这样可以使得调用方无需检查结果是否为null。 如果调用方一定要根据null判断，比如返回null表示文件不存在，那么考虑返回Optional\u003cT\u003e： public Optional\u003cString\u003e readFromFile(String file){ if(!fileExit(file)){ return Optional.empty(); } ... } 这样调用方必须通过Optional.isPresent()判断是否有结果. 定位NullPointerException 如果产生了NullPointerException，例如，调用a.b.c.x()时产生了NullPointerException，原因可能是： a是null； a.b是null； a.b.c是null； 确定到底是哪个对象是null以前只能打印这样的日志： System.out.println(a); System.out.println(a.b); System.out.println(a.b.c); 从Java 14开始，如果产生了NullPointerException，JVM可以给出详细的信息告诉我们null对象到底是谁。我们来看例子： public class Main{ public static void main(String[] args){ Person p =new Person(); System.out.println(p.address.city.toLowerCase()); } } class Person{ String[] name =new String[2]; Address address= new Address(); } class Address{ String city; String street; String zip; } /* Exception in thread \"main\" java.lang.NullPointerException: Cannot invoke \"String.toLowerCase()\" because \"\u003clocal1\u003e.address.city\" is null at Main.main(Main.java:5) */ 可以在NullPointerException的详细信息中看到类似... because \"\u003clocal1\u003e.address.city\" is null，意思是city字段为null，这样我们就能快速定位问题所在。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:25:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用断言 断言（Assertion）是一种调试程序的方式。在Java中，使用assert关键字来实现断言。 我们先看一个例子： public static void main(String[] args){ double x=Math.abs(-123.45); assert x\u003e=0; System.out.println(x); } 语句assert x \u003e= 0;即为断言，断言条件x \u003e= 0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。 使用assert语句时，还可以添加一个可选的断言消息： assert x \u003e= 0 : \"x must \u003e= 0\"; 这样，断言失败的时候，AssertionError会带上消息x must \u003e= 0，更加便于调试。 Java断言的特点是：断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。 对于可恢复的程序错误，不应该使用断言。例如： void sort(int[] arr) { assert arr != null; } 应该抛出异常并在上层捕获： void sort(int[] arr) { if (x == null) { throw new IllegalArgumentException(\"array cannot be null\"); } } public class Main { public static void main(String[] args) { int x = -1; assert x \u003e 0; System.out.println(x); } } //-1 断言x必须大于0，实际上x为-1，断言肯定失败。执行上述代码，发现程序并未抛出AssertionError，而是正常打印了x的值。 这是怎么肥四？为什么assert语句不起作用？ 这是因为JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。 要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，上述程序必须在命令行下运行才有效果： $ java -ea Main.java Exception in thread \"main\" java.lang.AssertionError at Main.main(Main.java:5) 还可以有选择地对特定地类启用断言，命令行参数是：-ea:com.itranswarp.sample.Main，表示只对com.itranswarp.sample.Main这个类启用断言。 或者对特定地包启用断言，命令行参数是：-ea:com.itranswarp.sample...（注意结尾有3个.），表示对com.itranswarp.sample这个包启动断言。 实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解JUnit的使用。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:26:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用JDK Logging 在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用System.out.println()打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。 代码改好了怎么办？当然是删除没有用的System.out.println()语句了。 如果改代码又改出问题怎么办？再加上System.out.println()。 反复这么搞几次，很快大家就发现使用System.out.println()非常麻烦。 怎么办？ 解决方法是使用日志。 那什么是日志？日志就是Logging，它的目的是为了取代System.out.println()。 输出日志，而不是用System.out.println()，有以下几个好处： 可以设置输出样式，避免自己每次都写\"ERROR: \" + var； 可以设置输出级别，禁止某些级别输出。例如，只输出错误日志； 可以被重定向到文件，这样可以在程序运行结束后查看日志； 可以按包名控制日志级别，只输出某些包打的日志； 可以…… 总之就是好处很多啦。 那如何使用日志？ 因为Java标准库内置了日志包java.util.logging，我们可以直接用。先看一个简单的例子： package demo; import java.util.logging.Logger; public class Main { public static void main(String[] args) { Logger logger =Logger.getGlobal(); logger.info(\"start process...\"); logger.warning(\"memory is running out..\"); logger.fine(\"ignored.\"); logger.severe(\"process will be terminated...\"); } } /* 9月 13, 2020 3:47:33 下午 demo.Main main 信息: start process... 9月 13, 2020 3:47:34 下午 demo.Main main 警告: memory is running out.. 9月 13, 2020 3:47:34 下午 demo.Main main 严重: process will be terminated... */ 对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。 再仔细观察发现，4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通： SEVERE WARNING INFO CONFIG FINE FINER FINEST 因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。 使用Java标准库内置的Logging有以下局限： Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行main()方法，就无法修改配置； 配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=\u003cconfig-file-name\u003e。 因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。 练习： 使用logger.severe()打印异常： package demo; import java.io.UnsupportedEncodingException; import java.util.logging.Logger; public class Main { public static void main(String[] args) { Logger logger =Logger.getLogger(Main.class.getName()); logger.info(\"start process...\"); try{ \"\".getBytes(\"invalidCharsetName\"); }catch (UnsupportedEncodingException e){ logger.severe(\"process will be terminated...\"); e.printStackTrace(); } logger.info(\"process end.\"); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:27:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用Commons Logging 和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。 Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。 使用Commons Logging只需要和两个类打交道，并且只有两步： 第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:28:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用Log4j 前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。 Log4j是一种非常流行的日志框架，最新版本是2.x。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:29:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用SLF4J和Logback 前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。 有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？ 其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。 反射 什么是反射？ 能够分析类能力的程序称为反射。反射机制可以用来： 在运行是分析类的能力 在运行时查看对象 实现通用的数组操作代码 利用Method对象方法 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。 正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例： // Main.java import com.itranswarp.learnjava.Person; public class Main { String getFullName(Person p) { return p.getFirstName() + \" \" + p.getLastName(); } } 但是，如果不能获得Person类，只有一个Object实例，比如这样： String getFullName(Object obj) { return ??? } 怎么办？有童鞋会说：强制转型啊！ String getFullName(Object obj) { Person p = (Person) obj; return p.getFirstName() + \" \" + p.getLastName(); } 强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用Person类。不然，去掉import语句，你看能不能编译通过？ 所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。 Java反射机制主要提供了以下几种功能： 在运行时判断一个对象所属的类 在运行时构造一个类的对象 在运行时判断一个类所有成员变量和方法 在运行时调用对象的方法 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:30:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"Class类 在java程序运行时，每一个对象都有一个类型标识，这个信息跟踪者这个对象所属的类，可以通过专门的java类访问这些信息。保存这些信息的类被称为Class。 一个Class对象将表示一个特定类的属性 Employee e; Class c1= e.getClass(); 除了int等基本类型外，Java的其他类型全部都是class（包括interface）。例如： String Object Runnable Exception … 仔细思考，我们可以得出结论：class（包括interface）的本质是数据类型（Type）。无继承关系的数据类型无法赋值： Number n = new Double(123.456); // OK String s = new Double(123.456); // compile error! 而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:31:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"访问字段 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:32:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"调用方法 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:33:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"调用构造方法 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:34:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"获取继承关系 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:35:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"动态代理 … 注解 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:36:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用注解 注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”: // this is a component: @Resource(\"hello\") public class Hello { @Inject int n; @PostConstruct public void hello(@Param String name) { System.out.println(name); } @Override public String toString() { return \"Hello\"; } } 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:37:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"注解的作用 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。 Java的注解可以分为三类： 第一类是由编译器使用的注解，例如： @Override：让编译器检查该方法是否正确地实现了覆写； @SuppressWarnings：告诉编译器忽略此处代码产生的警告。 这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解） 定义一个注解时，还可以定义配置参数。配置参数可以包括： 所有基本类型； String； 枚举类型； 基本类型、String、Class以及枚举的数组。 因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。 注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。 如果只写注解，相当于全部使用默认值。 public class Hello { @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y; } @Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:37:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"定义注解 Java语言使用@interface语法来定义注解（Annotation），它的格式如下： public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:38:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"元注解 有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。 @Target 最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置： 类或接口：ElementType.TYPE； 字段：ElementType.FIELD； 方法：ElementType.METHOD； 构造方法：ElementType.CONSTRUCTOR； 方法参数：ElementType.PARAMETER。 例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)： @Target(ElementType.METHOD) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }： @Target({ ElementType.METHOD, ElementType.FIELD }) public @interface Report { ... } 实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。 @Retention 另一个重要的元注解@Retention定义了Annotation的生命周期： 仅编译期：RetentionPolicy.SOURCE； 仅class文件：RetentionPolicy.CLASS； 运行期：RetentionPolicy.RUNTIME。 如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解： @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } @Repeatable 使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。 @Repeatable(Reports.class) @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } @Target(ElementType.TYPE) public @interface Reports { Report[] value(); } 经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解： @Report(type=1, level=\"debug\") @Report(type=2, level=\"warning\") public class Hello { } @Inherited 使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效： @Inherited @Target(ElementType.TYPE) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 在使用的时候，如果一个类用到了@Report： @Report(type=1) public class Person { } 则它的子类默认也定义了该注解： public class Student extends Person { } 如何定义Annotation 我们总结一下定义Annotation的步骤： 第一步，用@interface定义注解： public @interface Report { } 第二步，添加参数、默认值： public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。 第三步，用元注解配置注解： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default \"info\"; String value() default \"\"; } 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。 小结 Java使用@interface定义注解： 可定义多个参数和默认值，核心参数使用value名称； 必须设置@Target来指定Annotation可以应用的范围； 应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:38:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"处理注解 Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置： SOURCE类型的注解在编译期就被丢掉了； CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM； RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。 如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。 因此，我们只讨论如何读取RUNTIME类型的注解。 因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。 Java提供的使用反射API读取Annotation的方法包括： 判断某个注解是否存在于Class、Field、Method或Constructor： Class.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) 例如： // 判断@Report是否存在于Person类: Person.class.isAnnotationPresent(Report.class); 使用反射API读取Annotation： Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 例如： // 获取Person定义的@Report注解: Report report = Person.class.getAnnotation(Report.class); int type = report.type(); String level = report.level(); 第二种方法是直接读取Annotation，如果Annotation不存在，将返回null： Class cls = Person.class; Report report = cls.getAnnotation(Report.class); if (report != null) { ... } 读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解： public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) { } 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解： // 获取Method实例: Method m = ... // 获取所有参数的Annotation: Annotation[][] annos = m.getParameterAnnotations(); // 第一个参数（索引为0）的所有Annotation: Annotation[] annosOfName = annos[0]; for (Annotation anno : annosOfName) { if (anno instanceof Range) { // @Range注解 Range r = (Range) anno; } if (anno instanceof NotNull) { // @NotNull注解 NotNull n = (NotNull) anno; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:39:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用注解 注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。 我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Range { int min() default 0; int max() default 255; } 在某个JavaBean中，我们可以使用该注解： public class Person { @Range(min=1, max=20) public String name; @Range(max=10) public String city; } 但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义： void check(Person person) throws IllegalArgumentException, ReflectiveOperationException { // 遍历所有Field: for (Field field : person.getClass().getFields()) { // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) { // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String) { String s = (String) value; // 判断值是否满足@Range的min/max: if (s.length() \u003c range.min() || s.length() \u003e range.max()) { throw new IllegalArgumentException(\"Invalid field: \" + field.getName()); } } } } } 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。 泛型 泛型是一种“代码模板”，可以用一套代码套用各种类型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:39:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"什么是泛型 在讲解什么是泛型之前，我们先观察Java标准库提供的ArrayList，它可以看作“可变长度”的数组，因为用起来比数组更方便。 实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”： public class ArrayList { private Object[] array; private int size; public void add(Object e) {...} public void remove(int index) {...} public Object get(int index) {...} } 如果用上述ArrayList存储String类型，会有这么几个缺点： 需要强制转型； 不方便，易出错。 例如，代码必须这么写： ArrayList list = new ArrayList(); list.add(\"Hello\"); // 获取到Object，必须强制转型为String: String first = (String) list.get(0); list.add(new Integer(123)); // ERROR: ClassCastException: String second = (String) list.get(1); 要解决上述问题，我们可以为String单独编写一种ArrayList： public class StringArrayList{ private String[] array; public int size; public void add(String e){} public void remove(int index) {...} public String get(int index) {...} } 这样一来，存入的必须是String，取出的也一定是String，不需要强制转型，因为编译器会强制检查放入的类型： StringArrayList list = new StringArrayList(); list.add(\"Hello\"); String first = list.get(0); // 编译错误: 不允许放入非String类型: list.add(new Integer(123)); 问题暂时解决。 然而，新的问题是，如果要存储Integer，还需要为Integer单独编写一种ArrayList： public class IntegerArrayList { private Integer[] array; private int size; public void add(Integer e) {...} public void remove(int index) {...} public Integer get(int index) {...} } 实际上，还需要为其他所有class单独编写一种ArrayList： LongArrayList DoubleArrayList PersonArrayList … 这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。 为了解决新的问题，我们必须把ArrayList变成一种模板：ArrayList\u003cT\u003e，代码如下： class ArrayList\u003cT\u003e{ private T[] array; private void add(T e){ ... } public void remove(int index){ ... } public T get(int index){ ... } } T可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的ArrayList： // 创建可以存储String的ArrayList: ArrayList\u003cString\u003e strList = new ArrayList\u003cString\u003e(); // 创建可以存储Float的ArrayList: ArrayList\u003cFloat\u003e floatList = new ArrayList\u003cFloat\u003e(); // 创建可以存储Person的ArrayList: ArrayList\u003cPerson\u003e personList = new ArrayList\u003cPerson\u003e(); 因此，泛型就是定义一种模板，例如ArrayList\u003cT\u003e，然后在代码中为用到的类创建对应的ArrayList\u003c类型\u003e： ArrayList\u003cString\u003e strList = new ArrayList\u003cString\u003e(); strList.add(\"hello\"); // OK String s = strList.get(0); // OK strList.add(new Integer(123)); // compile error! Integer n = strList.get(0); // compile error! 这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。 向上转型 在Java标准库中的ArrayList\u003cT\u003e实现了List\u003cT\u003e接口，它可以向上转型为List\u003cT\u003e： public class ArrayList\u003cT\u003e implements List\u003cT\u003e { ... } List\u003cString\u003e list = new ArrayList\u003cString\u003e(); 即类型ArrayList\u003cT\u003e可以向上转型为List\u003cT\u003e。 要特别注意：不能把ArrayList\u003cInteger\u003e向上转型为ArrayList\u003cNumber\u003e或List\u003cNumber\u003e。 这是为什么呢？假设ArrayList\u003cInteger\u003e可以向上转型为ArrayList\u003cNumber\u003e，观察一下代码： // 创建ArrayList\u003cInteger\u003e类型： ArrayList\u003cInteger\u003e integerList = new ArrayList\u003cInteger\u003e(); // 添加一个Integer： integerList.add(new Integer(123)); // “向上转型”为ArrayList\u003cNumber\u003e： ArrayList\u003cNumber\u003e numberList = integerList; // 添加一个Float，因为Float也是Number： numberList.add(new Float(12.34)); // 从ArrayList\u003cInteger\u003e获取索引为1的元素（即添加的Float）： Integer n = integerList.get(1); // ClassCastException! 我们把一个ArrayList\u003cInteger\u003e转型为ArrayList\u003cNumber\u003e类型后，这个ArrayList\u003cNumber\u003e就可以接受Float类型，因为Float是Number的子类。但是，ArrayList\u003cNumber\u003e实际上和ArrayList\u003cInteger\u003e是同一个对象，也就是ArrayList\u003cInteger\u003e类型，它不可能接受Float类型， 所以在获取Integer的时候将产生ClassCastException。 实际上，编译器为了避免这种错误，根本就不允许把ArrayList\u003cInteger\u003e转型为ArrayList\u003cNumber\u003e。 package demo; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main{ public static void main(String[] args){ ArrayList\u003cString\u003e strlist=new ArrayList\u003cString\u003e(); ArrayList\u003cFloat\u003e floatlist =new ArrayList\u003cFloat\u003e(); strlist.add(\"hello\"); String s =strlist.get(0); System.out.println(s); //报错 //strlist.add(new Integer(123)); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:40:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用泛型 使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object： // 编译器警告: List list = new ArrayList(); list.add(\"Hello\"); list.add(\"World\"); String first = (String) list.get(0); String second = (String) list.get(1); 此时，只能把\u003cT\u003e当作Object使用，没有发挥泛型的优势。 当我们定义泛型类型\u003cString\u003e后，List\u003cT\u003e的泛型接口变为强类型List\u003cString\u003e： T -\u003eString // 无编译器警告: List\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"Hello\"); list.add(\"World\"); // 无强制转型: String first = list.get(0); String second = list.get(1); 当我们定义泛型类型\u003cNumber\u003e后，List\u003cT\u003e的泛型接口变为强类型List\u003cNumber\u003e： List\u003cNumber\u003e list = new ArrayList\u003cNumber\u003e(); list.add(new Integer(123)); list.add(new Double(12.34)); Number first = list.get(0); Number second = list.get(1); 编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码： List\u003cNumber\u003e list = new ArrayList\u003cNumber\u003e(); 编译器看到泛型类型List\u003cNumber\u003e就可以自动推断出后面的ArrayList\u003cT\u003e的泛型类型必须是ArrayList\u003cNumber\u003e，因此，可以把代码简写为： // 可以省略后面的Number，编译器可以自动推断泛型类型： List\u003cNumber\u003e list = new ArrayList\u003c\u003e(); ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:41:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"泛型接口 除了ArrayList\u003cT\u003e使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable\u003cT\u003e这个泛型接口： public interface Comparable\u003cT\u003e { /** * 返回负数: 当前实例比参数o小 * 返回0: 当前实例与参数o相等 * 返回正数: 当前实例比参数o大 */ int compareTo(T o); } 可以直接对String数组进行排序： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main{ public static void main(String[] args){ String[] ss=new String[] { \"orange\",\"Apple\",\"pear\" }; Arrays.sort(ss); System.out.print(Arrays.toString(ss)); } } 这是因为String本身已经实现了Comparable\u003cString\u003e接口。如果换成我们自定义的Person类型试试： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main{ public static void main(String[] args){ Person[] ps =new Person[] { new Person(\"Bob\",61), new Person(\"xiaohong\",99), new Person(\"xiaoming\",88) }; Arrays.sort(ps); System.out.print(Arrays.toString(ps)); } } class Person{ String name; int score; Person(String name,int score){ this.name=name; this.score=score; } public String toString(){ return this.name+\",\"+this.score; } } 运行程序，我们会得到ClassCastException，即无法将Person转型为Comparable。我们修改代码，让Person实现Comparable\u003cT\u003e接口： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main{ public static void main(String[] args){ Person[] ps =new Person[] { new Person(\"Bob\",61), new Person(\"xiaohong\",99), new Person(\"xiaoming\",88) }; Arrays.sort(ps); System.out.print(Arrays.toString(ps)); } } class Person implements Comparable\u003cPerson\u003e{ String name; int score; Person(String name,int score){ this.name=name; this.score=score; } public int compareTo(Person other){ return this.name.compareTo(other.name); } public String toString(){ return this.name+\",\"+this.score; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:41:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 使用泛型时，把泛型参数\u003cT\u003e替换为需要的class类型，例如：ArrayList\u003cString\u003e，ArrayList\u003cNumber\u003e等； 可以省略编译器能自动推断出的类型，例如：List\u003cString\u003e list = new ArrayList\u003c\u003e();； 不指定泛型参数类型时，编译器会给出警告，且只能将\u003cT\u003e视为Object类型； 可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:41:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"编写泛型 编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如ArrayList\u003cT\u003e，我们很少需要编写泛型类。 如果我们确实需要编写一个泛型类，那么，应该如何编写它？ 可以按照以下步骤来编写一个泛型类。 首先，按照某种类型，例如：String，来编写类： public class Pair { private String first; private String last; public Pair(String first, String last) { this.first = first; this.last = last; } public String getFirst() { return first; } public String getLast() { return last; } } 然后，标记所有的特定类型，这里是String： public class Pair { private String first; private String last; public Pair(String first, String last) { this.first = first; this.last = last; } public String getFirst() { return first; } public String getLast() { return last; } } 最后，把特定类型String替换为T，并申明\u003cT\u003e： class pair\u003cT\u003e{ private T first; private T last; public pair(T first,T last){ this.first=first; this.last=last; } public T getFirst() { return first; } public void setFirst(T first) { this.first = first; } public T getLast() { return last; } public void setLast(T last) { this.last = last; } } 熟练后即可直接从T开始编写。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:42:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"静态方法 编写泛型类时，要特别注意，泛型类型\u003cT\u003e不能用于静态方法。例如： public class Pair\u003cT\u003e { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 对静态方法使用\u003cT\u003e: public static Pair\u003cT\u003e create(T first, T last) { return new Pair\u003cT\u003e(first, last); } } 上述代码会导致编译错误，我们无法在静态方法create()的方法参数和返回类型上使用泛型类型T。 有些同学在网上搜索发现，可以在static修饰符后面加一个\u003cT\u003e，编译就能通过： public class Pair\u003cT\u003e { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 可以编译通过: public static \u003cT\u003e Pair\u003cT\u003e create(T first, T last) { return new Pair\u003cT\u003e(first, last); } } 但实际上，这个\u003cT\u003e和Pair\u003cT\u003e类型的\u003cT\u003e已经没有任何关系了。 对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的create()静态方法，我们应该把它改为另一种泛型类型，例如，\u003cK\u003e： public class Pair\u003cT\u003e { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { ... } public T getLast() { ... } // 静态泛型方法应该使用其他类型区分: public static \u003cK\u003e Pair\u003cK\u003e create(K first, K last) { return new Pair\u003cK\u003e(first, last); } } 这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:42:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"多个泛型类型 public class pair\u003cT,K\u003e{ private T first; private K last; public pair(T first,K last){ this.first=first; this.last=last; } public T getFirst(){...} public K getLast(){...} } 使用的时候，需要指出两种类型： Pair\u003cString, Integer\u003e p = new Pair\u003c\u003e(\"test\", 123); Java标准库的Map\u003cK, V\u003e就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:42:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 编写泛型时，需要定义泛型类型\u003cT\u003e； 静态方法不能引用泛型类型\u003cT\u003e，必须定义其他类型（例如\u003cK\u003e）来实现静态泛型方法； 泛型可以同时定义多种类型，例如Map\u003cK, V\u003e。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:42:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"擦拭法 泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。 Java语言的泛型实现方式是擦拭法（Type Erasure）。 所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。 例如，我们编写了一个泛型类Pair\u003cT\u003e，这是编译器看到的代码： public class Pair\u003cT\u003e { private T first; private T last; public Pair(T first, T last) { this.first = first; this.last = last; } public T getFirst() { return first; } public T getLast() { return last; } } 而虚拟机根本不知道泛型。这是虚拟机执行的代码： public class Pair { private Object first; private Object last; public Pair(Object first, Object last) { this.first = first; this.last = last; } public Object getFirst() { return first; } public Object getLast() { return last; } } 因此，Java使用擦拭法实现泛型，导致了： 编译器把类型\u003cT\u003e视为Object； 编译器根据\u003cT\u003e实现安全的强制转型。 使用泛型的时候，我们编写的代码也是编译器看到的代码： Pair\u003cString\u003e p = new Pair\u003c\u003e(\"Hello\", \"world\"); String first = p.getFirst(); String last = p.getLast(); 而虚拟机执行的代码并没有泛型： Pair p = new Pair(\"Hello\", \"world\"); String first = (String) p.getFirst(); String last = (String) p.getLast(); 所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。 了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限： 局限一：\u003cT\u003e不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型： Pair\u003cint\u003e p = new Pair\u003c\u003e(1, 2); // compile error! 局限二：无法取得带泛型的Class。观察以下代码： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main{ public static void main(String[] args){ pair\u003cString\u003e p1=new pair\u003c\u003e(\"hello\",\"world\"); pair\u003cInteger\u003e p2 =new pair\u003c\u003e(123,456); Class c1=p1.getClass(); Class c2=p2.getClass(); System.out.println(c1==c2);//True System.out.println(c1==pair.class);//True } } class pair\u003cT\u003e{ private T first; private T last; public pair(T first,T last){ this.first=first; this.last=last; } public T getFirst() { return first; } public void setFirst(T first) { this.first = first; } public T getLast() { return last; } public void setLast(T last) { this.last = last; } } 因为T是Object，我们对Pair\u003cString\u003e和Pair\u003cInteger\u003e类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。 换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair\u003cObject\u003e。 局限三：无法判断带泛型的类型： Pair\u003cInteger\u003e p = new Pair\u003c\u003e(123, 456); // Compile error: if (p instanceof Pair\u003cString\u003e) { } 原因和前面一样，并不存在Pair\u003cString\u003e.class，而是只有唯一的Pair.class。 public class Pair\u003cT\u003e { private T first; private T last; public Pair() { // Compile error: first = new T(); last = new T(); } } 上述代码无法通过编译，因为构造方法的两行语句： first = new T(); last = new T(); 擦拭后实际上变成了： first = new Object(); last = new Object(); 这样一来，创建new Pair\u003cString\u003e()和创建new Pair\u003cInteger\u003e()就全部成了Object，显然编译器要阻止这种类型不对的代码。 要实例化T类型，我们必须借助额外的Class\u003cT\u003e参数： public class Pair\u003cT\u003e { private T first; private T last; public Pair(Class\u003cT\u003e clazz) { first = clazz.newInstance(); last = clazz.newInstance(); } } 上述代码借助Class\u003cT\u003e参数并通过反射来实例化T类型，使用的时候，也必须传入Class\u003cT\u003e。例如： Pair\u003cString\u003e pair = new Pair\u003c\u003e(String.class); 因为传入了Class\u003cString\u003e的实例，所以我们借助String.class就可以实例化String类型。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:43:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"不恰当的覆写方法 有些时候，一个看似正确定义的方法会无法通过编译。例如： public class Pair\u003cT\u003e { public boolean equals(T t) { return this == t; } } 这是因为，定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。 换个方法名，避开与Object.equals(Object)的冲突就可以成功编译： public class Pair\u003cT\u003e { public boolean same(T t) { return this == t; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:43:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"泛型继承 一个类可以继承自一个泛型类。例如：父类的类型是Pair\u003cInteger\u003e，子类的类型是IntPair，可以这么继承： public class IntPair extends Pair\u003cInteger\u003e { } 使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可： IntPair ip = new IntPair(1, 2); 前面讲了，我们无法获取Pair\u003cT\u003e的T类型，即给定一个变量Pair\u003cInteger\u003e p，无法从p中获取到Integer类型。 但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。 在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：IntPair可以获取到父类的泛型类型Integer。获取父类的泛型类型代码比较复杂： ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:43:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 Java的泛型是采用擦拭法实现的； 擦拭法决定了泛型\u003cT\u003e： 不能是基本类型，例如：int； 不能获取带泛型类型的Class，例如：Pair\u003cString\u003e.class； 不能判断带泛型类型的类型，例如：x instanceof Pair\u003cString\u003e； 不能实例化T类型，例如：new T()。 泛型方法要防止重复定义方法，例如：public boolean equals(T obj)； 子类可以获取父类的泛型类型\u003cT\u003e。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:43:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"extends通配符 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:44:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"super通配符 … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:45:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"泛型和反射 … 集合 集合是一个容器，可以一次容纳多个对象。 例：假设数据库中有10条记录，那么假设把这10条条记录查询出来，在java程序中会将10条数据封装成10个java对象，然后将10个java对象放在某一个集合中，将集合传到前端，然后遍历集合。 集合中不能直接存储基本数据类型，集合也不能直接存储java对象，集合中存储的是java对象的内存地址（或者说是引用 ）list.add(100)//自动装箱Integer 集合也是一个对象 集合在任何时候存储的都是内存地址 每一个不同的集合，底层会对应不同的数据结构。往不同的集合中存储元素等于将数据放到不同的数据结构中。 常见的数据结构：数组、链表、哈希表 使用不同的集合等同于使用不同的数据结构 new ArrayList(); //创建一个集合，底层是数组 new LinkList();//创建一个集合，底层是链表 new Treeset(); //创建一个集合，底层是二叉树 在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合： String[] ss =new String[10]; ss[0]=\"Hello\"; String first=ss[0]; 既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制： 数组初始化后大小不可变； 数组只能按索引顺序存取。 因此，我们需要各种不同类型的集合类来处理不同的数据，例如： 可变大小的顺序链表； 保证无重复元素的集合； … Collection Java标准库自带的java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。Java的java.util包主要提供了以下三种类型的集合： List：一种有序列表的集合，例如，按索引排列的Student的List； Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set； Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。 集合的两个基本接口：Collection和Map java.util.Collection : 单个方式存储:插入元素：add(element) java.util.Map ：键值方式存储，put \\ get Java集合的设计有几个特点：一是实现了接口（相当于模板类）和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如： List\u003cString\u003e list = new ArrayList\u003c\u003e(); // 只能放入String类型 最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。 由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用： Hashtable：一种线程安全的Map实现； Vector：一种线程安全的List实现； Stack：基于Vector实现的LIFO的栈。 还有一小部分接口是遗留接口，也不应该继续使用： Enumeration\u003cE\u003e：已被Iterator\u003cE\u003e取代。 小结 Java的集合类定义在java.util包中，支持泛型，主要提供了3种集合类，包括List，Set和Map。Java集合使用统一的Iterator遍历，尽量不要使用遗留接口。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:46:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用list 在集合类中，List是最基础的一种集合：它是一种有序列表。 可以采用两种方式访问元素： 使用迭代器访问 - 随机访问，按任意顺序访问元素 使用整数索引访问 - 顺序访问元素 有两种有序集合： Arraylist- 可快速随机访问（使用整数索引） 链表-访问速度慢，最好使用迭代器来遍历 List的行为和数组几乎完全相同：List内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，List的索引和数组一样，从0开始。 数组和List类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组{'A', 'B', 'C', 'D', 'E'}中删除索引为2的元素： ┌───┬───┬───┬───┬───┬───┐ │ A │ B │ C │ D │ E │ │ └───┴───┴───┴───┴───┴───┘ │ │ ┌───┘ │ │ ┌───┘ │ │ ▼ ▼ ┌───┬───┬───┬───┬───┬───┐ │ A │ B │ D │ E │ │ │ └───┴───┴───┴───┴───┴───┘ 这个“删除”操作实际上是把'C'后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。 因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是ArrayList。实际上，ArrayList在内部使用了数组来存储所有元素。例如，一个ArrayList拥有5个元素，实际数组大小为6（即有一个空位）： ArrayList的扩容机制 ：参考 size=5 ┌───┬───┬───┬───┬───┬───┐ │ A │ B │ C │ D │ E │ │ └───┴───┴───┴───┴───┴───┘ 当添加一个元素并指定索引到ArrayList时，ArrayList自动移动需要移动的元素： size=5 ┌───┬───┬───┬───┬───┬───┐ │ A │ B │ │ C │ D │ E │ └───┴───┴───┴───┴───┴───┘ 然后，往内部指定索引的数组位置添加一个元素，然后把size加1： size=6 ┌───┬───┬───┬───┬───┬───┐ │ A │ B │ F │ C │ D │ E │ └───┴───┴───┴───┴───┴───┘ 继续添加元素，但是数组已满，没有空闲位置的时候，ArrayList先创建一个更大的新数组（进行扩容），然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组： size=6 ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ A │ B │ F │ C │ D │ E │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时size加1： size=7 ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐ │ A │ B │ F │ C │ D │ E │ G │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘ 可见，**ArrayList把添加和删除的操作封装起来，让我们操作List类似于操作数组，却不用关心内部元素如何移动。** 我们考察List\u003cE\u003e接口，可以看到几个主要的接口方法： 在末尾添加一个元素：boolean add(E e) 在指定索引添加一个元素：boolean add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size() 但是，实现List接口并非只能通过数组（即ArrayList的实现方式）来实现，另一种LinkedList通过“链表”也实现了List接口。在LinkedList中，它的内部每个元素都指向下一个元素： ┌───┬───┐ ┌───┬───┐ ┌───┬───┐ ┌───┬───┐ HEAD ──\u003e│ A │ ●─┼──\u003e│ B │ ●─┼──\u003e│ C │ ●─┼──\u003e│ D │ │ └───┴───┘ └───┴───┘ └───┴───┘ └───┴───┘ 我们来比较一下ArrayList和LinkedList： ArrayList LinkedList 获取指定元素 速度很快 需要从头开始查找元素 添加元素到末尾 速度很快 速度很快 在指定位置添加/删除 需要移动元素 不需要移动元素 内存占用 少 较大 通常情况下，我们总是优先使用ArrayList。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:47:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"List的特点 有序的 元素可以重复 使用List时，我们要关注List接口的规范。List接口允许我们添加重复的元素，即List内部的元素可以重复： public class Main { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"apple\"); // size=1 list.add(\"pear\"); // size=2 list.add(\"apple\"); // 允许重复添加元素，size=3 System.out.println(list.size()); } } List还允许添加null： public class Main { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"apple\"); // size=1 list.add(null); // size=2 list.add(\"pear\"); // size=3 String second = list.get(1); // null System.out.println(second); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:47:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"创建List 除了使用ArrayList和LinkedList，我们还可以通过List接口提供的of()方法，根据给定元素快速创建List： List\u003cInteger\u003e list = List.of(1, 2, 5); 但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:47:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"遍历List 和数组类型，我们要遍历一个List，完全可以用for循环根据索引配合get(int)方法遍历： public class Main{ public static void main(String[] args){ List\u003cString\u003e list=List.of(\"apple\",\"orange\"); for (int i=0;i\u003clist.size();i++){ String s =list.get(i); System.out.println(s); } } } 但这种方式并不推荐，一是代码复杂，二是因为get(int)方法只有ArrayList的实现是高效的，换成LinkedList后，索引越大，访问速度越慢。 所以我们要始终坚持使用迭代器Iterator来访问List。Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。Iterator对象知道如何遍历一个List，并且不同的List类型，返回的Iterator对象实现也是不同的，但总是具有最高的访问效率。 Iterator对象有两个方法：boolean hasNext()判断是否有下一个元素，E next()返回下一个元素。因此，使用Iterator遍历List代码如下: public class Main{ public static void main(String[] args){ List\u003cString\u003e list=List.of(\"apple\",\"orange\"); for (Iterator\u003cString\u003e it = list.iterator(); it.hasNext();){ String s =it.next(); System.out.println(s); } } } 有童鞋可能觉得使用Iterator访问List的代码比使用索引更复杂。但是，要记住，通过Iterator遍历List永远是最高效的方式。并且，由于Iterator遍历是如此常用，所以，Java的for each循环本身就可以帮我们使用Iterator遍历。把上面的代码再改写如下： public class Main{ public static void main(String[] args){ List\u003cString\u003e list=List.of(\"apple\",\"orange\"); for (String s:list){ System.out.println(s); } } } 当集合的结构发生改变时，迭代器必须重新获取 在迭代集合的元素时，不能够调用remove 方法删除集合的元素。 package demo; import java.util.*; public class Main{ public static void main(String[] args) { Collection c=new ArrayList(); c.add(123); c.add(456); c.add(789); Iterator it=c.iterator(); //这里使用Collection的remove方法删除元素会使得集合的元素发生改变，但是此时的迭代器并没有进行更新，所以会抛出异常ConcurrentModificationException！ c.remove(123); System.out.println(it.next()); } } package demo; import java.util.*; public class Main{ public static void main(String[] args) { Collection c=new ArrayList(); c.add(123); c.add(456); c.add(789); Iterator it=c.iterator(); System.out.println(it.next()); it.remove();//这里调用的是迭代器的remove方法，所以可以正常的删除。 System.out.println(c.size()); } } 注意： 必须先调用next()方法越过将要删除的元素，才能调用迭代器的remove方法，两者存在依赖性。 迭代器的remove方法将会删除上次调用next方法返回的元素。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:47:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"List和Array转换 把List变为Array有三种方法，第一种是调用toArray()方法直接返回一个Object[]数组： public class Main{ public static void main(String[] args){ List\u003cString\u003e list=List.of(\"apple\",\"orange\"); Object[] array=list.toArray(); for (Object s: array){ System.out.println(s); } } } 这种方法会丢失类型信息，所以实际应用很少。 第二种方式是给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = List.of(12, 34, 56); Integer[] array = list.toArray(new Integer[3]); for (Integer n : array) { System.out.println(n); } } } 注意到这个toArray(T[])方法的泛型参数\u003cT\u003e并不是List接口定义的泛型参数\u003cE\u003e，所以，我们实际上可以传入其他类型的数组，例如我们传入Number类型的数组，返回的仍然是Number类型： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = List.of(12, 34, 56); Number[] array = list.toArray(new Number[3]); for (Number n : array) { System.out.println(n); } } } 但是，如果我们传入类型不匹配的数组，例如，String[]类型的数组，由于List的元素是Integer，所以无法放入String数组，这个方法会抛出ArrayStoreException。 如果我们传入的数组大小和List实际的元素个数不一致怎么办？根据List接口的文档，我们可以知道： 如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。 实际上，最常用的是传入一个“恰好”大小的数组： Integer[] array = list.toArray(new Integer[list.size()]); 最后一种更简洁的写法是通过List接口定义的T[] toArray(IntFunction\u003cT[]\u003e generator)方法： Integer[] array = list.toArray(Integer[]::new); 这种函数式写法我们会在后续讲到。 反过来，把Array变为List就简单多了，通过List.of(T...)方法最简单： Integer[] array = { 1, 2, 3 }; List\u003cInteger\u003e list = List.of(array); 对于JDK 11之前的版本，可以使用Arrays.asList(T...)方法把数组转换成List。 要注意的是，返回的List不一定就是ArrayList或者LinkedList，因为List只是一个接口，如果我们调用List.of()，它返回的是一个只读List： public class Main { public static void main(String[] args) { List\u003cInteger\u003e list = List.of(12, 34, 56); list.add(999); // UnsupportedOperationException } } 对只读List调用add()、remove()方法会抛出UnsupportedOperationException。 练习： 给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.ArrayList; import java.util.Arrays; import java.util.Iterator; import java.util.List; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main { public static void main(String[] args) { final int start = 10; final int end = 20; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i = start; i \u003c= end; i++) { list.add(i); } int removed = list.remove((int) (Math.random() * list.size())); int found = findMissingNUMber(start, end, list); System.out.println(list.toString()); System.out.println(\"missing number:\" + removed); System.out.println(\"found number:\" + found); System.out.println(removed == found ? \"测试成功\" : \"测试失败\"); } static int findMissingNUMber(int start, int end, List\u003cInteger\u003e list) { // int[] num={10,11,12,13,14,15,16,17,18,19,20}; int[] num=new int[list.size()]; for (int i=0;i\u003c list.size();i++){ num[i]=start; start++; } int j=0; int miss=0; for (int i=0;i\u003clist.size();i++){ Integer s=list.get(i); if (s==num[j]){ j++; } else { miss=s-1; break; } } return miss; } } 增强版：和上述题目一样，但整数不再有序，试找出缺失的数字： package demo; import java.io.UnsupportedEncodingException; import java.lang.reflect.Array; import java.util.*; import java.util.logging.Logger; /* * @author shilongshen * *@ * * * */ public class Main { public static void main(String[] args) { final int start = 10; final int end = 20; List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int i = start; i \u003c= end; i++) { list.add(i); } System.out.printf(\"before:%s\\n\",list.toString()); Collections.shuffle(list);//随机交换List中的元素位置 int removed = list.remove((int) (Math.random() * list.size()));//随机删除List中的一个元素 int found = findMissingNUMber(start, end, list); System.out.printf(\"after:%s\\n\",list.toString()); System.out.println(\"missing number:\" + removed); System.out.println(\"found number:\" + found); System.out.println(removed == found ? \"测试成功\" : \"测试失败\"); } static int findMissingNUMber(int start, int end, List\u003cInteger\u003e list) { // int[] num={10,11,12,13,14,15,16,17,18,19,20}; int[] num = new int[list.size()+1]; for (int i = 0; i \u003c= list.size(); i++) { num[i] = start; start++; } System.out.printf(\"size:%s\\","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:47:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"编写equals方法 如果在collection中调用了contains和remove方法，存放进集合中的元素需要重写equals方法（String,Integer等对象不用，因为本身已经重写了equals方法） 调用的是存放进集合中元素的equals方法。 我们知道List是一种有序链表：List内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。 List还提供了boolean contains(Object o)方法来判断List是否包含某个指定元素。此外，int indexOf(Object o)方法可以返回某个元素的索引，如果元素不存在，就返回-1。 public class Main { public static void main(String[] args) { List\u003cString\u003e list = List.of(\"A\", \"B\", \"C\"); System.out.println(list.contains(\"C\")); // true System.out.println(list.contains(\"X\")); // false System.out.println(list.indexOf(\"C\")); // 2 System.out.println(list.indexOf(\"X\")); // -1 } } 这里我们注意一个问题，我们往List中添加的\"C\"和调用contains(\"C\")传入的\"C\"是不是同一个实例？ 如果这两个\"C\"不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下： public class Main { public static void main(String[] args) { List\u003cString\u003e list = List.of(\"A\", \"B\", \"C\"); System.out.println(list.contains(new String(\"C\"))); // true System.out.println(list.indexOf(new String(\"C\"))); // 2 } } 因为我们传入的是new String(\"C\")，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？ 因为List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等，例如contains()方法可以实现如下： public class ArrayList { Object[] elementData; public boolean contains(Object o) { for (int i = 0; i \u003c size; i++) { if (o.equals(elementData[i])) { return true; } } return false; } } 因此，要正确使用List的contains()、indexOf()这些方法，放入的实例必须正确覆写equals()方法，否则，放进去的实例，查找不到。我们之所以能正常放入String、Integer这些对象，是因为Java标准库定义的这些类已经正确实现了equals()方法。 我们以Person对象为例，测试一下： public class Main { public static void main(String[] args) { List\u003cPerson\u003e list = List.of( new Person(\"Xiao Ming\"), new Person(\"Xiao Hong\"), new Person(\"Bob\") ); System.out.println(list.contains(new Person(\"Bob\"))); // false } } class Person { String name; public Person(String name) { this.name = name; } } 不出意外，虽然放入了new Person(\"Bob\")，但是用另一个new Person(\"Bob\")查询不到，原因就是Person类没有覆写equals()方法。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:48:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"编写equals 如何正确编写equals()方法？equals()方法要求我们必须满足以下条件： 自反性（Reflexive）：对于非null的x来说，x.equals(x)必须返回true； 对称性（Symmetric）：对于非null的x和y来说，如果x.equals(y)为true，则y.equals(x)也必须为true； 传递性（Transitive）：对于非null的x、y和z来说，如果x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)也必须为true； 一致性（Consistent）：对于非null的x和y来说，只要x和y状态不变，则x.equals(y)总是一致地返回true或者false； 对null的比较：即x.equals(null)永远返回false。 上述规则看上去似乎非常复杂，但其实代码实现equals()方法是很简单的，我们以Person类为例： public class Person { public String name; public int age; } 首先，我们要定义“相等”的逻辑含义。对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。 因此，编写equals()方法如下： public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return this.name.equals(p.name) \u0026\u0026 this.age == p.age; } return false; } 对于引用字段比较，我们使用equals()，对于基本类型字段的比较，我们使用==。 如果this.name为null，那么equals()方法会报错，因此，需要继续改写如下： public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; boolean nameEquals = false; if (this.name == null \u0026\u0026 p.name == null) { nameEquals = true; } if (this.name != null) { nameEquals = this.name.equals(p.name); } return nameEquals \u0026\u0026 this.age == p.age; } return false; } 如果Person有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用Objects.equals()静态方法： public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return Objects.equals(this.name, p.name) \u0026\u0026 this.age == p.age; } return false; } 因此，我们总结一下equals()方法的正确编写方法： 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等； 用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false； 对引用类型用Objects.equals()比较，对基本类型直接用==比较。 使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。 如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。 例： package demo; import java.util.*; public class Main{ public static void main(String[] args) { Collection c=new ArrayList(); Student s1=new Student(\"jack\"); Student s2=new Student(\"jack\"); c.add(s1); System.out.println(c.contains(s2)); } } class Student{ private String name; public Student(String name){ this.name=name; } //重写equals方法 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return Objects.equals(name, student.name); } } 练习： 给Person类增加equals方法，使得调用indexOf()方法返回正常： package demo; import java.util.List; import java.util.Objects; public class Main { public static void main(String[] args) { List\u003cPerson\u003e list = List.of( new Person(\"xiaoming\", \"xiamhong\", 18), new Person(\"xiaohua\", \"xiamhong\", 18), new Person(\"xiaori\", \"xiaocai\", 18) ); boolean exit = list.contains(new Person(\"xiaori\", \"xiaocai\", 18)); System.out.print(exit ? \"测试成功\" : \"测试失败\"); } } class Person { String firstName; String lastName; int age; public Person(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } @Override public boolean equals(Object o) { if (o instanceof Person) { Person p = (Person) o; return Objects.equals(this.firstName, p.firstName) \u0026\u0026 Objects.equals(this.lastName, p.lastName) \u0026\u0026 this.age == p.age; } return false; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:48:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用Map 我们知道，List是一种顺序列表，如果有一个存储学生Student实例的List，要在List中根据name查找某个指定的Student的分数，应该怎么办？ 最简单的方法是遍历List并判断name是否相等，然后返回指定元素： List\u003cStudent\u003e list = ... Student target = null; for (Student s : list) { if (\"Xiao Ming\".equals(s.name)) { target = s; break; } } System.out.println(target.score); 这种需求其实非常常见，即通过一个键去查询对应的值。使用List来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而Map这种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。 public class Main { public static void main(String[] args) { Student s = new Student(\"Xiao Ming\", 99); Map\u003cString, Student\u003e map = new HashMap\u003c\u003e(); map.put(\"Xiao Ming\", s); // 将\"Xiao Ming\"和Student实例映射并关联 Student target = map.get(\"Xiao Ming\"); // 通过key查找并返回映射的Student实例 System.out.println(target == s); // true，同一个实例 System.out.println(target.score); // 99 Student another = map.get(\"Bob\"); // 通过另一个key查找 System.out.println(another); // 未找到返回null } } class Student { public String name; public int score; public Student(String name, int score) { this.name = name; this.score = score; } } 通过上述代码可知：Map\u003cK, V\u003e是一种键-值映射表，当我们调用put(K key, V value)方法时，就把key和value做了映射并放入Map。当我们调用V get(K key)时，就可以通过key获取到对应的value。如果key不存在，则返回null。和List类似，Map也是一个接口，最常用的实现类是HashMap。 如果只是想查询某个key是否存在，可以调用boolean containsKey(K key)方法。 如果我们在存储Map映射关系的时候，对同一个key调用两次put()方法，分别放入不同的value，会有什么问题呢？例如： public class Main { public static void main(String[] args) { Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"apple\", 123); map.put(\"pear\", 456); System.out.println(map.get(\"apple\")); // 123 map.put(\"apple\", 789); // 再次放入apple作为key，但value变为789 System.out.println(map.get(\"apple\")); // 789 } } 重复放入key-value并不会有任何问题，但是一个key只能关联一个value。在上面的代码中，一开始我们把key对象\"apple\"映射到Integer对象123，然后再次调用put()方法把\"apple\"映射到789，这时，原来关联的value对象123就被“冲掉”了。实际上，put()方法的签名是V put(K key, V value)，如果放入的key已经存在，put()方法会返回被删除的旧的value，否则，返回null。 始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。 此外，在一个Map中，虽然key不能重复，但value是可以重复的： Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"apple\", 123); map.put(\"pear\", 123); // ok ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:49:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"遍历Map 对Map来说，要遍历key可以使用for each循环遍历Map实例的keySet()方法返回的Set集合，它包含不重复的key的集合： public class Main { public static void main(String[] args) { Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"apple\", 123); map.put(\"pear\", 456); map.put(\"banana\", 789); for (String key : map.keySet()) { Integer value = map.get(key); System.out.println(key + \" = \" + value); } } } 同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射： public class Main { public static void main(String[] args) { Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"apple\", 123); map.put(\"pear\", 456); map.put(\"banana\", 789); for (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) { String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key + \" = \" + value); } } } Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。在遍历的时候，遍历的顺序既不一定是put()时放入的key的顺序，也不一定是key的排序顺序。使用Map时，任何依赖顺序的逻辑都是不可靠的。以HashMap为例，假设我们放入\"A\"，\"B\"，\"C\"这3个key，遍历的时候，每个key会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！ 遍历Map时，不可假设输出的key是有序的！ ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:49:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 Map是一种映射表，可以通过key快速查找value。 可以通过for each遍历keySet()，也可以通过for each遍历entrySet()，直接获取key-value。 最常用的一种Map实现是HashMap。 练习： 请编写一个根据name查找score的程序，并利用Map充当缓存，以提高查找效率： package demo; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Objects; public class Main { public static void main(String[] args) { List\u003cStudent\u003e list = List.of( new Student(\"Bob\", 78), new Student(\"Alice\", 85), new Student(\"Brush\", 66), new Student(\"Newton\", 99)); var holder = new Students(list); System.out.println(holder.getScore(\"Bob\") == 78 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Alice\") == 85 ? \"测试成功!\" : \"测试失败!\"); System.out.println(holder.getScore(\"Tom\") == -1 ? \"测试成功!\" : \"测试失败!\"); } } class Students { List\u003cStudent\u003e list; Map\u003cString, Integer\u003e cache; Students(List\u003cStudent\u003e list) { this.list = list; cache = new HashMap\u003c\u003e(); } /** * 根据name查找score，找到返回score，未找到返回-1 */ int getScore(String name) { // 先在Map中查找: Integer score = this.cache.get(name); if (score == null) { // TODO: cache.put(name, score); score = findInList(name); } return (score == null) ? -1 : score; } Integer findInList(String name) { for (var ss : this.list) { if (ss.name.equals(name)) { return ss.score; } } return null; } } class Student { String name; int score; Student(String name, int score) { this.name = name; this.score = score; } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:49:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"编写equals和hashCode 我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。 以HashMap为例，观察下面的代码： Map\u003cString, Person\u003e map = new HashMap\u003c\u003e(); map.put(\"a\", new Person(\"Xiao Ming\")); map.put(\"b\", new Person(\"Xiao Hong\")); map.put(\"c\", new Person(\"Xiao Jun\")); map.get(\"a\"); // Person(\"Xiao Ming\") map.get(\"x\"); // null HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引： ┌───┐ 0 │ │ ├───┤ 1 │ ●─┼───\u003e Person(\"Xiao Ming\") ├───┤ 2 │ │ ├───┤ 3 │ │ ├───┤ 4 │ │ ├───┤ 5 │ ●─┼───\u003e Person(\"Xiao Hong\") ├───┤ 6 │ ●─┼───\u003e Person(\"Xiao Jun\") ├───┤ 7 │ │ └───┘ 如果key的值为\"a\"，计算得到的索引总是1，因此返回value为Person(\"Xiao Ming\")，如果key的值为\"b\"，计算得到的索引总是5，因此返回value为Person(\"Xiao Hong\")，这样，就不必遍历整个数组，即可直接读取key对应的value。 当我们使用key存取value的时候，就会引出一个问题： 我们放入Map的key是字符串\"a\"，但是，当我们获取Map的value时，传入的变量不一定就是放入的那个key对象。 换句话讲，两个key应该是内容相同，但不一定是同一个对象。测试代码如下： public class Main { public static void main(String[] args) { String key1 = \"a\"; Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(key1, 123); String key2 = new String(\"a\"); map.get(key2); // 123 System.out.println(key1 == key2); // false System.out.println(key1.equals(key2)); // true } } 因为在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。 我们经常使用String作为key，因为String已经正确覆写了equals()方法。但如果我们放入的key是一个自己写的类，就必须保证正确覆写了equals()方法。 通过key计算索引的方式就是调用key对象的hashCode()方法，它返回一个int整数。HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。 因此，正确使用Map必须保证： 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范： 如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。 即对应两个实例a和b： 如果a和b相等，那么a.equals(b)一定为true，则a.hashCode()必须等于b.hashCode()； 如果a和b不相等，那么a.equals(b)一定为false，则a.hashCode()和b.hashCode()尽量不要相等。 正确编写equals()的方法我们已经在编写equals方法一节中讲过了，以Person类为例： public class Person { String firstName; String lastName; int age; } 把需要比较的字段找出来： firstName lastName age 然后，引用类型使用Objects.equals()比较，基本类型使用==比较。 在正确实现equals()的基础上，我们还需要正确实现hashCode()，即上述3个字段分别相同的实例，hashCode()返回的int必须相同： public class Person { String firstName; String lastName; int age; @Override int hashCode() { int h = 0; h = 31 * h + firstName.hashCode(); h = 31 * h + lastName.hashCode(); h = 31 * h + age; return h; } } … ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:50:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用EnumMap 因为HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。 如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。 我们以DayOfWeek这个枚举类型为例，为它做一个“翻译”功能： public class Main { public static void main(String[] args) { Map\u003cDayOfWeek, String\u003e map = new EnumMap\u003c\u003e(DayOfWeek.class); map.put(DayOfWeek.MONDAY, \"星期一\"); map.put(DayOfWeek.TUESDAY, \"星期二\"); map.put(DayOfWeek.WEDNESDAY, \"星期三\"); map.put(DayOfWeek.THURSDAY, \"星期四\"); map.put(DayOfWeek.FRIDAY, \"星期五\"); map.put(DayOfWeek.SATURDAY, \"星期六\"); map.put(DayOfWeek.SUNDAY, \"星期日\"); System.out.println(map); System.out.println(map.get(DayOfWeek.MONDAY)); } } 使用EnumMap的时候，我们总是用Map接口来引用它，因此，实际上把HashMap和EnumMap互换，在客户端看来没有任何区别。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:51:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"小结 如果Map的key是enum类型，推荐使用EnumMap，既保证速度，也不浪费空间。 使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:51:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"使用TreeMap 我们已经知道，HashMap是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历HashMap的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。 还有一种Map，它在内部会对Key进行排序，这种Map就是SortedMap。注意到SortedMap是接口，它的实现类是TreeMap。 ┌───┐ │Map│ └───┘ ▲ ┌────┴─────┐ │ │ ┌───────┐ ┌─────────┐ │HashMap│ │SortedMap│ └───────┘ └─────────┘ ▲ │ ┌─────────┐ │ TreeMap │ └─────────┘ SortedMap保证遍历时以Key的顺序来进行排序。例如，放入的Key是\"apple\"、\"pear\"、\"orange\"，遍历的顺序一定是\"apple\"、\"orange\"、\"pear\"，因为String默认按字母排序： package demo; import java.time.DayOfWeek; import java.util.EnumMap; import java.util.Map; import java.util.TreeMap; public class Main{ public static void main(String[] args){ Map\u003cString,Integer\u003e map = new TreeMap\u003c\u003e(); map.put(\"apple\",2); map.put(\"orange\",1); map.put(\"pear\",3); for (String key:map.keySet()){ System.out.println(key); } } } 使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。 如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法： 并发，多线程 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:52:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"创建线程的三种方式： ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"第一种方法：实现Runnable 接口，并覆写Run方法 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:1","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"第二种方法：继承Thread，并覆写Run方法 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:2","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"第三种方法：实现Callable接口，并重写call方法 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:3","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"选择使用实现Runable接口还是继承Thread ​ 由于java中不支持类的多重继承，但是支持实现多个接口，因此如果需要继承其他的类，需要选择实现Runnable接口。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:4","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"start方法和run方法的区别 ​ start方法由于启动线程，启动线程之后会运行线程中的run方法。如果没有调用start方法而直接调用run方法，则没有启动新线程，开辟新的栈空间，而是在原来的线程中调用run方法。 //第一种方法：实现Runnable 接口，并覆写Run方法 public class Main{ public static void main(String[] args){ //创建一个线程对象，构造方法需要传入一个可运行对象 Thread t1=new Thread(new MyThread); t1.start; } } class MyThread implemtnts Runnable{ @Override public void Run{ //线程的方法 } } //第二种方法：继承Thread，并覆写Run方法 public class Main{ public static void main(String[] args){ //创建一个线程对象 Thread t1=new MyThread(); t1.start; } } class MyThread extends Thread{ @Override public void Run{ //线程的方法 } } /* * 实现线程的第三种方法，实现Callable接口 * * 优点： * 可以获得当前线程的执行结果 * 缺点： * 效率比较低，在获取t线程执行结果时，当前线程受阻，效率较低。 * * */ public class ThreadTest10 { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建一个“未来对象类” FutureTask futureTask = new FutureTask(new Callable() {//call()相当与run() @Override public Object call() throws Exception { System.out.println(\"线程执行\"); Thread.sleep(1000*5); return 22+30;//有返回值 } }); //创建线程对象 Thread t1 = new Thread(futureTask); // 启动线程 t1.start(); //如何在main线程中获取t1线程的返回值 //通过get方法 // get方法会导致main线程受阻 Object o=futureTask.get(); System.out.println(o); // 只有到t1线程结束。main方法才能执行 System.out.println(\"main线程\"); } } ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:53:5","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"线程的状态 线程的状态包括了： 新建（new）: 刚new出来的线程 可运行 （Runnable）：new出来的线程通过start()方法进入可运行状态，可运行状态又可以细分为可运行状态和运行状态,其中可运行状态表示当前线程具有抢夺执行权的权利（java采用的是抢占式的调度方式），当一个线程抢到执行权后就开始执行Run方法进入运行状态，当执行权用完后会重性进入可运行状态。 阻塞 (Blocked) ： 线程遇到阻塞事件会放弃抢到的执行权，回到可运行状态。 等待 （waiting）：当线程占用锁的对象调用wait方法时，该线程会进入等待状态，进释放抢到的执行权。 计时等待 (Timed waiting) 终止 (Teminated)：线程的Run方法执行结束。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:54:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["Java学习笔记"],"content":"常见问题总结： Java中Runnable和Callable有什么不同？ Runnable封装一个一部运行的任务，可以把它想象成一个没有参数和返回值的方法。Callable和Runnable方法类似，但是有返回值，Callable接口是一个参数化的类型，只有一个方法call,类型参数是返回值的类型 Java中的volatile 变量是什么？ volatile关键字为实例字段提供了一种免锁机制。如果声明一个实例字段为volatile，那么编译器和java虚拟机就知道该字段可能被另一个线程并发更新。(保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。) 什么是线程安全？Vector是一个线程安全类吗？ 当存在多线程并发，并且多线程对同一个数据进行操作，且存在修改数据的行为，就会存在线程安全的问题。 Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。 Java中notify 和 notifyAll有什么区别？ notify:随机选择一个在这个对象上调用wait方法的线程，解除其阻塞状态。(notify方法不能唤醒某个具体的线程，所以只有一个线程在等 待的时候它才有用武之地) notifyAll:解除所有这个对象上调用wait方法的线程 的阻塞状态。(notifyAll唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？ 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 什么是ThreadLocal变量？ ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。 ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比synchronized要简单得多。 ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。 Java多线程中调用wait() 和 sleep()方法有什么不同？ wait()会释放锁，而sleep不会释放锁。 Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。 Java中interrupted 和 isInterruptedd方法的区别？ Thread.interruped()是一个静态方法，它检查当前线程是否被中断，而且调用该方法会清除该线程的中断状态。 isInterruped()是一个实例方法，用于检查是否有线程被中断。调用这个方法不会改变中断状态。 Java中堆和栈有什么不同？ 为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈 调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。 怎么检测一个线程是否拥有锁？ 在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。 有三个线程T1，T2，T3，怎么确保它们按顺序执行？ 使用join方法 用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。 Thread类中的yield方法有什么作用？ Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。 volatile 变量和 atomic 变量有什么不同？ 这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性 的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。 写出3条你遵循的多线程最佳实践 给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。 避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。 多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断 优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。 多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。 如何避免死锁？ Java多线程中的死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。 Java中的同步集合与并发集合有什么区别？ 同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在 多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分 区等现代技术提高了可扩展性。 什么是线程池？ 为什么要使用它？ 创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时 候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短 的任务的程序的可扩展线程池）。 ","date":"2020-11-15","objectID":"/java%E5%9F%BA%E7%A1%80/:55:0","tags":null,"title":"Java基础","uri":"/java%E5%9F%BA%E7%A1%80/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 KL散度用来做什么？ KL散度的用途：比较两个概率分布的接近程度。 在统计应用中，我们经常需要用一个简单的，近似的概率分布f∗ 来描述一个复杂的概率分布f。这个时候，我们需要一个量来衡量我们选择的近似分布 f∗相比原分布f究竟损失了多少信息量，这就是KL散度起作用的地方。 熵 为了更好的理解KL散度，在这里首先抛出熵的概念。在信息论这门学科中，一个很重要的目标就是量化描述数据中含有多少信息。 为此，提出了熵的概念，记作H，一个概率分布所对应的熵表达如下： $$ H= −\\sum_{i=1}^N=p(x_i)⋅\\log (p(x_i)) $$ 果我们使用 log⁡2 作为底，熵可以被理解为：我们编码所有信息所需要的最小位数。 需要注意的是：通过计算熵，我们可以知道信息编码需要的最小位数，却不能确定最佳的数据压缩策略。怎样选择最优数据压缩策略，使得数据存储位数与熵计算的位数相同，达到最优压缩，是另一个庞大的课题。 KL散度的计算 现在，我们能够量化数据中的信息量了，就可以来衡量近似分布带来的信息损失了。KL散度的计算公式其实是熵计算公式的简单变形,在原有概率分布 p 上，加入我们的近似概率分布 q，计算他们的每个取值对应对数的差： $$ D_{KL}(p||q)= ∑_{i=1}^Np(x_i)⋅(log(p(x_i))−log(q(x_i)))\\ =∑_{i=1}^Np(x_i)⋅log \\frac{p(x_i)}{q(x_i)} $$ 换句话说，KL散度计算的就是数据的原分布与近似分布的概率的对数差的期望值。 在对数以2为底时，log2 ，可以理解为“我们损失了多少位的信息” KL散度的连续定义： $$ D_{KL}(p||q)=\\int p(x)⋅log \\frac{p(x)}{q(x)}dx $$ ","date":"2020-11-15","objectID":"/kl%E6%95%A3%E5%BA%A6/:0:0","tags":null,"title":"KL散度","uri":"/kl%E6%95%A3%E5%BA%A6/"},{"categories":["深度学习论文阅读笔记"],"content":"该文章实现了不同背景下多条件人物图像生成。 该文提出了一个概念：图像生成（image generation）和图像合成（image compositing） Introduction 条件人物图像生成可以分为两个阶段： conditional generation phase : 在几何条件的基础上，生成人物的细粒度纹理 adaptive compositing phase : 根据不同的背景调整生成人物的色调，使得生成的人物能够和背景更加的融合。 对于conditional generation phase，以三个条件作为输入：geometry、pattern（灰度纹理）和color，对应到具体的输入为parsing mask、Gaussian noise以及multi-valued color attributes。其中patteern 和 color是抽象的并且与geometry相关。因此条件人物图像生成可以视为抽象条件的视觉具体化。 另一方面，adaptive compositing phase 需要将生成的人物图像更好的与背景相融合。 ​ MISC包含两个模块： conditional person generation model spatially-adaptive image composition model 其中conditional person generation model ： 对于pattern condition ，将它视为Gaussian noise，引入一个条件归一化层：GAIN，通过Gaussian 来调剂激活值。 对于color condition，使用bipartite network project method 来讲attribute 映射到人物相应的几何位置上，并使用预训练的cross-modality similarity model 来增强attribute embedding的语义意义。 而对于spatially-adaptive image composition model： 利用生成的人物图像和提供背景的图像，来为前景人物图像推断出每一个像素的颜色转换参数， Conditional person image synthesis conditional person generation model： $$ \\hat{y}=F^G(x) $$ 其中$x$表示输入的条件。生成的$\\hat{y}$可以被解耦为$\\hat{y}^f$和$\\hat{y}^b$ spatially-adaptive image composition model： $$ (\\rho ,\\tau)=F^C(\\hat{y}^f,y^b) $$ 其中$y^b$是背景图像。 通过仿射参数$(\\rho , \\tau)$可以将$\\hat{y}^f$与$y^b$进行更好的融合（将生成的人物图像与背景更好的融合）： $$ y=m \\odot y^f+(1-m)y^b $$ ","date":"2020-11-15","objectID":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/:0:0","tags":null,"title":"MISC: Multi-condition Injection and Spatially-adaptive Compositing for Conditional Person Image Synthesis","uri":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"Conditional generation $F^G$的输入$x$包括了geometry $x^g$、pattern $x^p$以及color $x^c$。 $x^g \\in \\mathbb{L}^{N_g \\times H \\times W}$ 表示body part parsing mask 。其中$\\mathbb{L}\\in { 0,1}$ $x^p \\sim \\mathcal{N}(0,1)$ 表示Gaussian noise vector。 $x^c \\in \\mathbb{L}^{N_c \\times N_v}$ 表示multi-valued attributes, 其中$\\mathbb{L}\\in { 0,1}$，$N_c$和$N_v$表示the number of attributes $F^G$是多模块的叠加： $$ h_{i+1}=F^G_{i+1}(h_i,x_i^g,e^p,e^c) $$ $F^G$的目标是实现抽象条件$x^p,x^c$的视觉具体化，为了实现这一目标需要实现合理的条件注入机制。 ","date":"2020-11-15","objectID":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/:1:0","tags":null,"title":"MISC: Multi-condition Injection and Spatially-adaptive Compositing for Conditional Person Image Synthesis","uri":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"Pattern injection GAIN：结合了AdaIN和SPADE的优势。希望GAIN能够在$x_g$的指导下自适应的控制不同身体部位的texture uniformity 。 令$\\hat{h}=\\in \\mathbb{R}^{K\\times \\hat{H} \\times \\hat{W}}$ 表示AdaIN的输入特征，该特征被分为两个部分$k_1-th$和$k_2-th$，分别通过两组参数来控制：$\\gamma[k_1],\\beta[k_1]$以及$\\gamma[k_2],\\beta[k_2]$ 。如果这两个部分属于相同的身体部分，我们希望这两个部分有uniform textures，也就是有限制： $$ (\\gamma[k_1]\\sim \\gamma[k_2])\\land (\\beta[k_1]\\sim\\beta[k_2]) $$ 注意到这种限制不应该影响到无关身体部位的激活值，所以一个限制应该以空间自适应的方式应用到每一个通道上。因此引入了两个空间自适应门： $$ g^\\gamma\\in \\mathbb{M}^{K \\times \\tilde{H} \\times \\tilde{W}} \\ for \\ \\gamma\\in \\mathbb{R}^K \\ g^\\beta\\in \\mathbb{M}^{K \\times \\tilde{H} \\times \\tilde{W}} \\ for \\ \\beta\\in \\mathbb{R}^K $$ 其中$\\mathbb{M}\\in [0,1]$,通过“门”操作将$\\gamma$，$\\beta$变为： $$ \\bar{\\gamma}\\in \\mathbb{R}^{K \\times \\tilde{H} \\times \\tilde{W}} \\ \\bar{\\beta}\\in \\mathbb{R}^{K \\times \\tilde{H} \\times \\tilde{W}} $$ 采用SPADE来计算$g^\\gamma$和$g^\\beta$。 ","date":"2020-11-15","objectID":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/:1:1","tags":null,"title":"MISC: Multi-condition Injection and Spatially-adaptive Compositing for Conditional Person Image Synthesis","uri":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"Color injection 为了减轻由uniform injection 带来的”learning burdens“，我们需要准备和注入一个spatially-specific attribute condition $e^{gc}\\in \\mathbb{R}^{K \\times H \\times W}$,这可以分为两个部分： 每一个身体部位专有属性嵌入，例如$e^c\\in \\mathbb{R}^{K \\times N_g}$,其中$K$表示嵌入的维度，$N_g$表示身体部位的个数。 geometry condition $x^g \\in \\mathbb{N }^{N_g\\times H\\times W}$ 表示身体部位和空间位置的相关性 随后可以通过bipartie network 获取$e^{gc}$ : $$ e^{gc}=e^c \\otimes x^g $$ 通过在每一阶段将$e^{g,c}$和输入的特征相叠加来惊醒color injection。 如何获取$e^c$ : 根据二进制属性内在关联将二进制颜色属性变为multi-valued attributes $x^c\\in \\mathbb{L}^{N_c\\times N_v}$ 利用$Enc^C$ 将每一个multi-valued attributes编码为向量，$\\hat{e}^c\\in \\mathbb{R}^{K\\times N_c}$ 。 确定身体部位和属性间的关联矩阵 $A\\in \\mathbb{L}^{N_g\\times N_c} $ ","date":"2020-11-15","objectID":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/:1:2","tags":null,"title":"MISC: Multi-condition Injection and Spatially-adaptive Compositing for Conditional Person Image Synthesis","uri":"/misc_-multi-condition-injection-and-spatially-adaptive-compositing-for-conditional-person-image-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"map 函数 #map 函数 接收一个函数和一个序列 \u003e\u003e\u003e def f(x): ... return x * x ... \u003e\u003e\u003e r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003e\u003e\u003e list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] filter 函数 #filter 函数 #filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 匿名函数 #匿名函数 lambda x:x*x #等价于 def f(x): return x*x #关键字lambda表示匿名函数，冒号前面的x表示函数参数。 #匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 函数的装饰器 #首先需要明确函数可以作为参数传递给其他函数 #函数也可以作为其他函数的返回值 #装饰器的作用就是为已经存在的对象添加额外的功能。 #简单的装饰器使用 def use_logging(func): def wrapper(): print('nihao') return func() # 把 foo 当做参数传递进来时，执行func()就相当于执行foo() return wrapper def foo(): print('i am foo') foo = use_logging(foo) # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于 foo = wrapper foo() # 执行foo()就相当于执行 wrapper() \u003e\u003enihao i am foo # @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。 def use_logging(func): def wrapper(): print('nihao') return func() return wrapper @use_logging def foo(): print(\"i am foo\") foo() \u003e\u003enihao i am foo #如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。 #装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。 #可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如： def foo(name): print(\"i am %s\" % name) 我们可以在定义 wrapper 函数的时候指定参数： def use_logging(func): def wrapper(*arg,**kw): print('nihao') return func(*arg,**kw) return wrapper @use_logging def foo(*arg,**kw): print(\"i am foo\") foo() #装饰器还有更大的灵活性，例如带参数的装饰器 def use_logging(level): def decorator(func): def wrapper(*args, **kwargs): if level == \"warn\": print('nihao') elif level == \"info\": print('china') return func(*args) return wrapper return decorator @use_logging(level=\"warn\") def foo(name='foo'): print(\"i am %s\" % name) foo() \u003e\u003enihao i am foo #上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=\"warn\")调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。 @use_logging(level=\"warn\") 等价于 @decorator #没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。 class Foo(object): def __init__(self, func): self._func = func def __call__(self): print ('class decorator runing') self._func() print ('class decorator ending') @Foo def bar(): print ('bar') bar() \u003e\u003eclass decorator runing bar class decorator ending #使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子： # 装饰器 def logged(func): def with_logging(*args, **kwargs): print (func.__name__) # 输出 'with_logging' print (func.__doc__ ) # 输出 None return func(*args, **kwargs) return with_logging # 函数 @logged def f(x): \"\"\"does some math\"\"\" return x + x * x logged(f) f.__name__ \u003e\u003e'with_logging' print(f.__doc__) \u003e\u003eNone #不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了 #wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。 from functools import wraps def logged(func): @wraps(func) def with_logging(*args, **kwargs): print (func.__name__) # 输出 'f' print (func.__doc__ ) # 输出 'does some math' return func(*args, **kwargs) return with_logging @logged def f(x): \"\"\"does some math\"\"\" return x + x * x f(2) \u003e\u003ef does some math 6 函数的参数 #函数的参数 #位置参数 def f(x): return x*x #默认参数,默认参数必须指向不变对象 def power(x, n=2): s = 1 while n \u003e 0: n = n - 1 s = s * x return s #可变参数 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum ##参数numbers接收到的是一个list \u003e\u003e\u003e nums = [1, 2, 3] \u003e\u003e\u003e calc(*nums) 14 #关键字参数 #关键字参数在函数内部自动组装为一个dict。 def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) #可以只传入必选参数 \u003e\u003e\u003e person('Michael', 30) name: Michael age: 30 other: {} #也可以传入任意个参数 \u003e\u003e\u003e person('Bob', 35, city='Beijing') name: Bob age: 35 other: {'city': 'Beijing'} \u003e\u003e\u003e person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} #命名关键字参数 #如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： def person(name, age, *, city, job): print(name, age, city, job) #和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 \u003e\u003e\u003e person('Jack', 24, city='Beijing', job='Engineer') Jack 24 Beijing Engineer #如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： def per","date":"2020-11-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"python学习笔记","uri":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"元组 a. 概念：元组是一种有序集合 b. 元祖和列表的区别： ​ 格式：元祖(),列表[] ​ 列表中的元素可以增删，元组中的元素不能进行修改（不能够修改地址，但是能够修改内容） t=(1,2,3,[4,5,6]) #创建元组 l=[1,2,3,[4,5,6]] #创建列表 l.pop() #可以对列表进行删除 #此时的l为 #Out[21]: [1, 2, 3] l.append(4) #可以对列表增加元素 #此时的l为 #Out[23]: [1, 2, 3, 4] #但是不能对元组增删元素，但可以修改内容 t[3][0]=0 #此时的t为 #Out[33]: (1, 2, 3, [0, 5, 6]) c. 元组和列表的相同点： ​ 都是一种容器，可以同时存储不同类型的数据 d. 元组和列表的创建 列表：list=[parm1,parm2,...] 元组：tuple=(parm1,parm2) #注意：和列表类似，在元组中可以存储重复元素，同时存储不同类型的数据； e. 元组的访问 ​ 获取值：语法如：元组名称[索引] #1.创建空元组 tuple1 = () #2.创建带有元素的元组 tuple2 = (10,20,30) #1.获取元组值 tuple1 = (10,20,30,40,50) print(tuple1[1]) #法一：获取元组中的最后一个值：从前向后获取 print(tuple1[4]) #法二：获取元组中的最后一个值：从后向前获取，-1表示最后一个元素 print(tuple1[-1]) #2.修改元素值:不支持元素的修改，指的是不能更改地址，可以修改内容，此处特殊情况 tuple2 = (1,3,43,5,[54,54,5]) print(tuple2) list1 = tuple2[4] list1[1] = 100 print(tuple2) #3.删除元组 del tuple2 f. 元组的操作 ​ f1. 元组截取【切片】：tuple1[2:4] #截取2到4的元素，包前不包后，包头不包尾 ​ tuple1[2:] #截取索引为2以后的元素，包括元素2 ​ tuple1[:4] #截取从开头到4的元素，不包括元素4 ​ f2. 获取元组中元素的个数： len(tuple1) ​ f3. 获取元组中元素的最大值和最小值： max(tuple1)和min(tuple1) ​ f4. 元组和列表之间的相互转换：取长补短，转换前后不是以前的元组了 list1 = list(tuple1) tuple2 = tuple(list2) ​ f5. 元组遍历 for i,element in enumerate(tuple1): print(i,element) ","date":"2020-11-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"python学习笔记","uri":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"字典 采用key:value的方式进行存储，和Java中的map一样 key是唯一的 a. 字典的创建 dict={\"zhangsan\":90,\"lisi\":100} b. 字典的访问 ​ 通过Key获取Value dict={\"zhangsan\":90,\"lisi\":100} score=dict[\"zhangsan\"] c. 字典的操作 ​ c1. 添加 ​ 如果键存在，则将对应键的值进行修改；如果键不存在，则添加新的键值对 ​ c2. 删除 ​ 删除指定的key，对应的value也会删除掉 ​ c3. 遍历 dict1 = {\"zhangsan\":60,\"jack\":90,\"tom\":80} #通过key获取value for key in dict1: ...: value=dict1[key] ...: print(key,value) ...: zhangsan 60 jack 90 tom 80 #只获取value list=dict1.values() for value in list: ...: print(value) ...: 60 90 80 # for i,key in enumerate(dict1): ...: value=dict1[key] ...: print(i,key,value) ...: 0 zhangsan 60 1 jack 90 2 tom 80 #同时获得key,value for key,value in dict1.items(): ...: print(key,value) ...: zhangsan 60 jack 90 tom 80 list切片 \"\"\" 使用模式: [start:end:step] 其中start表示切片开始的位置,默认是0 end表示切片截止的位置(不包含),默认是列表长度 step表示切片的步长,默认是1 当start是0时,可以省略;当end是列表的长度时,可以省略. 当step是1时,也可以省略,并且省略步长时可以同时省略最后一个冒号. 此外,当step为负数时,表示反向切片,这时start值应该比end值大. 注意:切片操作创建了一个新的列表. \"\"\" 参考 view view()的作用相当于numpy中的reshape，重新定义矩阵的形状。 一、例1 普通用法： import torch v1 = torch.range(1, 16) v2 = v1.view(4, 4) 123 其中v1为116大小的张量，包含16个元素。 v2为44大小的张量，同样包含16个元素。注意view前后的元素个数要相同，不然会报错。 二、例2 参数使用-1 import torch v1 = torch.range(1, 16) v2 = v1.view(-1, 4) 123 和图例中的用法一样，view中一个参数定为-1，代表动态调整这个维度上的元素个数，以保证元素的总数不变。因此两个例子的结果是相同的。 ","date":"2020-11-15","objectID":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"python学习笔记","uri":"/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"tensor的一些性质 import torch x=torch.tensor(2.5) print(x.dtype) \u003e\u003etorch.float32#torch默认的数据类型为float32 数据类型包括： #如何将tensor的数据类型转换？ #在Tensor后加 .long(), .int(), .float(), .double()等即可 x.half() \u003e\u003etensor(2.5000, dtype=torch.float16) #将numpy.ndarray转换为tensor: a=numpy.array([1,2,3]) a.dtype \u003e\u003edtype('int32') t=torch.from_numpy(a) t \u003e\u003etensor([1, 2, 3], dtype=torch.int32) #torch.zeros_like(input)-\u003e生成一个与input相同size的零矩阵,同理还有torch.ones_like(input);torch.randn_like(input) input=torch.ones(2,3) torch.zeros_like(input) \u003e\u003etensor([[0., 0., 0.], [0., 0., 0.]]) #torch.arange() 和torch.range()的区别 #Note that arange generates values in [start; end), not [start; end]. torch.arange(1,4) \u003e\u003etensor([1, 2, 3]) torch.range(1,6) \u003e\u003etensor([1., 2., 3., 4., 5., 6.]) #torch.full(size,fill_value) #Returns a tensor of size size filled with fill_value.常用于GAN训练中的真假标签赋值 torch.full((2,3),3.1415) \u003e\u003etensor([[3.1415, 3.1415, 3.1415], [3.1415, 3.1415, 3.1415]]) torch.full((2,),3.14)#注意size的表达形式（*，*）或者是（*，*，*）；不能使用（*） \u003e\u003etensor([3.1400, 3.1400]) #torch.cat(tensor,dim) #将输入的张量在指定的维度上进行叠加 x=torch.ones(2,2,) torch.cat((x,x),0) \u003e\u003etensor([[1., 1.], [1., 1.], [1., 1.], [1., 1.]]) torch.cat((x,x),1) \u003e\u003etensor([[1., 1., 1., 1.], [1., 1., 1., 1.]]) #torch.split(tensor,split_size,dim) #将输入张量在指定维度上分为特定的份 a=torch.randn(4,4) a \u003e\u003etensor([[-1.0159, 0.2249, -0.0083, 0.4495], [-0.5427, 0.0253, 0.3100, -1.8563], [ 0.6721, -0.5261, -0.1104, 1.5312], [ 0.4096, -1.4238, 0.5939, 0.2700]]) b=torch.split(a,2,0) b \u003e\u003etensor([[-1.0159, 0.2249, -0.0083, 0.4495], [-0.5427, 0.0253, 0.3100, -1.8563], [ 0.6721, -0.5261, -0.1104, 1.5312], [ 0.4096, -1.4238, 0.5939, 0.2700]]) #torch.reshape(input,shape) #将input重构为shape的形状 a=torch.randn(4,4) a=torch.reshape(a,(2,8)) a.shape \u003e\u003etorch.Size([2, 8]) a=torch.reshape(a,(-1,)) #当某一维度为-1时，这一维度的形状不用管，根据input和另一维度计算形状。当另一维度的表达式没有时，就讲input按照“某一维度为-1”的维度排列input a.shape \u003e\u003etorch.Size([16]) a=torch.reshape(a,(-1,8)) a.shape torch.Size([2, 8]) #torch.squeeze(input,dim) #将输入张量维度为1的size去掉 x=torch.randn(2,1,3,1,4) x.shape \u003e\u003etorch.Size([2, 1, 3, 1, 4]) y=torch.squeeze(x)#如果不指定维度就会将所有维度为1的size去掉，如果加了维度，只会在指定维度上 y.shape \u003e\u003etorch.Size([2, 3, 4]) #torch.unsqueeze(input,dim) #在指定维度插入size=1 x=torch.randn(4) x.shape \u003e\u003etorch.Size([4]) torch.unsqueeze(x,0).shape \u003e\u003etorch.Size([1, 4]) torch.unsqueeze(x,1).shape \u003e\u003etorch.Size([4, 1]) pytorch 自动微分 #autograd 包是 PyTorch 中所有神经网络的核心.该 autograd 软件包为 Tensors 上的所有操作提供自动微分 #####动态计算图（DCG）-\u003e由autograd动态生成。这个图的叶节点是输入张量，根节点是输出张量。梯度是通过跟踪从根到叶的图形，并使用链式法则将每个梯度相乘来计算的。 tensor(data, dtype=None, device=None, requires_grad=False) -\u003e Tensor #参数: # data： (array_like): tensor的初始值. 可以是列表，元组，numpy数组，标量等; # dtype： tensor元素的数据类型 # device： 指定CPU或者是GPU设备，默认是None # requires_grad：是否可以求导，即求梯度，默认是False，即不可导的 # 注意data必须为浮点数才可导 data:输入数据 requires_grad：这个成员(如果为true)开始跟踪所有的操作历史，并形成一个用于梯度计算的后向图。 grad: grad保存梯度值。如果requires_grad 为False，它将持有一个None值。即使requires_grad 为真，它也将持有一个None值，除非从其他节点调用.backward()函数。例如，如果你对out关于x计算梯度，调用out.backward()，则x.grad的值为∂out/∂x。 grad_fn：这是用来计算梯度的向后函数。 在调用backward()时，只计算requires_grad和is_leaf同时为真的节点的梯度。 当打开 requires_grad = True时，PyTorch将开始跟踪操作，并在每个步骤中存储梯度函数，如下所示： Backward函数实际上是通过传递参数(默认情况下是1x1单位张量)来计算梯度的，它通过Backward图一直到每个叶节点，每个叶节点都可以从调用的根张量追溯到叶节点。然后将计算出的梯度存储在每个叶节点的.grad中。请记住，在正向传递过程中已经动态生成了后向图。backward函数仅使用已生成的图形计算梯度，并将其存储在叶节点中。 #参考：https://blog.csdn.net/qq_27825451/article/details/89393332 ###求导的核心函数-torch.autograd.backward backward(gradient=None, retain_graph=None, create_graph=False) #在pytorch中，默认是标量对标量求导或者是标量对向量求导 #向量对向量求导-\u003e当使用向量对向量求导时需要设置gradient的参数 #一个计算图在进行反向求导之后，为了节省内存，这个计算图就销毁了。 如果你想再次求导，就会报错。那怎么办呢？遇到#这种问题，我们可以通过设置 retain_graph=True 来保留计算图 #标量对标量求导 x=torch.tensor(3.0,requires_grad=True) y=torch.pow(x,2) #判断x,y是否是可以求导的 print(x.requires_grad) print(y.requires_grad) #求导，通过backward函数来实现 y.backward() #查看导数，也即所谓的梯度 print(x.grad) #标量对向量求导 #在深度学习中，损失函数一般为标量，即将所有项的损失相加。而输入一般为多维张量 #例:1： #x-\u003e(1,3),w-\u003e(3,1) #输出y是一个标量 #创建一个多元函数，即Y=XW+b=Y=x1*w1+x2*w2*x3*w3+b，x不可求导，W,b设置可求导 X=torch.tensor([1.5,2.5,3.5],requires_grad=False) W=torch.tensor([0.2,0.4,0.6],requires_grad=True) b","date":"2020-11-15","objectID":"/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"pytorch学习笔记","uri":"/pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"GAN的可解释性研究：从latent space出发 latent space的优点： 语义最高级-包含丰富的语义信息 维度比较低-比较好控制 可通过解码器生成image-可唯一确定image assumptions code连续变化时，生成图片也在连续变化-不会发生跳变 基于上一观点的基础上，latent space线性可分-可认为latent space中有一个超平面，latent code越过超平面后，相应的属性会发生变化。 ","date":"2020-11-15","objectID":"/semantic-hierarchy-emerges-in-deep-generative-representations-for-scene-synthesis/:0:0","tags":null,"title":"Semantic Hierarchy Emerges in Deep Generative Representations for Scene Synthesis","uri":"/semantic-hierarchy-emerges-in-deep-generative-representations-for-scene-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"SPADE 为一个新颖的网络归一化层。 SPADE和AdaIN十分的相似，不同的是利用了batch norm进行归一化，类似的使用segmentation mask来提取调剂参数。这能够更好的保存segmentation mask的语义信息。 其中$\\gamma_{c,y,x}^i(m)$和$\\beta_{c,y,x}^i(m)$是归一化层的调剂参数，它与输入语义图有关并会随着位置$(y,x)$变化 SPADE生成器网络结构 ","date":"2020-11-15","objectID":"/semantic-image-synthesis-with-spatially-adaptive-normalization/:0:0","tags":null,"title":"Semantic Image Synthesis with Spatially-Adaptive Normalization","uri":"/semantic-image-synthesis-with-spatially-adaptive-normalization/"},{"categories":["深度学习论文阅读笔记"],"content":"why does the SPADE work better? 传统的生成器以segmentation mask（有不同的标签）直接作为网络的输入，经过卷积层和归一化层处理。无论输入的segmentation mask的标签的怎样的，当卷积层的输出经过归一化层处理后，其均值为0，因此其语义信息就会丢失。 而在SPADE中，语义图经过卷积操作映射成为调剂参数，而没有经过归一化层处理。仅仅只有上一层的激活值被归一化了。因此SPADE能够更好的保存语义信息。 ","date":"2020-11-15","objectID":"/semantic-image-synthesis-with-spatially-adaptive-normalization/:0:1","tags":null,"title":"Semantic Image Synthesis with Spatially-Adaptive Normalization","uri":"/semantic-image-synthesis-with-spatially-adaptive-normalization/"},{"categories":["深度学习论文阅读笔记"],"content":" two-stage spatial-transformer - to capture fine details in the geometric iwarping stage conditional segmentation mask generation module - to prevent garment textures from bleeding onto skin and other areas. perceptual geometric matching loss - to impove warping output duelling triplet loss strategy - to improve output from the translation network ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:0:0","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"inputs $I_P$ : try-on cloth image $I_{priors}$ : 19 channel pose and body-shape map $I_m$ : target model image ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:1:0","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Coarse2Fine Warping 目标：将$I_p$进行warp操作，与$I_m$的姿态和形状进行对齐。 基于STN进行warp操作 ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:2:0","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Tackling Occlusion and Pose-variation 作者认为若要进行准确的warping 操作需要考虑一下两点： Large variations in shape or pose between the try- on cloth image and the corresponding regions in the model image. Occlusions in the model image. For example, the long hair of a person may occlude part of the garment near the top. 基于STN进行warp操作: 第一阶段（Coarse）以$I_p$和$I_{priors}$作为输入，产生的参数$\\theta$,对$I_p$进行warp操作，产生$I_{stn}^0$ 第二阶段（fine）以$I_{stn}^0$和$I_{priors}$作为输入，产生参数$\\Delta \\theta$，以$\\theta+\\Delta\\theta$对$I_p$进行warp操作，产生$I_{stn}^1$ ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:2:1","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Perceptual Geometric Matching Loss $$ L_{warp}=\\lambda_1L_s^0+\\lambda_2L_s^1+\\lambda_3L_{pgm} $$ 其中： $$ L_S^0=| I_{gt}-I_{stn}^0 | \\ L_S^1=| I_{gt}-I_{stn}^1 | $$ $$ L_{pgm}=\\lambda_4L_{push}+\\lambda_5L_{align} $$ 又 $$ L_{push}=k*L_s^1-| I_{stn}^1-I_{stn}^0 | $$ 这是为了确保$I_{stn}^1$比$I_{stn}^0$更加接近$I_{gt}$,$I_{gt}$表示目标服装。 $$ V^0=VGG(I_{stn}^0)-VGG(I_{gt})\\ V^1=VGG(I_{stn}^1)-VGG(I_{gt})\\ \\ L_{align}=(CosineSimilarity(V^0,V^1)-1)^2 $$ 实际上是采用了余弦距离进行度量，目的是保证向量$V^0$和$V^1$更加的接近。同时最小化$L_{align}$能够促进最小化$L_{push}$。 ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:2:2","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Texture Transfer ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:3:0","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Conditional Segmentation Mask Prediction 现有方法的关键问题是不能够准确的遵守clothing product 和skin的界限。会出现clothing product pixels渗色到skin pixel，或者是skin pixel渗色到clothing product pixels。在自遮挡的情况下，skin pixels可能会被完全的替代掉。当try-on image和clothing in the model image上的形状不一致时，这种情况尤为严重。同时当target model有复杂的姿势时也会这种情况。 输入为$I_{priors}$、$I_p$ 输出为$M_{exp}$ –\u003e “expected ” segmentation mask.target model is wearing the try-on cloth. 注意损失函数的使用。 损失函数为加权交叉熵损失函数。在skin和background处增加了权重。在skin处增加权重能够更好的解决自遮挡问题。在background处增加权重能够阻止skin pixels渗色到background。 ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:3:1","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Segmentation Assisted Texture Translation 输入为： The warped product image $I_{stn}^1$ The expected seg. mask $M_{exp}$ Pixels of $I_m$ for the unaffected regions, (Texture Trans- lation Priors in Figure 3). E.g. face and bottom cloth, if a top garment is being tried-on. 输出： an RGB rendered person image $I_{rp}$ a composition mask $M_{cm}$ -\u003e 最终的try-on image: $$ I_{try-on}=M_{cm}*I_{stn}^1+(1-M_{cm})*I_{rp} $$ 损失函数： $$ L_{tt}=L_{l1}+L_{percep}+L_{mask}\\ L_{l1}=| I_{try-on}-I_m |\\ L_{percep}=| VGG(I_{try-on})-VGG(I_m) |\\ L_{mask}=| M_{cm}-M_{gt}^{cloth} | $$ 注意此处的训练策略： 前K步使用$L_{tt}$进行训练，得到一个较为合理的结果。 之后再用$L_{tt}$加上triplet loss进行细粒度挖掘。 ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:3:2","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"Duelling Triplet Loss Strategy 其中$I_{try-on}^{i_{prev}}$表示上一步的输出，其作为negative ","date":"2020-11-15","objectID":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/:3:3","tags":null,"title":"SieveNet: A Unified Framework for Robust Image-Based Virtual Try-On","uri":"/sievenet_-a-unified-framework-for-robust-image-based-virtual-try-on/"},{"categories":["深度学习论文阅读笔记"],"content":"target parsing:在特定的segmentation 区域进行纹理的渲染 warping block ：align the image features 通过仿射变换和TSP计算出transformation map用于warping condition image以减缓姿态不对齐问题 第一阶段生成目标姿态的part segmentation map 第二阶段首先训练geometric matcher 来估计condition segmentation和synthesized segmentation的transformation 参数。基于这个参数将condition image 的feature map进行warping，并渲染到target segmentation map warping GAN的好处：1）如果存在大的姿态变换就会进行大的transformation，小的姿态变形就会进行小的transformation 2）在feature-level进行warping，能够合成更加真实的图片 3）warping block 能够通过attention layers自动选择有效的feature map 进行warping Stage I: Pose-Guided Parsing 为了在part-level上学习condition image到target pose之间的映射，引入了pose-guide parser. Geometric Matcher 将仿射变换和TPS相结合，通过孪生卷积神经网络来获得transformation map。 首先估计condition segmentation 和synthesized segmentation之间的仿射参数，基于仿射变换参数，估计经过仿射变换后的warping result和target parsing之间的TPS参数。 提取出来的transformation map用于warping条件图像的feature，减缓不对齐问题。 Soft-gatedWarping-Block 网络结构 消融实验 ","date":"2020-11-15","objectID":"/soft-gatedwarping-gan-for-pose-guided-person-image-synthesis/:0:0","tags":null,"title":"Soft-GatedWarping-GAN for Pose-Guided Person Image Synthesis","uri":"/soft-gatedwarping-gan-for-pose-guided-person-image-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":"IS参考 ","date":"2020-11-15","objectID":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/:0:0","tags":null,"title":"SSIM，IS等生成图像评价指标","uri":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/"},{"categories":["深度学习论文阅读笔记"],"content":"Inception Score 的基本原理 众所周知，评价一个生成模型，我们需要考验它两方面性能：1. 生成的图片是否清晰 2. 生成的图片是否多样。生成的图片不够清晰，显然说明生成模型表现欠佳；生成的图片够清晰了，我们还要看是不是能生成足够多样的图片，有些生成模型只能生成有限的几种清晰图片，陷入了所谓 mode collapse，也不是好的模型。 Inception Score 是这样考虑这两个方面的： 清晰度：把生成的一张图片 输入 Inception V3 中，将输出1000维的向量 ，向量的每个维度的值对应图片属于某类的概率。对于一个清晰的图片，它属于某一类的概率应该非常大，而属于其它类的概率应该很小（这个假设本身是有问题的，有可能有些图片很清晰，但是具体属于哪个类却是模棱两可的）。用专业术语说， 的熵应该很小（熵代表混乱度，均匀分布的混乱度最大，熵最大）。 多样性：如果一个模型能生成足够多样的图片，那么它生成的图片在各个类别中的分布应该是平均的，假设生成了 10000 张图片，那么最理想的情况是，1000类中每类生成了10张。转换成术语，就是生成图片在所有类别概率的边缘分布 熵很大（均匀分布）。具体计算时，可以先用生成器生成 N 张图片，然后用公式 (1) 的经验分布来代替： 综合上面两方面，Inception Score 的公式为： ：仅仅是为了好看，没有具体含义 ：表示从生成器中生成图片 ：把生成的图片 输入到 Inception V3，得到一个 1000 维的向量 ，也就是该图片属于各个类别的概率分布。IS 提出者的假设是，对于清晰的生成图片，这个向量的某个维度值格外大，而其余的维度值格外小（也就是概率密度图十分尖）。 ：N个生成的图片（N 通常取5000），每个生成图片都输入到 Inception V3 中，各自得到一个自己的概率分布向量，把这些向量求一个平均，得到生成器生成的图片全体在所有类别上的边缘分布，见公式 (1)。 ：对 和 求 KL 散度。KL 散度离散形式的公式如下： KL 散度用以衡量两个概率分布的距离，它是非负的，值越大说明这两个概率分布越不像。但这个距离不是对称的，观察公式， 很大 很小的地方对 KL 距离贡献很大，而 很小 很大的地方对 KL 距离的贡献很小。我们预期 的某个维度值很大，而 总体均匀，因此需要把 放在公式 (2) 中双竖线的前面。放到后面可能会造成 的极端值被忽略，而正是这个极端值的存在告诉了我们这个生成的图片是否清晰。 综合起来，只要 和 的距离足够大，就能证明这个生成模型足够好。因为前者是一个很尖锐的分布，后者是一个均匀分布，这俩距离本就应该很大。 公式 (2) 很不直观，在实际操作中可以改成如下形式： 实际操作中，先用生成的大量样本代入公式 (1)，求出 ，然后再对每个样本求出 ，计算它和 的 KL 散度，最后求平均，再算一下指数即可。（IS越大越好） IS存在的问题 首先回顾一下 Inception Score 的两个假设： 越真实的图片，输入预训练的 Inception V3 ，分类的结果越明确。即在1000维的输出向量中，某一维很大，其余维很小。也就是说，输出的概率分布函数图越尖锐。 生成的图片多样性越强，那么类别的边缘分布就越平均，边缘分布的概率函数图像就越平整。 Inception Score 通过计算 1 和 2 中两个概率分布的散度，来衡量生成模型的表现。 我们乍一看这两条假设，不难发现最明显的两个问题： 针对第一个假设，是否越真实的图片，分类网络输出的概率分布函数越尖锐？显然是不见得的，如果某一个物体所属的类别在分类网络中并不存在，那么它的分布函数依然尖锐吗？ 针对第二个假设，是否输出图片均匀地覆盖每个类别，就意味着生成模型不存在 mode collapse？Inception net 输出 1000 类，假设生成模型在每类上都生成了 50 个图片，那么生成的图片的类别边缘分布是严格均匀分布的，按照 Inception Score 的假设，这种模型不存在 mode collapse，但是，如果各类中的50个图片，都是一模一样的，仍然是 mode collapse。Inception Score 无法检测这种情况。 除了上面最直观的两个硬伤，本文开头提到的文章中对 Inception Score 缺点做了详细分析。其中涉及到：使用 IS 时，分类模型应该和生成模型在同一个训练集上训练，否则分类模型计算的边缘分布将不准确，而分类模型对单个图片的预测，也将不能真实反映图片的清晰程度。 出现这一问题的本质原因是：计算 IS 时只考虑了生成样本，没有考虑真实数据，即 IS 无法反映真实数据和样本之间的距离，IS 判断数据真实性的依据，源于 Inception V3 的训练集： ImageNet，在 Inception V3 的“世界观”下，凡是不像 ImageNet 的数据，都是不真实的，都不能保证输出一个 sharp 的 predition distribution。 FID参考 ","date":"2020-11-15","objectID":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/:1:0","tags":null,"title":"SSIM，IS等生成图像评价指标","uri":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/"},{"categories":["深度学习论文阅读笔记"],"content":"Fréchet Inception Distance (FID)的基本原理 Fréchet Inception Distance (FID) 则是计算了真实图片和假图片在 feature 层面的距离，因此显得更有道理一点。FID 的公式如下： 众所周知，预训练好的神经网络顶层可以提取图片的高级信息，一定程度能反映图片的本质。因此，FID 的提出者通过预训练的 Inception V3 来提取全连接层之前的 2048 维向量，作为图片的特征。公式 (1) 中： ：真实图片的特征的均值 ：生成的图片的特征的均值 : 真实图片的特征的协方差矩阵 : 生成图片的特征的协方差矩阵 FID 只把 Inception V3 作为特征提取器，并不依赖它判断图片的具体类别，因此不必担心 Inception V3 的训练数据和生成模型的训练数据不同。同时，由于直接衡量生成数据和真实数据的分布之间的距离，也不必担心每个类别内部只产生一模一样的图片这种形式的 mode collapse。完美避开了很多 Inception Score 的缺陷。 综上所述，对比 IS，FID 有如下优点： 生成模型的训练集和 Inception V3 的训练集可以不同。 计算 FID 时同时用到了生成的数据和真实数据，比起 IS 来更灵活。可以理解成，IS 判断真实性与否，是把生成数据和 ImageNet 数据做比较，而 FID 是把生成数据和训练数据做比较，因此更 reasonable。 以优化 FID 为目标，不会产生对抗样本。因为优化的是 lantent space feature，不是最终的输出图片，不会导致最终的生成图片失真。 FID 仍然存在一些和 IS 同样的问题： FID 只是某一层的特征的分布，是否足以衡量真实数据分布与生成数据分布的距离？同时，提出 FID 公式计算的是多元正态分布的距离，显然神经网络提取的特征并不是多元正态分布。 针对同一个生成模型，不同框架下预训练的 Inception V3 算出的 FID 差别是否可以忽略？ FID 无法反映生成模型过拟合的情况，如果某个生成模型只是简单拷贝训练数据，FID 会非常小，认为这是一个完美的生成模型，因此，使用 FID 时同时也要通过别的手段证明生成模型没有过拟合。 FID参考 在计算FID中我们也同样使用inception network网络。我们还是先来简单回顾一下什么是inception network，它就是一个特征提取的深度网络，最后一层是一个pooling层，然后可以输出一张图像的类别。在计算FID时，我们去掉这个最后一层pooling层，得到的是一个2048维的高层特征，以下简称n维特征。我们继续简化一下，那么这个n维特征是一个向量。则有：对于我们已经拥有的真实图像，这个向量是服从一个分布的，（我们可以假设它是服从一个高斯分布）；对于那些用GAN来生成的n维特征它也是一个分布；我们应该立马能够知道了，GAN的目标就是使得两个分布尽量相同。假如两个分布相同，那么生成图像的真实性和多样性就和训练数据相同了。于是，现在的问题就是，怎么计算两个分布之间的距离呢？我们需要注意到这两个分布是多变量的，也就是前面提到的n维特征。也就是说我们计算的是两个多维变量分布之间的距离，数学上可以用Wasserstein-2 distance或者Frechet distance来进行计算。以下简单介绍一下如何计算这个距离。 假如一个随机变量服从高斯分布，这个分布可以用一个均值和方差来确定。那么两个分布只要均值和方差相同，则两个分布相同。我们就利用这个均值和方差来计算这两个单变量高斯分布之间的距离。但我们这里是多维的分布，我们知道协方差矩阵可以用来衡量两个维度之间的相关性。所以，我们使用均值和协方差矩阵来计算两个分布之间的距离。均值的维度就是前面n维特征的维度，也就是n维；协方差矩阵则是n*n的矩阵。 最后，我们可以使用下面的公式计算FID（看这个公式之前务必要记住这个公式的物理意义，毕竟我们不是专门的数学学习者）： 公式中，$T_r$ 表示矩阵对角线上元素的总和，矩阵论中俗称“迹”（trace）。均值为 $\\mu$ 协方差为 $\\Sigma$ 。此外$x$表示真实的图片，$g$是生成的图片。 较低的FID意味着两个分布之间更接近，也就意味着生成图片的质量较高、多样性较好。 FID对模型坍塌更加敏感。相比较IS来说，FID对噪声有更好的鲁棒性。因为假如只有一种图片时，FID这个距离将会相当的高。因此，FID更适合描述GAN网络的多样性。 ","date":"2020-11-15","objectID":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/:2:0","tags":null,"title":"SSIM，IS等生成图像评价指标","uri":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/"},{"categories":["深度学习论文阅读笔记"],"content":"Structural Similarity(SSIM)的基本原理 SSIM 参考 **SSIM（structural similarity）**结构相似性，也是一种全参考的图像质量评价指标，它分别从亮度、对比度、结构三方面度量两幅图像相似性，其值越大越好，最大为1；作为结构相似性理论的实现，结构相似度指数从图像组成的角度将结构信息定义为独立于亮度、对比度的，反映场景中物体结构的属性，并将失真j建模为亮度、对比度和结构三个不同因素的组合；用均值作为亮度的估计，标准差作为对比度的估计，协方差作为结构相似程度的度量。 与传统检测图像质量的方法MSE,PSNR与人眼的实际视觉感知是不一致的，SSIM算法在设计上考虑了人眼的视觉特性，比传统方式更符合人眼视觉感知，MSE或者是PSNR算法，都是对绝对误差的评估，SSIM是一种基于感知的计算模型，它能够考虑到图像的结构信息在人的感知上的模糊变化，该模型还引入了一些与感知上的变化有关的感知现象，包含亮度mask和对比mask，结构信息指的是像素之间有着内部的依赖性，尤其是空间上靠近的像素点。这些依赖性携带着目标对象视觉感知上的重要信息。 SSIM算法的计算公式： 其中$\\mu_x,\\mu_y$分别表示图像X和Y的均值，$\\sigma_x,\\sigma_y$分别表示图像X和Y的方差，$\\sigma_{x,y}$表示图像X和Y的协方差，即 最后把三个函数组合起来，得到SSIM指数函数： ​ 这里，用来调整三个模块间的重要性。 为了得到简化形式，设，其中C1、C2、C3为常数，为了避免分母为0的情况，通常取C1=(K1L)^2, C2=(K2L)^2, C3=C2/2, 一般地K1=0.01, K2=0.03, L=255. 则 即： SSIM取值范围[0,1]，值越大，表示图像失真越小. 在实际应用中，可以利用滑动窗将图像分块，令分块总数为N，考虑到窗口形状对分块的影响，采用高斯加权计算每一窗口的均值、方差以及协方差，然后计算对应块的结构相似度SSIM，最后将平均值作为两图像的结构相似性度量，即平均结构相似性MSSIM： 参考 由SSIM测量系统可得相似度的测量可由三种对比模块组成，分别为：亮度，对比度，结构。接下来我们将会对这三模块函数进行定义。 首先，对于离散信号，我们以平均灰度来作为亮度测量的估计： ​ (1) ​ 亮度对比函数l（x,y）是关于的函数。 ​ 然后，由测量系统知道要把平均灰度值从信号中去除，对于离散信号，可使用标准差来做对比度估量值。 ​ （2） ​ 对比度对比函数c(x,y)就是的函数。 ​ 接下来，信号被自己的标准差相除，结构对比函数就被定义成和的函数。 ​ 最后，三个对比模块组合成一个完整的相似测量函数： ​ （3） ​ ​ S（x,y）应该满足以下三个条件： ​ （1） 对称性：； ​ （2） 有界性：； ​ （3） 最大值唯一性：当且仅当x=y时，S（x,y）=1 。 ​ 现在，我们定义三个对比函数。 ​ 亮度对比函数： ​ （4） ​ 常数是为了避免接近0时造成系统的不稳定。 ​ 特别的，我们选择，L为图像灰度级数，对于8-bit灰度图像，L=255，。公式（4）满足上述三个条件。 ​ 对比度对比函数： ​ （5） ​ 常数，且。公式（5）依然满足上述三个条件。 ​ 结构对比函数： ​ （6） ​ 其中 ​ （7） 最后把三个函数组合起来，得到SSIM指数函数： ​ （8） 这里，用来调整三个模块间的重要性。 为了得到简化形式，设，得到： ​ （9） ","date":"2020-11-15","objectID":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/:3:0","tags":null,"title":"SSIM，IS等生成图像评价指标","uri":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/"},{"categories":["深度学习论文阅读笔记"],"content":"LPIPS的基本原理 LPIPS computes the distance between the generated images and reference images at the perceptual domain. It indicates the perceptual difference between the input. ","date":"2020-11-15","objectID":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/:4:0","tags":null,"title":"SSIM，IS等生成图像评价指标","uri":"/ssimis%E7%AD%89%E7%94%9F%E6%88%90%E5%9B%BE%E5%83%8F%E8%AF%84%E5%88%A4%E6%A0%87%E5%87%86/"},{"categories":["深度学习论文阅读笔记"],"content":"网络结构 网络分为三个部分：Localisation net、Grid generator以及Sampler 输入为feature map $U$，输出为feature map $V$。 Localisation net 以$U$为输入，经过卷积层或者全连接层输出仿射参数$\\theta \\in (2,3)$ 假设$\\theta=\\begin{bmatrix}\\theta_{11}\u0026\\theta_{12}\u0026\\theta_{13}\\ \\theta_{21}\u0026\\theta_{22}\u0026\\theta_{23} \\end{bmatrix}$ 在编程实现中最好将$\\theta$进行初始化为$\\begin{bmatrix}1\u00260\u00260\\0\u00261\u00260\\end{bmatrix}$ Grid generator 已知$V$的坐标，使用仿射变换求出$U$中对应的坐标。 在编程实现中需要预先定义$V$的shape, pytorch会根据shape的大小自动初始化一个坐标 假设$V$的坐标为$\\begin{bmatrix}x^t\\y^t\\1 \\end{bmatrix}$ ，$U$中对应的坐标为$\\begin{bmatrix}x^s\\y^s \\end{bmatrix}$。则两者之间的关系为 $$ \\begin{bmatrix}x^s\\y^s \\end{bmatrix}=\\begin{bmatrix}\\theta_{11}\u0026\\theta_{12}\u0026\\theta_{13}\\ \\theta_{21}\u0026\\theta_{22}\u0026\\theta_{23} \\end{bmatrix}\\begin{bmatrix}x^t\\y^t\\1 \\end{bmatrix} $$ 注意此处的目标坐标和原坐标的对应关系，这里使用的是图像变换中的向后映射，参考5 图像变换的本质是将像素点的坐标通过一种函数关系映射到另外的位置，并根据对应关系进行采样 向前映射：已知原图像上的坐标，并且已知原图像坐标到目标图像坐标的映射关系，因此可以求得原图像上一点经过映射后在目标图像上的位置。 向后映射：已知目标图像上的坐标，并且已知目标图像坐标到原图像坐标的映射关系，因此可以求得目标图像上一点经过映射后在原图像上的位置。 插值：通常情况下一个整数的坐标$(x,y)$经过映射后往往都位于非整数位置，此时就要采用插值方法进行采样。（此处以双线性插值为例） 针对前向映射的插值方法：当输入图像上的整数坐标$(x,y)$经过映射后，对应的目标图像上的坐标$(x’,y’)$为非整数，需要将其像素值按照一定的权重分配到其周围的四个像素点上。因此输出图像上的整数坐标的像素值是由多个输入图像像素点映射并按照一定权重叠加的结果。 针对后向映射的插值方法：当输出图像上的整数坐标$(x’,y’)$经过映射后，对应的原图像上的坐标$(x,y)$为非整数，利用其周围整数点位置的输入图像像素值进行插值，就得到了该点的像素值。我们遍历输出图像，经过坐标变换、插值两步操作，我们就能将其像素值一个个地计算出来，因此向后映射又叫图像填充映射。如下图所示。 Sampler 由于计算得到的$\\begin{bmatrix}x^s\\y^s \\end{bmatrix}$为浮点数时会造成无法进行梯度传播，因此使用双线性插值进行采样： 其中$U_{nm}^c$表示距离$(x^s,y^s)$最近的四个坐标所对应的$U$中的像素值，$V_i^c$表示使用双线性插值后$V$中某点像素值。 反向传播 前向的传递过程为Localisation net $\\rightarrow^{\\Large\\theta}$ Grid generator $\\rightarrow^{\\Large\\begin{bmatrix}x^s\\y^s\\end{bmatrix}}$ Sampler $\\rightarrow^{\\Large V_i^c}$ 因此反向传播的过程需要先计算出$V_i^c$关于$\\begin{bmatrix}x^s\\y^s\\end{bmatrix}$的梯度，在计算出$\\begin{bmatrix}x^s\\y^s\\end{bmatrix}$关于$\\theta$的梯度。 同理可以计算出$V_i^c$关于$y^s$的导数，以及$\\begin{bmatrix}x^s\\y^s\\end{bmatrix}$关于$\\theta$的导数（这个比较简单） 通过以上的前向传播以及反向传播可以学习到仿射参数$\\theta$，进而通过双线性插值得到经过warp后的特征。 参考1 参考2 参考3 参考4 参考5 ","date":"2020-11-15","objectID":"/stn%E7%9A%84%E7%90%86%E8%A7%A3/:0:0","tags":null,"title":"STN的理解","uri":"/stn%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["深度学习论文阅读笔记"],"content":"该文提出了Swapnet，能够实现任意姿态下的虚拟换装。 网络分为两阶段： warping : 将desired clothing根据pose进行warping,生成clothing segmentation。 texturing : 利用desired clothing information 对clothing segmentation进行细节的服装纹理合成。 给定包含desired clothing的图像A，以及包含desired pose的图像B，目标是生成具有B的姿态且有A的服装的图像$B'$ （B中的人物穿上了A的服装）。 ","date":"2020-11-15","objectID":"/swapnet_-image-based-garment-transfer/:0:0","tags":null,"title":"SwapNet: Image Based Garment Transfer","uri":"/swapnet_-image-based-garment-transfer/"},{"categories":["深度学习论文阅读笔记"],"content":"Warping Module 以A的语义分割图$A_{cs}$和B的语义分割图$B_{cs}$为输入，合成$B’_{CS}$,其同时具有A的语义形状、标签以及B的体型和姿态。 生成的结果strongly conditioned on the body segmentation以及weakly conditioned on the clothing segmentation。这是通过将 clothing segmentation经过下采样再上采样的操作（？）。这种设计网络结构的好处在于：（？） 损失函数部分： 没看懂 ","date":"2020-11-15","objectID":"/swapnet_-image-based-garment-transfer/:1:0","tags":null,"title":"SwapNet: Image Based Garment Transfer","uri":"/swapnet_-image-based-garment-transfer/"},{"categories":["深度学习论文阅读笔记"],"content":"Texturing Module 损失函数: $$ \\mathcal{L}{L1}=|| f_g-A ||_1 \\ \\mathcal{L}{feat}=\\sum_l\\lambda_l || \\phi_l(f_g)-\\phi_l(A) ||_2 \\ \\mathcal{L}_{GAN}s $$ ","date":"2020-11-15","objectID":"/swapnet_-image-based-garment-transfer/:2:0","tags":null,"title":"SwapNet: Image Based Garment Transfer","uri":"/swapnet_-image-based-garment-transfer/"},{"categories":["深度学习论文阅读笔记"],"content":"前馈卷积神经网络用于图像翻译任务时的一个关键在于损失函数能够准确的度量真实图像和生成图像之间的相似性。大多数的损失函数假设真实图像和生成图像在空间上是对齐的，直接比较在相应位置pixel的相似性。然而在大多数任务中，在空间上对齐的训练数据对是难以得到的。 该文提出了一种不需要对齐训练数据对的损失函数，该损失函数基于content和semantics–在考虑整张图像的content的同时比较具有相似semantics meaning的区域。 Introduction 在图像翻译任务中常用的损失函数有： （1）pixel-to-pixel 损失函数，在在相应的空间位置进行比较。包括了L1,L2和感知损失函数。 （2）Global 损失函数，例如Gram 损失函数能够通过比较整张图像的统计特性来很好的捕获风格和纹理。 （3）对抗损失函数（GAN） 存在问题： pixel-to-pixel 损失函数适用与生成图像和目标图像在空间上是对齐的情况，对于风格迁移等任务不是特别适合。 该损失函数的关键思想是将图像作为特征的集合，在忽视特征的空间位置，基于特征之间的相似性的基础上进行图像相似性的度量。我们在度量生成图像特征和真实图像特征相似性时考虑了生成图像的所有特征，因此将整张图像的语境(global image content)合并到了相似性度量中。两张图像的相似性是通过匹配的特征的相似性来定义的。 感知损失函数的一大优点是能够保证目标图像的外观。 Method 3.1 contextual similarity between images 将每一张图像表示为一系列高维的点（特征），如果两张图像相应的点是相似的则认为两张图像是相似的。我们认为如果两张图像大多数特征相似，则认为两张图像相似。 假设生成图像为$x$，目标图像为$y$，将其表示为一系列的点（特征，可以通过预训练的VGG来提取）：$X={ x_i },Y={ y_i }$,并假设$|Y|=|X|=N$（有$N$个点）。我们为每一个$y_i$从$X={ x_i}$中寻找最相似的$x_i$,然后将所有$y_i$相应的特征相似值进行相加： $$ CX(x,y)=CX(X,Y)=\\frac{1}{N}\\sum_j \\max_i CX_{i,j} $$ 其中$CX_{i,j}$定义的是$x_i$和$y_j$之间的相似性。 通过$CX_{i,j}$将整张图像的语境(global image content)引入。 我们称$x_i$与$y_j$是contextually similar的，如果$x_i$与$Y$中其他点相比与$y_j$更加的接近。当$x_i$与$Y$中所有的点都不接近时，$CX_{i,j}$会非常的的小。 设$d_{i,j}$为$x_i$与$y_j$的余弦距离，当$d_{i,j}«d_{i,k},k \\neq j$时我们认为$x_i$和$y_j$是相似的。 pytorch 实现 ","date":"2020-11-15","objectID":"/the-contextual-loss-for-image-transformation-with-non-aligned-data/:0:0","tags":null,"title":"The Contextual Loss for Image Transformation with Non-Aligned Data","uri":"/the-contextual-loss-for-image-transformation-with-non-aligned-data/"},{"categories":["深度学习论文阅读笔记"],"content":"Contribution We introduce a novel task of virtual try-on conditioned on multiple poses, and collect a new dataset that covers different poses and various clothes. We propose a novel Multi-pose Guided Virtual Try-On Network (MG-VTON) that handles large pose varia- tions by disentangling the warping of clothes appear- ance and the pose manipulation in multiple stages. Specifically, we propose a pose-clothes guided human parsing network to first synthesize the human parsing with the desired clothes and pose, which effectively guides the virtual try-on to achieve reasonable results via the correct region parts. We design a Warp-GAN that integrates human pars- ing with geometric matching to alleviate blurry issues caused by the misalignment among different poses. A pose-guided refinement network is further proposed to adaptively controls the composition mask according to different poses, which learns to recover details and remove artifacts. ","date":"2020-11-15","objectID":"/towards-multi-pose-guided-virtual-try-on-network/:1:0","tags":null,"title":"Towards Multi-pose Guided Virtual Try-on Network","uri":"/towards-multi-pose-guided-virtual-try-on-network/"},{"categories":["深度学习论文阅读笔记"],"content":"it is empty! ","date":"2020-11-15","objectID":"/towards-photo-realistic-virtual-try-on-by-adaptively-generating___preserving-image-content/:0:0","tags":null,"title":"Towards Photo-Realistic Virtual Try-On by Adaptively Generating↔Preserving Image Content","uri":"/towards-photo-realistic-virtual-try-on-by-adaptively-generating___preserving-image-content/"},{"categories":["深度学习论文阅读笔记"],"content":"主要的想法是利用光流法来捕获复杂的姿态变形。 基于光流的方法能够相比于仿射变换和薄板样条插值更加的灵活，能够解决复杂的变形问题 为了解决遮挡问题，提出了一种无监督姿态流学习方法将外观转换到被遮挡的区域。 分为两个阶段： 阶段一：通过flow estimator估计多尺寸姿态流-\u003e表示的是原图像和目标图像之间姿态的运动关系（变形关系） 阶段二：基于多尺寸姿态流，对原图像进行多尺寸特征warped操作。使用coarse-to-fine的操作，coarse操作生成目标外观，fine操作进行精修，生成图像 ","date":"2020-11-15","objectID":"/unsupervised-pose-flow-learning-for-pose-guided-synthesis/:0:0","tags":null,"title":"Unsupervised Pose Flow Learning for Pose Guided Synthesis","uri":"/unsupervised-pose-flow-learning-for-pose-guided-synthesis/"},{"categories":["深度学习论文阅读笔记"],"content":" https://arxiv.org/abs/1911.12287v2 1.Your Local GAN: Designing Two Dimensional Local Attention Mechanisms for Generative Models 该文提出了一种局部稀疏注意力层，其能够保存几何形状和局部性 同时该文提出了一种新的可视化注意力的方法 转置卷积层是GAN基础算法的重要组成部分，因为其能够捕获空间不变性。但是存在的一个限制是：卷积操作不能够构建复杂的几何与长程依赖。为了解决这一问题，注意力机制已经被引入到深度生成模型中了。注意力机制能够构建长程空间依赖，这能够自动的找到图像中相关的部分，即使两个部分相距很远。注意力首先在SAGAN中被提出，随后再BigGAN被进一步的发展。 注意力机制存在的一些问题： 第一点是计算不高效：标准的密集注意力的计算需要较大的内存和较长的时间。 第二点是统计不高效：需要大量的训练数据来训练注意力层。统计特性的不高效同样也说明了密集注意力并没有从局部性中获利，因为在图像中的大多数依赖关系主要与邻域的像素点相关.(这里可以这样理解，密集注意力机制建立了一个像素点与其他所有像素之间的关系，但是实际上，与这个像素点相关的像素点主要集中在这个这个像素点的邻域内，因此密集注意力机制的统计是不高效的。) Dense attention 给定两个特征向量： $$ {X}\\in \\mathbb{R}^{N_x \\times E_x}\\ {Y}\\in \\mathbb{R}^{N_y \\times E_y} $$ Dense Attention的输出为： $$ O=\\sigma(X_Q Y_K^T )Y_V $$ 例如自注意力机制。 Sparsified Attention 在Dense attention中的复杂性在于矩阵$A_{X,Y}=X_Q . Y_K^T$. 本文中提出的稀疏注意力机制将注意力权重矩阵的计算分解成多步，在第i步中，只关注输入位置的一部分，通过二进制掩码$M_i$来确定： $$ A_{X,Y}^i[a,b]=\\left{ \\begin{array}{lr} A_{X,Y}^i[a,b], \u0026 M_i[a,b]=1 \\ - \\infty, \u0026 M_i[a,b]=0\\ \\end{array} \\right. $$ 其中$-\\infty$表示这一位置在经过softmax处理后等于0. 关键点在于如何设计一个合理的二进制掩码$M_i$? ","date":"2020-11-15","objectID":"/your-local-gan/:0:0","tags":null,"title":"Your local GAN","uri":"/your-local-gan/"},{"categories":["深度学习论文阅读笔记"],"content":"参考1 参考2 图像由像素点构成，像素点的两个组成成分：像素值和和像素值对应的坐标（通过坐标来索引像素值） 在图像的变换中，首先进行的是坐标的变换，即已知目标坐标，通过仿射变化来寻找原图像中对应的坐标。1.通过变换求得原图像中的对应坐标。2.后再通过采样的方法来将原图像中的像素值填充到目标图像中。常用的采样方法为双线性插值、最邻近插值等。 假设原图像的像素矩阵为 $$ \\left[ \\begin{array}{cc} 234 \u0026 38 \u0026 22 \\ 67 \u0026 44 \u0026 12\\ 89 \u0026 65 \u0026 63 \\end{array} \\right] $$ 这个矩阵中，元素坐标(x,y)是这样确定的，x从左到右，从0开始，y从上到下，也是从零开始，这是图象处理中最常用的坐标系。 如果想把这副图放大为 44大小的图像，那么该怎么做呢？那么第一步肯定想到的是先把44的矩阵先画出来再说，好了矩阵画出来了，如下所示，当然，矩阵的每个像素都是未知数，等待着我们去填充（这个将要被填充的图的叫做目标图,Destination）： $$ \\left[ \\begin{array}{cc} ? \u0026 ? \u0026 ? \\ ? \u0026 ? \u0026 ?\\ ? \u0026 ? \u0026 ? \\end{array} \\right] $$ 小结：假设目标图像中的坐标为$(i,j)$,通过方向变换后得到的对应的目标图像中的目标是$(i+u,j+v)$, 则目标图像中坐标为$(i,j)$处填充的像素值为$f(i+u,j+v)=(1-u)(1-v)f(i,j)+(1-u)vf(i,j+1)+u(1-v)f(i+1,j)+uvf(i+1,j+1)$ 双线性插值的计算方法 设$f(x,y)$表示坐标$(x,y)$处的像素值 ","date":"2020-11-15","objectID":"/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/:0:0","tags":null,"title":"“什么是双线性插值\"","uri":"/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"},{"categories":["深度学习论文阅读笔记"],"content":"https://www.cnblogs.com/happystudyeveryday/p/10547316.html https://www.matongxue.com/madocs/244.html 仿射变换 Affine Transformation是一种二维坐标到二维坐标之间的线性变换，保持二维图形的“平直性”（译注：straightness，即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（译注：parallelness，其实是指保二维图形间的相对位置关系不变，平行线还是平行线） 仿射变换可以通过一系列的原子变换的复合来实现，包括：平移（Translation）、缩放（Scale）、翻转（Flip）、旋转（Rotation）和剪切（Shear）。 仿射变换的矩阵表达式： $$ \\begin{bmatrix}x^s\\y^s\\end{bmatrix}=\\begin{bmatrix}\\theta_{11}\u0026\\theta_{12}\u0026\\theta_{13}\\\\theta_{21}\u0026\\theta_{22}\u0026\\theta_{23}\\end{bmatrix}\\begin{bmatrix}x^t\\y^t\\1\\end{bmatrix} $$ 仿射变换与透视变换 https://zhuanlan.zhihu.com/p/36082864 ","date":"2020-11-15","objectID":"/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%BB%A5%E5%8F%8Atps/:0:0","tags":null,"title":"仿射变换以及TPS","uri":"/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%BB%A5%E5%8F%8Atps/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 参考 在机器学习领域中，通常将特征表示为向量的形式，所以在分析两个特征向量之间的相似性时，常用余弦相似度表示。，简单来说，余弦相似度，就是计算两个向量间的夹角的余弦值。余弦距离就是用1减去这个获得的余弦相似度。 余弦相似度：$cos(A,B)=\\frac{AB}{|A|_2|B|_2}$ 余弦距离：$dist(A,B)=1-cos(A,B)$ ","date":"2020-11-15","objectID":"/%E4%BD%99%E5%BC%A6%E8%B7%9D%E7%A6%BB/:0:0","tags":null,"title":"余弦距离","uri":"/%E4%BD%99%E5%BC%A6%E8%B7%9D%E7%A6%BB/"},{"categories":["深度学习论文阅读笔记"],"content":"深度生成模型的目的分为两个，第一个是通过在未知分布中采集一些样本，利用这些已知的样本结果信息来反推出最有可能导致这些样本结果出现的模型参数，这一步称为概率密度估计。第二步是在第一步中已学习到的概率分布中进行采样（即生成样本）。 在概率密度估计中，假设采集的样本为$\\pmb{x}={ x_1,x_2…x_n }$,假设这些样本服从一个概率密度$p(\\pmb{x};\\theta)$，其中$\\theta $为待估计的概率密度的参数。采用极大似然法进行估计，则对数似然函数为 $$ \\log p(\\pmb{x};\\theta)=\\sum_{i=1}^n\\log p(x^i;\\theta) $$ 这样参数估计问题就转化为最优化问题： $$ {\\theta}^{ML} =arg \\max\\limits_{\\theta}\\sum_{i=1}^n\\log p({x}^{(i)};\\theta) $$ 在机器学习中，密度估计是一类无监督学习问题．比如在手写体数字图像的密度估计问题中，我们将图像表示为一个随机向量𝑿，其中每一维都表示一个像素值．假设手写体数字图像都服从一个未知的分布$p_r(\\pmb{x})$，希望通过一些观测样本来估计其分布。但是，手写体数字图像中不同像素之间存在复杂的依赖关系（比如相邻像素的颜色一般是相似的），很难用一个明确的图模型来描述其依赖关系，所以直接建模$p_r(\\pmb{x})$ 比较困难．因此，我们通常通过引入隐变量𝒛来简化模型。如果要建模含隐变量的分布，就需要利用EM算法来进行密度估计。 给定样本$\\pmb{x}={ x_1,x_2…x_n }$，因为$p(\\pmb{x,z};\\theta)=p(\\pmb{z|x};\\theta)p(\\pmb{x};\\theta)$，所以有$\\log p(\\pmb{x,z};\\theta)=\\log p(\\pmb{z|x};\\theta)+\\log p(\\pmb{x};\\theta)$，进而有$\\log p(\\pmb{x};\\theta)=\\log p(\\pmb{x,z};\\theta)-\\log p(\\pmb{z|x};\\theta)$。引入变分分布概率密度$q(\\pmb{z};\\phi)$，有$\\int q(\\pmb{z};\\phi)dz=1 $,其中$\\phi$为变分分布的参数。则概率密度$p(\\pmb{x};\\theta)$的对数似然函数可以转换为： $$ \\begin{aligned} \\log p(\\pmb{x};\\theta)\u0026=\\int q(\\pmb{z};\\phi)\\log p(\\pmb{x};\\theta)dz\\ \u0026=\\int q(\\pmb{z};\\phi)[\\log p(\\pmb{x,z};\\theta)-\\log p(\\pmb{z|x};\\theta)]dz\\ \u0026=\\int q(\\pmb{z};\\phi)\\log p(\\pmb{x,z};\\theta)dz-\\int q(\\pmb{z};\\phi)\\log q(\\pmb{z};\\phi)dz-\\int q(\\pmb{z};\\phi)\\log (\\pmb{z|x};\\theta)dz+\\int q(\\pmb{z};\\phi)\\log q(\\pmb{z};\\phi)dz\\ \u0026=\\int q(\\pmb{z};\\phi)[\\log p(\\pmb{x,z};\\theta)-\\log q(\\pmb{z};\\phi)]dz-\\int q(\\pmb{z};\\phi)[\\log p(\\pmb{z|x},\\theta)-\\log q(\\pmb{z};\\phi)]dz\\ \u0026=\\int q(\\pmb{z};\\phi)\\log\\frac{ p(\\pmb{x,z};\\theta)}{ q(\\pmb{z};\\phi)}dz-\\int q(\\pmb{z};\\phi)\\log \\frac{p(\\pmb{z|x};\\theta)}{\\log q(\\pmb{z};\\phi)}dz\\ \u0026=ELBO(q,\\pmb{x};\\theta)+KL(q(\\pmb{z})||p(\\pmb{z|x};\\theta)) \\end{aligned} $$ 其中$ELBO(q,\\pmb{x};\\theta)$称为$\\log p(\\pmb{x};\\theta)$的变分下界。最大化对数边际似然$\\log p(\\pmb{x};\\theta)$可以用EM算法来求解。在EM算法的每次迭代中，具体可以分为两步： （1） E 步：固定𝜃，寻找一个密度函数$q(\\pmb{z};\\phi)$使其等于或接近于后验密度函数$p(\\pmb{z|x};\\theta)$； （2） M 步：固定$q(\\pmb{z};\\phi)$，寻找𝜃 来最大化$ELBO(q,\\pmb{x};\\theta,\\phi)$．不断重复上述两步骤，直到收敛． 在EM 算法的每次迭代中，理论上最优的$q(\\pmb{z};\\phi)$ 为隐变量的后验概·率密度函数$p(\\pmb{z|x};\\theta)$,即 $$ p(\\pmb{z|x};\\theta)=\\frac{p(\\pmb{x|z};\\theta)p(\\pmb{z};\\theta)}{\\int p(\\pmb{x|z};\\theta)p(\\pmb{z};\\theta)d\\pmb{z}} $$ 后验概率密度函数$p(\\pmb{z|x};\\theta)$ 的计算是一个统计推断问题，涉及积分计算．当隐变量𝒛 是有限的一维离散变量时，计算起来比较容易．但在一般情况下，这个后验概率密度函数是很难计算的，通常需要通过变分推断来近似估计。为了降低复杂度，通常会选择一些比较简单的分布$q(\\pmb{z};\\phi)$来近似推断，常用的变分推断方法有随机变分推断、可拓展变分推断以及非标准变分推断等。但是当$p(\\pmb{z|x};\\theta)$比较复杂时，近似效果不佳。 变分自编码器（Variational AutoEncoder，VAE）是一种深度生成模型，其思想是利用神经网络来建模复杂的条件概率密度函数。 ","date":"2020-11-15","objectID":"/_______________________________________/:0:0","tags":null,"title":"关于深度生成模型的再次思考","uri":"/_______________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 ","date":"2020-11-15","objectID":"/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/:0:0","tags":null,"title":"卷积核类型简介","uri":"/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"参考1 参考2 1.稀疏连接 卷积层与下一层的连接数大大减小 或者可以说是上一层的某一个神经元只影响了下一层的某些神经元，而不是全部神经元 或者说是下一层的某一神经元只被上一层的某些神经元所影响，而不是全部神经元 2.参数共享 作为参数的卷积核$w^(l)$对于第$l$层的所有的神经元都是相同的。 参数共享可以理解为一个卷积核直捕捉输入数据中的一种特定的局部特征，因此，如果要提取多种特征就需要使用多个不同的卷积核。 3.等变表示 卷积层负责提取特征，采样层负责特征选择，全连接层负责分类 ","date":"2020-11-15","objectID":"/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%89%B9%E7%82%B9/:0:0","tags":null,"title":"卷积神经网络的特点","uri":"/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%89%B9%E7%82%B9/"},{"categories":["深度学习论文阅读笔记"],"content":" 1.姿态表示的错误 2.由于身体自遮挡造成的姿态表示的模棱两可 3.稀少的姿态 4.稀少的外观 5. 从2D的层面来说肢体的遮挡是无可避免的 姿态引导下任务图像生成是计算机视觉领域一个热门的研究方向。该任务的目标为在目标姿态的引导下，在保留源图像外观的基础上进行人物姿态的转变。姿态引导下人物图像生成研究具有广泛的应用价值：例如图像编辑、电影制作、AR技术、虚拟换装、以及数据增强等。在这些应用中，用户通常会关注语义和细节更加丰富的部分，例如脸部和服装的细节。因此对语义信息进行保留以及对细粒度外观特征进行补充对于姿态引导下图像生成模型具有重要的意义。 姿态引导下的图像生成研究大致可以分为三种方法：全局预测方法、局部映射方法以及混合方法 全局预测方法 受到图像翻译工作的启发，早期的姿态引导下图像生成研究通常采用了全局预测的方法来直接将源图像姿态直接转换为目标姿态。例如文献【】中提出的模型中采用了具有跳跃连接的U-net进行图像的生成，其中跳跃连接用于前向传递解码特征给编码器。但是这种基于全局预测的方法缺乏捕获相应局部特征的能力，这会导致生成图像中细节的缺失，例如生成平滑的服装或者是变形的姿态。究其原因在于U-net首先文献【】被提出用于解决图像分割问题，其原域的图像与目标域的图像的局部结构是对齐的，解码器的特征映射与编码器的特征映射具有相同的空间分布，属于强约束。而对于姿态转换问题，由于人体非刚性的特点，（由于视角变化或者是姿态变化）输入图像和目标图像具有不同的空间位置，其特征映射是未对齐的，对于未对齐的特征映射则不属于强约束。因此直接使用U-net的跳跃连接只能够为解码器提供未对齐的特征映射，这对于进行姿态转换并不能取得很好的效果。 具体解释： 假设U-net的结构如上，其中Encoder中进行的是的是源图像$I_s$和目标姿态$P_t$的信息融合，所以Encoder中的特征Encoder feature表示的是源姿态$P_s$和目标姿态$P_t$的一种融合信息（当然还包括了源图像的外观），而latent code可以理解为源图像的姿态已经转变为目标姿态（保留了源图像的外观），因此latent code可以视为生成$I_g$.(需要经过Decoder编码)。所以Encoder feature和latent code（可以理解为Decoder feature）在局部是不对齐的。 思考一下U-net中的跳跃连接的作用是什么：是为了前向传递Encoder feature，这能够有效的保留源图像中的信息。（保留图像中的局部信息，保留细节） 但是在姿态引导下的图像生成研究中，前向传递的特征是不对齐的，这会导致导致模型无法很好的捕获局部的信息，使得生成的图像细节的缺失，例如生成平滑的服装或者是变形的姿态 局部映射方法 针对全局预测方法存在的缺陷，文献【】提出了一种改进的特征融合机制，对前向传递的解码器特征进行仿射变换后再传递给编码器。受到该方法的启发，有许多的研究人员采用了局部映射方法来进行姿态引导下的图像生成研究进行细粒度挖掘，例如例如引入薄板样条函数来进一步促进了非线性局部映射、引入了局部注意力机制增强了在局部映射建模中的灵活性、除此之外还有光流法以及3D 建模法等。由于局部映射方法往往需要对应的精确特征来进行细节重构，然而在实际的情况中，图像中人物往往由于视角的变化、遮挡或者姿态变化出现不可见的区域，这会导致源图像和目标图像中的某些部分区域无法对应，这些无法对应的部分就无法使用局部映射方法，这会导致相应部分的生成内容不确定。 常用的局部映射方法：仿射变换，薄板样条，局部注意力机制，光流法，3D建模 仿射变换和薄板样条不够灵活 3D建模的计算量太大 混合方法 针对局部映射方法存在的缺陷，混合方法尝试利用另外一个全局预测分支在不对应部分生成新的内容，并与局部映射方法生成的内容相结合。但是现有的混合方法只是尝试在图像级别将生成结果进行混合，中间层的特征融合很少被研究。具体来说全局预测分支通常独立于局部映射方法，这使得两者生成的内容在风格上是不一致的。 ","date":"2020-11-15","objectID":"/__________________________________________/:0:0","tags":null,"title":"可控人物图像生成综述","uri":"/__________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:0:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"sigmoid $$ f(z)=\\frac{1}{1+e^{-z}} $$ 其图像如下: ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:1:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 能够将输入的连续实值变换为0到1之间的输出 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:1:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"缺点 在深度神经网络中梯度反向传播是容易造成梯度爆炸和梯度消失 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:1:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"sigmoid导数 $$ f’(z)=\\frac{e^{-z}}{(1+e^{-z})^2} $$ 其导数图像如下: ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:1:3","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"tanh $$ tanh(x)=\\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}} $$ 其图像如下: ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:2:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 解决了sigmoid函数不是zero-centered的问题, 但是梯度消失依旧存在 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:2:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 $$ tanh’(x)=1-(\\frac{e^{x}-e^{-x}}{e^{x}+e^{-x}})^2 $$ 导数图像 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:2:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"Relu $$ Relu(x)=max(0,x) $$ 函数图像 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:3:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 $$ Relu’(x)=\\left{ \\begin{array}{lr} 1 \u0026x\u003e0 \\ 0 \u0026x\u003c0 \\end{array} \\right. $$ ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:3:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"优点 解决了梯度消失问题 计算速度非常快 收敛速度远快于sigmoid和tanh ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:3:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"缺点 输出的不是zero-centered 有些神经元可能永远不会被激活(Dead ReLU) 不好的参数初始化 学习率过高, 导致网络不幸进入这种情况 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:3:3","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"Leaky Relu(PRelu) $$ f(x)=max(\\alpha x,x) $$ 函数图像α=0.1 α=0.1 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:4:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 $$ f’(x)=\\left{ \\begin{array}{lr} 1 \u0026x\\ge0 \\ \\alpha \u0026x\u003c0 \\end{array} \\right. $$ 图像 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:4:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 具有ReLU的所有优点 不会有Dead ReLU问题 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:4:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"ELU $$ f(x)=\\left{ \\begin{array}{lr} x \u0026x\u003e0 \\ \\alpha(e^x-1) \u0026x \\leq0 \\end{array} \\right. $$ 函数图像α=1 α=1 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:5:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 $$ f’(x)=\\left{ \\begin{array}{lr} 1 \u0026x\u003e0 \\ \\alpha e^x \u0026x \\leq0 \\end{array} \\right. $$ 图像α=1 α=1 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:5:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 类似于Leaky ReLU 计算量稍大 不会有Dead ReLU问题 均值接近于0 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:5:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"SELU $$ f(x)=\\lambda\\left{ \\begin{array}{lr} x \u0026x\u003e0 \\ \\alpha e^x - \\alpha \u0026x \\leq0 \\end{array} \\right. $$ λ=1.0507009873554804934193349852946 α=1.6732632423543772848170429916717 函数图像 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:6:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 $$ f’(x)=\\lambda \\left{ \\begin{array}{lr} 1 \u0026x\u003e0 \\ \\alpha e^x \u0026\\leq0 \\end{array} \\right. $$ 图像: ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:6:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 在ELU的基础上求解了最佳的α α , 并且扩大了λ λ倍, SELU拥有ELU所有的优点 不存在死区 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:6:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"SoftMax $$ f(x_i)=\\frac{e^{x_i}}{\\sum_{j=1}^ne^{x_j}} $$ 简单地说, 就是当前元素的值就等与e的当前元素次方在所有元素的e的次方和的比例 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:7:0","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"导数 当交叉熵作为损失函数时,$loss=-\\sum_it_i \\ lny_i$,其中,表$t_i$示真实值当预测第i个时,可以认为,$t_i=1$那么$loss=-\\sum_i\\ lny_i$因为softmax的和为1,那么$\\sum_{i=1}^n(\\frac{e^{x_i}}{\\sum_{j=1}^ne^{x_j}})$,对loss求导后为: $$ y_i-1 $$ 当交叉熵作为损失函数时,LOSS=−i∑tilnyi,其中,ti表示真实值当预测第i个时,可以认为ti=1,那么LOSS=−∑lnyi因为softmax的和为1,那么∑j=1nexjexi,对Loss求导后为−(1−∑jnexj∑i=jnexi)=yi−1 也就是说, 只要求出$y_i$,那么减一就是梯度. ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:7:1","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"特点 Softmax会将整个超空间按照分类个数进行划分 Softmax会比其他的激活函数更适合多分类问题最后的激活 ","date":"2020-11-15","objectID":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/:7:2","tags":null,"title":"各种激活函数","uri":"/%E5%90%84%E7%A7%8D%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 ","date":"2020-11-15","objectID":"/%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%9A%84%E8%B0%83%E6%95%B4/:0:0","tags":null,"title":"学习率的调整","uri":"/%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%9A%84%E8%B0%83%E6%95%B4/"},{"categories":["深度学习论文阅读笔记"],"content":"目标函数损失值 曲线 曲线 初始时 上扬 [红线]： Solution：初始 学习率过大 导致 振荡，应减小学习率，并 从头 开始训练 。 曲线 初始时 强势下降 没多久 归于水平 [紫线]： Solution：后期 学习率过大 导致 无法拟合，应减小学习率，并 重新训练 后几轮 。 曲线 全程缓慢 [黄线]： Solution：初始 学习率过小 导致 收敛慢，应增大学习率，并从头 开始训练。 ","date":"2020-11-15","objectID":"/%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%9A%84%E8%B0%83%E6%95%B4/:1:0","tags":null,"title":"学习率的调整","uri":"/%E5%AD%A6%E4%B9%A0%E7%8E%87%E7%9A%84%E8%B0%83%E6%95%B4/"},{"categories":["深度学习论文阅读笔记"],"content":"概率和统计的区别？ 概率（probabilty）和统计（statistics）看似两个相近的概念，其实研究的问题刚好相反。 概率研究的问题是，已知一个模型和参数，怎么去预测这个模型产生的结果的特性（例如均值，方差，协方差等等）。 举个例子，我想研究怎么养猪（模型是猪），我选好了想养的品种、喂养方式、猪棚的设计等等（选择参数），我想知道我养出来的猪大概能有多肥，肉质怎么样（预测结果）。 统计研究的问题则相反。统计是，有一堆数据，要利用这堆数据去预测模型和参数。仍以猪为例。现在我买到了一堆肉，通过观察和判断，我确定这是猪肉（这就确定了模型。在实际研究中，也是通过观察数据推测模型是／像高斯分布的、指数分布的、拉普拉斯分布的等等），然后，可以进一步研究，判定这猪的品种、这是圈养猪还是跑山猪还是网易猪，等等（推测模型参数）。 一句话总结：概率是已知模型和参数，推数据。统计是已知数据，推模型和参数。 显然，本文解释的MLE和MAP都是统计领域的问题。它们都是用来推测参数的方法。为什么会存在着两种不同方法呢？ 这需要理解贝叶斯思想。我们来看看贝叶斯公式。 什么是贝叶斯公式？ … 极大似然估计 极大似然估计，通俗 理解来说，就是利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！ 换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。（给定样本来推测模型的参数） 极大后验估计 ","date":"2020-11-15","objectID":"/_____________________________________________________________________/:0:0","tags":null,"title":"最大似然估计、最大后验估计以及贝叶斯公式的理解","uri":"/_____________________________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 首先让我们先来了解一个概念：什么是梯度不稳定呢？ 概念：在深度神经网络中的梯度是不稳定的，在靠近输入层的隐藏层中或会消失，或会爆炸。这种不稳定性才是深度神经网络中基于梯度学习的根本问题。 产生梯度不稳定的根本原因：前面层上的梯度是来自后面层上梯度的乘积。当存在过多的层时，就会出现梯度不稳定场景，比如梯度消失和梯度爆炸。 划重点：梯度消失和梯度爆炸属于梯度不稳定的范畴 ","date":"2020-11-15","objectID":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/:0:0","tags":null,"title":"梯度消失和梯度爆炸","uri":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"},{"categories":["深度学习论文阅读笔记"],"content":"1.梯度消失与梯度爆炸的概念 梯度消失：在神经网络中，当前面隐藏层的学习速率低于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫梯度消失。 梯度爆炸：在神经网络中，当前面隐藏层的学习速率高于后面隐藏层的学习速率，即随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫梯度爆炸。 ","date":"2020-11-15","objectID":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/:1:0","tags":null,"title":"梯度消失和梯度爆炸","uri":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"},{"categories":["深度学习论文阅读笔记"],"content":"2.梯度消失与梯度爆炸的产生原因 梯度消失：（1）隐藏层的层数过多；（2）采用了不合适的激活函数(更容易产生梯度消失，但是也有可能产生梯度爆炸) 梯度爆炸：（1）隐藏层的层数过多；（2）权重的初始化值过大 （1）隐藏层的层数过多 　总结：从深层网络角度来讲，不同的层学习的速度差异很大，表现为网络中靠近输出的层学习的情况很好，靠近输入的层学习的很慢，有时甚至训练了很久，前几层的权值和刚开始随机初始化的值差不多。因此，梯度消失、爆炸，其根本原因在于反向传播训练法则，属于先天不足。具体见下图： 从上图可以非常容易的看出来：对于四个隐层的网络来说，第四隐藏层比第一隐藏层的更新速度慢了两个数量级！！！ （2）激活函数 我们以下图的反向传播为例，假设每一层只有一个神经元且对于每一层都可以用公式1表示，其中σ为sigmoid函数，C表示的是代价函数，前一层的输出和后一层的输入关系如公式1所示。我们可以推导出公式2。 3）初始化权重的值过大 当，也就是w比较大的情况下，根据2式的链式相乘可得(反向传播)，则前面的网络层比后面的网络层梯度变化更快，引起了梯度爆炸的问题。所以，在一般的神经网络中，权重的初始化一般都利用高斯分布(正态分布)随机产生权重值。 ","date":"2020-11-15","objectID":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/:2:0","tags":null,"title":"梯度消失和梯度爆炸","uri":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"},{"categories":["深度学习论文阅读笔记"],"content":"3.梯度消失与梯度爆炸的解决方案 梯度消失和梯度爆炸问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。对于更普遍的梯度消失问题，可以考虑一下三种方案解决： （1）用ReLU、Leaky-ReLU、P-ReLU、R-ReLU、Maxout等替代sigmoid函数。(几种激活函数的比较见我的博客) （2）用Batch Normalization。(对于Batch Normalization的理解可以见我的博客) （3）LSTM的结构设计也可以改善RNN中的梯度消失问题。 ","date":"2020-11-15","objectID":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/:3:0","tags":null,"title":"梯度消失和梯度爆炸","uri":"/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E5%92%8C%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"},{"categories":["深度学习论文阅读笔记"],"content":"池化层夹在连续的卷积层中间， 用于压缩数据和参数数量，减小过拟合。如果输入是图像的话，那么池化层的最主要作用就是压缩图像。特征不变性也就是在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的 resize，平时一张狗的图像被缩小了一倍还能识别出这是一张狗的图像，这说明这张图像中仍保留着狗最重要的特征，图像压缩时去掉的信息只是一些冗余信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。池化层去冗余信息的思路是将一块区域的特征值集合通过一个主要特征值替换，达到快速数据降维的效果，常见方法有取局部最大值(maxpooling)或取局部平均(averagepooling)。 池化层不但能够有效减小神经元的数量，还可以使得网络对一些小的局部形态改变保持不变形，并拥有更大的感受野 ","date":"2020-11-15","objectID":"/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8/:0:0","tags":null,"title":"池化层的作用","uri":"/%E6%B1%A0%E5%8C%96%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8/"},{"categories":["深度学习论文阅读笔记"],"content":"1绪论 ​ 基本的深度学习相当于函数逼近问题，即函数或曲面的拟合 ，所不同的是，这里用作基函数的是非线性的神经网络函数，而原来数学中的用的则是多项式、三角不等式等。 ​ 由于神经网络的非线性和复杂性，它有更强的表达能力，即能够从给定的神经网络函数族中可能找到对特定数据集拟合得更好的神经网络。这里既涉及设计合适的神经网络类型，也涉及从该类型中的神经网络中找出好的（即拟合误差小的）特定神经网络的方法。后者正是数学中最优化分支所研究的问题。从数学角度来说，目前深度学习中所用的优化算法还是属于比较简单的梯度下降法。 ​ 但是恰恰由于神经网络的非线性复杂性，使得能够通过大量的标注数据经过深度学习可以得到一个误差结果很小的神经网络，但是要用它来解释却十分的困难。近来也有学者发现，一个精度很高的神经网络，改变它的几个参数，就会使该网络的精度明显下降。换言之，深度学习方法的鲁棒性也有待研究。 ","date":"2020-11-15","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:1","tags":null,"title":"深度学习的基本概念","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["深度学习论文阅读笔记"],"content":"2.机器学习、深度学习和人工神经网络的关系 ​ 深度学习以神经网络为主要模型。深度学习一开始用来解决机器学习中的表示学习问题。但是由于其强大的能力，深度学习越来越多的用来解决一些通用的人工智能问题，比如决策、推理等。 ​ 从根源上来说，**深度学习是机器学习的一个分支，**是指一类问题以及解决这类问题的方法。指从有限样例中通过算法总结出一般性的规律，并可应用到新的未知数据上。 ​ 其次，深度学习采用的模型一般比较复杂，指样本的原始输入到输出目标 之间的数据流经过多个线性或非线性的组件（component）．因为每个组件都会对信息进行加工，并进而影响后续的组件，所以当我们最后得到输出结果时，我们并不清楚其中每个组件的贡献是多少．这个问题叫作贡献度分配问题（Credit Assignment Problem，CAP）[Minsky, 1961]． 贡献度分配问题也经 常翻译为信用分配问题或功劳分配问题．在深度学习中，贡献度分配问题是 一个很关键的问题，这关系到如何学习每个组件中的参数。 ​ 目前，一种可以比较好解决贡献度分配问题的模型是人工神经网络。神经网络和深度学习并不等价，深度学习可以采用神经网络模型，也可以采用其他模型（比如深度信念网络是一种概率图模型）.但是由于神经网络模型可以比较容易地解决贡献度分配问题，因此神经网络模型成为深度学习中主要采用的模型。 2.1人工智能 ​ 人工智能是计算机科学的一个分支，主要研究、开发用于模拟、延伸和扩展人类智能的理论、方法、技术及应用系统等．和很多其他学科不同，人工智能这个学科的诞生有着明确的标志性事件，就是1956 年的达特茅斯（Dartmouth）会议．在这次会议上，“人工智能”被提出并作为本研究领域的名称．同时，人工智能研究的使命也得以确定．John McCarthy 提出了人工智能的定义：人工智能就是要让机器的行为看起来就像是人所表现出的智能行为一样． ​ 目前，人工智能的主要领域大体上可以分为以下几个方面： （1）感知：：模拟人的感知能力，对外部刺激信息（视觉和语音等）进行感 知和加工．主要研究领域包括语音信息处理和计算机视觉等． （2）学习:模拟人的学习能力，主要研究如何从样例或从与环境的交互中 进行学习．主要研究领域包括监督学习、无监督学习和强化学习等． （3）认知:模拟人的认知能力，主要研究领域包括知识表示、自然语言理 解、推理、规划、决策等． 2.2深度学习 ​ 深度学习是将原始的数据特征通过多步的特征转换得到一种特征表示，并进一步输入到预测函数得到最终结果．和“浅层学习”不同，深度学习需要解决的关键问题是贡献度分配问题（Credit Assignment Problem，CAP）[Minsky, 1961]，即一个系统中不同的组件（component）或其参数对最终系统输出结果的贡献或影响．以下围棋为例，每当下完一盘棋，最后的结果要么赢要么输．我们会思考哪几步棋导致了最后的胜利，或者又是哪几步棋导致了最后的败局．如何判断每一步棋的贡献就是贡献度分配问题，这是一个非常困难的问题．从某种意义上讲，深度学习可以看作一种强化学习（Reinforcement Learning，RL），每个内部组件并不能直接得到监督信息，需要通过整个模型的最终监督信息（奖励）得到，并且有一定的延时性。 ​ 目前，深度学习采用的模型主要是神经网络模型，其主要原因是神经网络模型可以使用误差反向传播算法，从而可以比较好地解决贡献度分配问题．只要是超过一层的神经网络都会存在贡献度分配问题，因此可以将超过一层的神经网络都看作深度学习模型．随着深度学习的快速发展，模型深度也从早期的5 ∼ 10层增加到目前的数百层．随着模型深度的不断增加，其特征表示的能力也越来越强，从而使后续的预测更加容易。 ​ ","date":"2020-11-15","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:2","tags":null,"title":"深度学习的基本概念","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["深度学习论文阅读笔记"],"content":" 参考：https://nndl.github.io/ https://www.spaces.ac.cn/archives/5253 https://www.spaces.ac.cn/archives/5343 为什么要研究生成模型？ 概率生成模型（Probabilistic Generative Model），简称生成模型，是概率统计和机器学习领域的一类重要模型，指一系列用于随机生成可观测数据的模型。假设在一个连续或离散的高位空间$\\cal{X}$中,存在一个随机向量$\\pmb{X}$服从一个未知的数据分布$p_r(\\pmb{x})$，$\\pmb{x}\\in\\cal{X}$。生成模型是根据一些可观测样本${\\pmb{x}^1,\\pmb{x}^2,…,\\pmb{x}^N }$来学习一个参数化的模型$p_\\theta(\\pmb{x})$来近似位置分布$p_r(\\pmb{x})$，并可以用这个模型来生成一些样本，使得生成样本和真实样本尽可能地相似。生成模型通常包含两个基本功能：**概率密度估计**和**生成样本（即采样）**。下图以手写体数字图像为例给出了生成模型的两个功能示例，其中左图表示手写体数字图像的真实分布$p_r(\\pmb{x})$以及从中采样的一些“真实”样本，右图表示估计出了分布$p_\\theta(\\pmb{x})$以及从中采样的“生成”样本。 深度生成模型的目标是从训练数据中学习到复杂的概率分布 1 概率生成模型 给定一组数据$\\cal{D}=\\lbrace\\pmb{x}^{(n)}\\rbrace_{n=1}^N$，假设它们都是独立地从相同的概率密度函数为$p_r(\\pmb{x})$ 的未知分布中产生的．**密度估计（Density Estimation）是根据数据集$\\cal{D}$来估计其概率密度函数$p_\\theta(\\pmb{x})$**。 在机器学习中，密度估计是一类无监督学习问题．比如在手写体数字图像的密度估计问题中，我们将图像表示为一个随机向量𝑿，其中每一维都表示一个像素值．假设手写体数字图像都服从一个未知的分布$p_r(\\pmb{x})$，希望通过一些观测样本来估计其分布．但是，手写体数字图像中不同像素之间存在复杂的依赖关系（比如相邻像素的颜色一般是相似的），很难用一个明确的图模型来描述其依赖关系，所以直接建模$p_r(\\pmb{x})$ 比较困难．因此，我们通常通过引入隐变量𝒛来简化模型，这样密度估计问题可以转换为估计变量(𝒙, 𝒛) 的两个局部条件概率$p_\\theta(\\pmb{z})$和$p_\\theta(\\pmb{x|z})$．一般为了简化模型，假设隐变量𝒛 的先验分布为标准高斯分布𝒩(0, 𝑰)．隐变量𝒛 的每一维之间都是独立的．在这个假设下，先验分布𝑝(𝒛; 𝜃) 中没有参数．因此，**密度估计的重点是估计条件分布$p{(\\pmb{x|z},\\theta)}$．** 如果要建模含隐变量的分布，就需要利用EM算法来进行密度估计，而在EM算法中，需要估计条件分布 $p(\\pmb{x}|\\pmb{z};\\theta)$以及后验分布 $p(\\pmb{z}|\\pmb{x};\\theta)$,当这两个分布比较复杂时就可以利用神经网络来建模，这就是变分自编码器的思想。 由条件概率公式可得： $$ p_\\theta(x，z)=p_\\theta(\\pmb{z})p_\\theta(\\pmb{x|z}) $$ 在得到两个变量的局部条件概率$p_\\theta(\\pmb{z})$ 和$p_\\theta(\\pmb{x|z})$之后，我们就可以**生成数据**𝒙，具体过程可以分为两步进行： (1)根据隐变量的先验分布$p_\\theta(\\pmb{z})$ 进行采样，得到样本$z$。 (2)根据条件分布$p_\\theta(\\pmb{x|z})$进行采样，得到样本$x$. 为了便于采样，通常$p_\\theta(\\pmb{x|z})$不能过于复杂。因此，另一种生成样本的思想是从一个简单分布𝑝(𝒛), 𝒛 ∈ 𝒵（比如标准正态分布）中采集一个样本𝒛，并利用一个深度神经网络𝑔 ∶ 𝒵 → 𝒳 使得𝑔(𝒛) 服从$p_r(\\pmb{x})$．这样，我们就可以避免密度估计问题，并有效降低生成样本的难度，这正是**生成对抗网络**的思想． 1.2 变分自编码器 1.2.1 含隐变量的生成模型 假设一个生成模型（如图13.3所示）中包含隐变量，即有部分变量是不可观测的，其中观测变量𝑿 是一个高维空间𝒳 中的随机向量，隐变量𝒁 是一个相对低维的空间𝒵 中的随机向量。 这个生成模型的联合概率密度函数为： $$ p(\\pmb{x,z};\\theta)=p(\\pmb{x|z};\\theta)p(\\pmb{z};\\theta) $$ 其中$p(\\pmb{z};\\theta)$为隐变量$z$的先验分布的概率密度函数，$p(\\pmb{x|z};\\theta)$为已知$z$时观测变量$\\pmb{x}$的条件概率密度函数,$\\theta$表示两个密度函数的参数。一般情况下我们可以假设$p(\\pmb{z};\\theta)$和$p(\\pmb{x|z};\\theta)$为某种参数化的分布族，比如正态分布，这种分布的形式已知，只是参数$\\theta$未知，可以通过极大似然进行估计。 给定样本$\\pmb{x}$，其对数边际似然函数$\\log p(\\pmb{x};\\theta)$可以分解为 $$ \\log p(\\pmb{x};\\theta)=ELBO(q,\\pmb{x};\\theta,\\phi)+KL[q(\\pmb{z};\\phi),p(\\pmb{z|x};\\theta)] $$ 其中$q(\\pmb{z};\\phi)$是额外引入的变分密度函数，其参数为$\\phi$，$ELBO(q,\\pmb{x};\\theta,\\phi)$为证据下界， $$ ELBO(q,\\pmb{x};\\theta,\\phi)=\\mathbb{E}_{\\mathcal{z}\\sim {q(\\pmb{z};\\phi)}}[\\log \\frac{p(\\pmb{x,z},\\theta)}{q(\\pmb{z};\\phi)}] $$ 最大化对数边际似然$\\log p(\\pmb{x};\\theta)$可以用EM算法来求解。在EM算法的每次迭代中，具体可以分为两步： （1） E 步：固定𝜃，寻找一个密度函数$q(\\pmb{z};\\phi)$使其等于或接近于后验密度函数$p(\\pmb{z|x};\\theta)$； （2） M 步：固定$q(\\pmb{z};\\phi)$，寻找𝜃 来最大化$ELBO(q,\\pmb{x};\\theta,\\phi)$．不断重复上述两步骤，直到收敛． 在EM 算法的每次迭代中，理论上最优的$q(\\pmb{z};\\phi)$ 为隐变量的后验概率密度函数$p(\\pmb{z|x};\\theta)$，即 $$ p(\\pmb{z|x};\\theta)=\\frac{p(\\pmb{x|z};\\theta)p(\\pmb{z};\\theta)}{\\int p(\\pmb{x|z};\\theta)p(\\pmb{z};\\theta)d\\pmb{z}} $$ 后验概率密度函数$p(\\pmb{z|x};\\theta)$ 的计算是一个统计推断问题，涉及积分计算．当隐变量𝒛 是有限的一维离散变量时，计算起来比较容易．但在一般情况下，这个后验概率密度函数是很难计算的，通常需要通过变分推断来近似估计。为了降低复杂度，通常会选择一些比较简单的分布$q(\\pmb{z};\\phi)$来近似推断$p(\\pmb{z|x};\\theta)$．当$p(\\pmb{z|x};\\theta)$比较复杂时，近似效果不佳．此外，概率密度函数$p(\\pmb{x|z};\\theta)$ 一般也比较复杂，很难直接用已知的分布族函数进行建模。 什么是变分推断： 后验概率密度等于： $$ p(\\pmb{z}|\\pmb{x})=\\frac{p(\\pmb{x,z})}{\\int p(\\pmb{x,z})d\\pmb{z}} $$ 上式存在着积分运算，对于大多数的模型来说，计算积分项通常是比较困难的。变分推断的思想就是引入一个简单的分布$q_\\lambda(\\pmb{z})$来逼近后验概率$p(\\pmb{z|x})$。具体来说就是通过控制参数$\\lambda$来最小化两个分布之间的度量距离，这一度量距离通常使用KL散度。 $$ KL[q_\\lambda(z) \\ ||\\ p(\\pmb{z|x})]=-\\mathbb{E}_{q_\\lambda}(z)[\\ \\log \\frac{p(\\pmb{z|x})}{q_\\lambda(z)} \\ ] $$ 通过这种方式，变分推断加那个贝叶斯推断转换为优化问题。理想情况下$q_\\lambda(\\pmb{z})=p(\\pmb{z|x})$，但是当分布$p(\\pmb{z|x})$复杂时，变分分布$q_\\lambda(\\pmb{z})$通常是欠参数化的，无法很好的逼近$p(\\pmb{z|x})$。 变分自编码器（Variational AutoEncoder，VAE）是一种深度生成模型，其思想是利用神经网络来分别建模两个复杂的条件概率密度函数。 （1） 用神经网络来估计变分分布$q(\\pmb{z};\\phi)$，称为推断网络．理论上$q(\\pmb{z};\\phi)$可不依赖𝒙．但**由于$q(\\pmb{z};\\phi)$ 的目标是近似后验分布$p(\\pmb{z|x};\\theta)$，**其和𝒙 相关，因此变分密度函数一般写为$q(\\pmb{z|x};","date":"2020-11-15","objectID":"/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/:0:0","tags":null,"title":"深度生成模型","uri":"/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"线性模型是机器学习中应用最广泛的模型，指通过样本特征的线性组合来进行预测的模型。给定一个D维样本$\\pmb{x}=[x_1,…,x_D]^T$ ,其线下你给组合函数为： $$ f(x;w)=w_1x_1+w_2x_2+…+w_Dx_D+b=\\pmb{w^Tx}+b $$ ​ 其中$\\pmb{w}=[w_1,…w_D]^T$为为D维的权重向量。直接用$f(x;w)$来预测输出目标$y=f(x;w)$。在分类问题中，由于输出目标$y$是一些离散的标签，而$f(x;w)$的置于为实数，因此无法直接用$f(x;w)$来进行预测，需要引入一个非线性的决策函数$g(.)$来预测输出目标 $$ y=g(f(x;w)) $$ 其中$f(x;w)$也称为判别函数。典型的二分类问题的结构图如下： ","date":"2020-11-15","objectID":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/:0:0","tags":null,"title":"线性模型","uri":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"3.1线性判别函数和决策边界 ​ 一个线性分类模型是由一个（或多个）线性的判别函数$f(\\pmb{x;w})=\\pmb{w^Tx}+b$和非线性的决策函数$g(.)$构成。 3.1.1二分类 ​ 二分类问题的类别标签$y$只有两种取值，通常可以设为{+1,-1}。在二分类问题中，我们只需要一个线性判别函数$f(\\pmb{x;w})=\\pmb{w^Tx}+b$。特征空间$\\cal{R}$中满足$f(\\pmb{x;w})=0$的点组成一个分割超平面，称为决策边界。决策边界将特征空间一分为二，划成两个区域，每一个区域对应一个类别。 ​ 给定N个样本的训练集$\\cal{D}={(x^{(n)},y^{(n)}})^N_{n=1}$.其中$y^{n}\\in(+1,-1)$.线性模型视图学习到参数$\\pmb{w^*}$，使得对于每个样本$(x^{n},y^n)$尽量满足 $$ f(\\pmb{x}^(n);\\pmb{w}^*)\u003e0\\qquad if \\quad y^{(n)}=1\\ f(\\pmb{x}^(n);\\pmb{w}^*)\u003e0 \\qquad if \\quad y^{(n)}=1 $$ 3.1.2多分类 ​ 多分类问题是指分类的类别数C大于2.多分类一般需要多个线性判别函数，但是设计这些判别函数有很多种形式。 假设一个多分类的问题的类别是$\\lbrace1,2,…C\\rbrace$。常用的方式有以下三种： （1）“一对其余”方式:把多分类问题转换为𝐶 个“一对其余”的二分类问 题．这种方式共需要𝐶 个判别函数，其中第𝑐 个判别函数$f_c$ 是将类别𝑐 的样本和 不属于类别𝑐 的样本分开． （2）“一对一方式”：：把多分类问题转换为𝐶(𝐶 − 1)/2 个“一对一”的二分 类问题．这种方式共需要𝐶(𝐶 − 1)/2 个判别函数，其中第(𝑖, 𝑗) 个判别函数是把类 别𝑖 和类别𝑗 的样本分开． （3）“argmax”方式：这是一种改进的“一对其余\"方式，共需要C个判别函数 $$ f_c(\\pmb{x,w_c})=\\pmb{w_c^Tx}+b_c \\qquad c\\in\\lbrace1,…C\\rbrace $$ 对于样本𝒙，如果存在一个类别𝑐，相对于所有的其他类别𝑐(̃ 𝑐 ̃ ≠ 𝑐)有𝑓𝑐(𝒙;𝒘𝑐) \u003e 𝑓𝑐̃(𝒙,𝒘𝑐̃)，那么𝒙属于类别𝑐．“argmax”方式的预测函数定义为 $$ y={argmax}_{c=1}^Cf_c(\\pmb{x;w}_c) $$ ","date":"2020-11-15","objectID":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/:0:1","tags":null,"title":"线性模型","uri":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"3.2 logistic回归 ​ 对于二分类问题，假定$y\\in\\lbrace0,+1\\rbrace$,给定一个输入向量$\\pmb{x}$，它可能对应一张图片（假设包含猫），比如你可能想要识别这张图片是否包含一只猫，你想要一个算法能够输出预测$\\hat{y}$，也就是对实际值$y$的估计。也就是说你想要让$\\hat{y}$表示$y$等于1的可能性，前提条件是给定了输入特征$\\pmb{x}$。我们引入非线性函数sigmoid函数：$g（.）=\\sigma$来预测后验概率$p(y=1|\\pmb{x})$。 $$ let\\quad y\\approx\\hat{y}=p(y=1|\\pmb{x})=g(f(\\pmb{x;w}))=g(\\pmb{w^Tx}+b)=\\sigma(\\pmb{w^Tx}+b) $$ 其中sigmoid函数（也称为logistics函数）的图像为： sigmoid函数函数表达式为：$\\sigma(z)=\\frac1{1+e^{-z}}$.由表达式可知，如果$z$很大的话$\\sigma(z)\\approx1$。相反的，如果$z$很小，那么$\\sigma(z)\\approx0$。因此此时我们的工作就是让机器学习参数$\\pmb{w},b$使得$z=\\pmb{w^Tx}+b$较大，这样才能使$\\hat{y}$成为对$y=1$这一情况的一个很好的估计。 3.2.1 参数学习 logistics回归采用交叉熵作为损失函数，并使用梯度下降法来对参数进行更新（优化）。 损失函数为（最小化损失函数）： $$ \\Re(\\pmb{w},b)=-\\frac1N\\sum_{n=1}^N(y^{(n)}log(\\hat{y}^{(n)})+(1-y^{n})log(1-\\hat{y}^{(n)})) $$ 直观的理解：当$y=1$时损失函数为$-log(\\hat{y})$,如果想要损失函数尽可能的小，那么$\\hat{y}$就要尽可能的大，又因为sigmiod函数的取值范围为[0,1]，所以$\\hat{y}$会尽可能的接近1。同理当$y=0$时损失函数为$-log(1-\\hat{y})$，如果想要损失函数尽可能的小，就要使$\\hat{y}$尽可能接近0。 ","date":"2020-11-15","objectID":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/:0:2","tags":null,"title":"线性模型","uri":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"3.3 softmax回归 https://note.youdao.com/ynoteshare1/index.html?id=a15461dfbaf9b46fe22a75dc0ef34b46\u0026type=note ​ Softmax 回归（Softmax Regression），也称为多项Multinomial）或多类（Multi-Class）的Logistic 回归，是Logistic 回归在多分类问题上的推广。 ​ 对于多分类问题，类别标签$y\\in\\lbrace1,2,…C\\rbrace$可以有C个可能取值。给定一个样本$\\pmb{x}$，softmax回归预测的属于类别c的概率为 $$ p(y=c|\\pmb{x})=softmax(\\pmb{w_c^Tx})=\\frac {exp(\\pmb{w_c^Tx})}{\\sum_\\tilde{c}^{C}exp(\\pmb{w_\\tilde{c}^Tx})} $$ 其中$\\pmb{w_c}$为第第c类的权重向量。 3.3.1参数学习 ​ 采用交叉熵损失函数，softmax的损失函数为： $$ \\Re(\\pmb{w},b)=-\\frac1N\\sum_{n=1}^Ny^{(n)}log(\\hat{y}^{(n)}) $$ ​ ","date":"2020-11-15","objectID":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/:0:3","tags":null,"title":"线性模型","uri":"/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 参考文献 在文献中是这样描述cost volume： 明确：在文献中是计算图像1（目标图像）和经过warp操作后的图像2（原图像）的cost volume。cost volume也称为correlation ","date":"2020-11-15","objectID":"/_____________________cost-volume___correlation_________/:0:0","tags":null,"title":"计算机视觉中的cost volume","uri":"/_____________________cost-volume___correlation_________/"},{"categories":["深度学习论文阅读笔记"],"content":"计算cost volume的目的是什么？ 文章中是这样描述的：A cost volume stores the data matching costs for associating a pixel with its corresponding pixels at the next frame 即用于存储两张图像中各自像素之间的相似程度的。 ","date":"2020-11-15","objectID":"/_____________________cost-volume___correlation_________/:0:1","tags":null,"title":"计算机视觉中的cost volume","uri":"/_____________________cost-volume___correlation_________/"},{"categories":["深度学习论文阅读笔记"],"content":"如何计算cost volume 假设图像特征的大小为$x \\in \\mathbb{R}^{C \\times H \\times W}$，则像素共有$H\\times W$个像素，每个像素的维度为$C$，即一个像素为$C$维的向量。 注意在机器学习领域中，通常将特征表示为向量的形式，所以在分析两个特征向量之间的相似性时，常用余弦相似度表示。 $$ cos(A,B)=\\frac{A \\cdot B}{||A||_2\\cdot||B||_2} $$ 当将向量进行归一化之后，即$||A||_2=1$，$||B||_2=1$ 。 此时$cos(A,B)=A \\cdot B$。也就是说我们可以通过向量的点积来表示两个向量之间的相似程度。 余弦相似度的取值范围是[-1,1]，相同两个向量的之间的相似度为1。 假设目标图像的维度为$x_1 \\in \\mathbb{R}^{C \\times H \\times W}$，原图像的维度为$x_2 \\in \\mathbb{R}^{C \\times H \\times W}$，那么如何计算cost volume？ 实际上cost volume （或称为correlation）的计算分为两大类，一类是local correlation，另一类称为global correlation。 local correlation计算目标图像像素点邻域内的相似性，常用于Optical Flow计算中。 而global correlation则计算目标图像像素点与所有原图像像素点的相似性，常用于Geometric Correspondence，Semantic Correspondence的计算中 一个像素点实际上是由坐标和像素值构成的 local correlation的计算 给定目标图像中的一个坐标，在原图像中找到相同的坐标。取目标图像中该坐标处的向量值分别与原图像中相同坐标处周围的$d \\times d$个位置的向量值进行相乘(其中d为邻域的大小，d小于h,w)。 对每一个坐标都进行同样的操作，最终得到的correlation的维度为$d^2 \\times h \\times w$ global correlation的计算 给定目标中的一个坐标，取该坐标的向量值分别于原图像的每一个向量进行相乘。 对每一坐标进行同样的操作，最终的得到的correlation的维度为$(h\\times w) \\times h \\times w$ ","date":"2020-11-15","objectID":"/_____________________cost-volume___correlation_________/:0:2","tags":null,"title":"计算机视觉中的cost volume","uri":"/_____________________cost-volume___correlation_________/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 ","date":"2020-11-15","objectID":"/___________________________________________________/:0:0","tags":null,"title":"训练集、验证集和测试集的区别和联系","uri":"/___________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"1 三者的区别 训练集（train set） —— 用于模型拟合的数据样本。 验证集（development set）—— 是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。 ​ 在神经网络中， 我们用验证数据集去寻找最优的网络深度（number of hidden layers)，或者决定反向传播算法的停止点或者在神经网络中选择隐藏层神经元的数量； ​ 在普通的机器学习中常用的交叉验证（Cross Validation) 就是把训练数据集本身再细分成不同的验证数据集去训练模型。 测试集 —— 用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。 类别 验证集 测试集 是否被训练到 否 否 作用 用于调超参数，监控模型是否发生过拟合（以决定是否停止训练） 为了评估最终模型泛化能力 使用次数 多次使用，以不断调参 仅仅一次使用 缺陷 模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够 测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集 验证集的作用： 使用验证集是为了 快速调参，也就是用验证集选择超参数（网络层数，网络节点数，迭代次数，学习率这些）。另外用验证集还可以监控模型是否异常（过拟合啦什么的），然后决定是不是要提前停止训练。 验证集的关键在于 选择超参数，我们手动调参是为了让模型在验证集上的表现越来越好，如果把测试集作为验证集，调参去拟合测试集，就有点像作弊了。 而测试集既 不参与参数的学习过程，也 不参与参数的选择过程，仅仅用于模型评价。 验证集的正确打开方式： 验证集可以看做参与了 “人工调参” 的训练过程 一般训练几个 epoch 就跑一次验证看看效果（大部分网络自带这个功能） 这样做的第一个好处是：可以及时发现模型或者参数的问题，比如模型在验证集上发散啦、出现很奇怪的结果啦（Inf）、mAP不增长或者增长很慢啦等等情况，这时可以及时终止训练，重新调参或者调整模型，而不需要等到训练结束。 另一个好处是验证模型的泛化能力，如果在验证集上的效果比训练集上差很多，就该考虑模型是否过拟合了。同时，还可以通过验证集对比不同的模型。 训练集和验证集都是在训练阶段使用的！！！ 相信你看了下面这段立马就明白了 ---------------------------- for each epoch for each training data instance propagate error through the network adjust the weights calculate the accuracy over training data for each validation data instance calculate the accuracy over the validation data if the threshold validation accuracy is met exit training else continue training 一旦你完成了训练，那么你就对照你的测试集进行测试，并验证准确性是否足够。 ","date":"2020-11-15","objectID":"/___________________________________________________/:0:1","tags":null,"title":"训练集、验证集和测试集的区别和联系","uri":"/___________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"详细解释 训练集：该数据集用于调整神经网络上的权重。 验证集：该数据集用于最小化过度拟合。 您没有使用此数据集调整网络的权重，您只是验证训练数据集的准确度的任何提高实际上都会提高准确性，而不是之前未向网络显示的数据集， 或者至少网络没有接受过培训（即验证数据集）。 如果训练数据集的准确度增加，但验证数据集的准确度保持不变或降低，则您的神经网络过度拟合，应该停止训练。 测试集：该数据集仅用于测试最终解决方案，以确认网络的实际预测能力。 ","date":"2020-11-15","objectID":"/___________________________________________________/:2:0","tags":null,"title":"训练集、验证集和测试集的区别和联系","uri":"/___________________________________________________/"},{"categories":["深度学习论文阅读笔记"],"content":"1. Lipschitz定义 2. Lipschitz常数 3.深度学习中的Lipschitz约束：泛化与生成模型 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:0:0","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"L约束与泛化 扰动敏感 记输入为 x，输出为 y，模型为 f，模型参数为 w，记为： 很多时候，我们希望得到一个“稳健”的模型。何为稳健？一般来说有两种含义，一是对于参数扰动的稳定性，比如模型变成了 fw+Δw(x) 后是否还能达到相近的效果？如果在动力学系统中，还要考虑模型最终是否能恢复到 fw(x)；二是对于输入扰动的稳定性，比如输入从 x 变成了 x+Δx 后，fw(x+Δx) 是否能给出相近的预测结果。 读者或许已经听说过深度学习模型存在“对抗攻击样本”，比如图片只改变一个像素就给出完全不一样的分类结果，这就是模型对输入过于敏感的案例。 L约束 所以，大多数时候我们都希望模型对输入扰动是不敏感的，这通常能提高模型的泛化性能。也就是说，我们希望 ||x1−x2|| 很小时： 也尽可能地小。当然，“尽可能”究竟是怎样，谁也说不准。于是 Lipschitz 提出了一个更具体的约束，那就是存在某个常数 C（它只与参数有关，与输入无关），使得下式恒成立 也就是说，希望整个模型被一个线性函数“控制”住。这便是 L 约束了。 **换言之，在这里我们认为满足 L 约束的模型才是一个好模型。**并且对于具体的模型，我们希望估算出 C(w) 的表达式，并且希望 C(w) 越小越好，越小意味着它对输入扰动越不敏感，泛化性越好。 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:1:0","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"神经网络 在这里我们对具体的神经网络进行分析，以观察神经网络在什么时候会满足 L 约束。 简单而言，我们考虑单层的全连接 f(Wx+b)，这里的 f 是激活函数，而 W,b 则是参数矩阵/向量，这时候 (3) 变为： 让 x1,x2 充分接近，那么就可以将左边用一阶项近似，得到： 显然，要希望左边不超过右边，**∂f/∂x 这一项（每个元素）的绝对值必须不超过某个常数。这就要求我们要使用“导数有上下界”的激活函数，不过我们目前常用的激活函数，比如sigmoid、tanh、relu等，都满足这个条件。**假定激活函数的梯度已经有界，尤其是我们常用的 relu 激活函数来说这个界还是 1，因此 ∂f/∂x 这一项只带来一个常数，我们暂时忽略它，剩下来我们只需要考虑 ||W(x1−x2)||。 多层的神经网络可以逐步递归分析，从而最终还是单层的神经网络问题，而 CNN、RNN 等结构本质上还是特殊的全连接，所以照样可以用全连接的结果。因此，对于神经网络来说，问题变成了：如果下式恒成立，那么 C 的值可以是多少？ 找出 C 的表达式后，我们就可以希望 C 尽可能小，从而给参数带来一个正则化项。 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:2:0","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"矩阵范数 定义 其实到这里，我们已经将问题转化为了一个矩阵范数问题（矩阵范数的作用相当于向量的模长），它定义为： 如果 W 是一个方阵，那么该范数又称为“谱范数”、“谱半径”等，在本文中就算它不是方阵我们也叫它“谱范数（Spectral Norm）”好了。注意 ||Wx|| 和 ||x|| 都是指向量的范数，就是普通的向量模长。而左边的矩阵的范数我们本来没有明确定义的，但通过右边的向量模型的极限定义出来的，所以这类矩阵范数称为“由向量范数诱导出来的矩阵范数”。 好了，文绉绉的概念就不多说了，有了向量范数的概念之后，我们就有： 呃，其实也没做啥，就换了个记号而已，||W||2 等于多少我们还是没有搞出来。 Frobenius范数 其实谱范数 ||W||2 的准确概念和计算方法还是要用到比较多的线性代数的概念，我们暂时不研究它，而是先研究一个更加简单的范数：Frobenius 范数，简称 F 范数。 这名字让人看着慌，其实定义特别简单，它就是： 说白了，它就是直接把矩阵当成一个向量，然后求向量的欧氏模长。 简单通过柯西不等式，我们就能证明： 很明显 ||W||F 提供了 ||W||2 的一个上界，也就是说，你可以理解为 ||W||2 是式 (6) 中最准确的 C（所有满足式 (6) 的 C 中最小的那个），但如果你不大关心精准度，你直接可以取 C=||W||F，也能使得 (6) 成立，毕竟 ||W||F 容易计算。 l2正则项 前面已经说过，为了使神经网络尽可能好地满足L约束，我们应当希望 C=||W||2 尽可能小，我们可以把 C2 作为一个正则项加入到损失函数中。当然，我们还没有算出谱范数 ||W||2，但我们算出了一个更大的上界 ||W||F，那就先用着它吧，即 loss 为： 其中第一部分是指模型原来的 loss。我们再来回顾一下 ||W||F 的表达式，我们发现加入的正则项是： 这不就是 l2 正则化吗？ 终于，捣鼓了一番，我们得到了一点回报：我们揭示了 l2 正则化（也称为 weight decay）与 L 约束的联系，表明 l2 正则化能使得模型更好地满足 L 约束，从而降低模型对输入扰动的敏感性，增强模型的泛化性能。 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:3:0","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"谱范数 主特征根 这部分我们来正式面对谱范数 ||W||2，这是线性代数的内容，比较理论化。 事实上，谱范数 ||W||2 等于的最大特征根（主特征根）的平方根，如果 W是方阵，那么||W||2 等于 W 的最大的特征根绝对值。 对于感兴趣理论证明的读者，这里提供一下证明的大概思路。根据定义 (7) 我们有： 假设****对角化为diag(λ1,…,λn)，即，其中 λi 都是它的特征根，而且非负，而 U 是正交矩阵，由于正交矩阵与单位向量的积还是单位向量，那么： 所以等于****的最大特征根。 幂迭代 也许有读者开始不耐烦了：鬼愿意知道你是不是等于特征根呀，我关心的是怎么算这个鬼范数！ 事实上，前面的内容虽然看起来茫然，但却是求 ‖W‖2 的基础。前一节告诉我们就是****的最大特征根，所以问题变成了求****的最大特征根，这可以通过**“幂迭代”法** [3] 来解决。 所谓“幂迭代”，就是通过下面的迭代格式： 迭代若干次后，最后通过： 得到范数（也就是得到最大的特征根的近似值）。也可以等价改写为： 这样，初始化 u,v 后（可以用全 1 向量初始化），就可以迭代若干次得到 u,v，然后代入算得 ‖W‖2 的近似值。 对证明感兴趣的读者，这里照样提供一个简单的证明表明为什么这样的迭代会有效。 记，初始化为，同样假设 A 可对角化，并且假设 A 的各个特征根 λ1,…,λn 中，最大的特征根严格大于其余的特征根（不满足这个条件意味着最大的特征根是重根，讨论起来有点复杂，需要请读者查找专业证明，这里仅仅抛砖引玉。 当然，从数值计算的角度，几乎没有两个人是完全相等的，因此可以认为重根的情况在实验中不会出现。），那么 A 的各个特征向量 η1,…,ηn 构成完备的基底，所以我们可以设： 每次的迭代是 Au/‖Au‖，其中分母只改变模长，我们留到最后再执行，只看 A 的重复作用： 注意对于特征向量有 Aη=λη，从而： 不失一般性设 λ1 为最大的特征值，那么： 根据假设 λ2/λ1,…,λn/λ1 都小于 1，所以 r→∞ 时它们都趋于零，或者说当 r 足够大时它们可以忽略，那么就有： 先不管模长，这个结果表明当 r 足够大时，提供了最大的特征根对应的特征向量的近似方向，其实每一步的归一化只是为了防止溢出而已。这样一来就是对应的单位特征向量，即：因此：，这就求出了谱范数的平方。 谱正则化 前面我们已经表明了 Frobenius 范数与 l2 正则化的关系，而我们已经说明了 Frobenius 范数是一个更强（更粗糙）的条件，更准确的范数应该是谱范数。虽然谱范数没有 Frobenius 范数那么容易计算，但依然可以通过式 (15) 迭代几步来做近似。 所以，我们可以提出**“谱正则化（Spectral Norm Regularization）”**的概念，即把谱范数的平方作为额外的正则项，取代简单的 l2 正则项。即式 (11) 变为： Spectral Norm Regularization for Improving the Generalizability of Deep Learning [1]一文已经做了多个实验，表明“谱正则化”在多个任务上都能提升模型性能 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:3:1","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"生成模型 WGAN 如果说在普通的监督训练模型中，L 约束只是起到了“锦上添花”的作用，那么在 WGAN 的判别器中，L 约束就是必不可少的关键一步了。因为 WGAN 的判别器的优化目标是： 这里的 Pr,Pg 分别是真实分布和生成分布，|f|L=1 指的就是要满足特定的 L 约束 |f(x1)−f(x2)|≤‖x1−x2‖（那个 C=1）。所以上述目标的意思是，在所有满足这个L约束的函数中，挑出使得最大的那个 f，就是最理想的判别器。写成 loss 的形式就是： 梯度惩罚 目前比较有效的一种方案就是梯度惩罚，即 ‖f′(x)‖=1 是 |f|L=1 的一个充分条件，那么我把这一项加入到判别器的 loss 中作为惩罚项，即： 事实上我觉得加个 relu(x)=max(x,0) 会更好： 其中采用随机插值的方式： 梯度惩罚不能保证 ‖f′(x)‖=1，但是直觉上它会在 1 附近浮动，所以 |f|L 理论上也在 1 附近浮动，从而近似达到 L 约束。 这种方案在很多情况下都已经 work 得比较好了，但是在真实样本的类别数比较多的时候却比较差（尤其是条件生成）。 **问题就出在随机插值上：**原则上来说，L 约束要在整个空间满足才行，但是通过线性插值的梯度惩罚只能保证在一小块空间满足。如果这一小块空间刚好差不多就是真实样本和生成样本之间的空间，那勉勉强强也就够用了，但是如果类别数比较多，不同的类别进行插值，往往不知道插到哪里去了，导致该满足 L 条件的地方不满足，因此判别器就失灵了。 思考：梯度惩罚能不能直接用作有监督的模型的正则项呢？有兴趣的读者可以试验一下。 谱归一化 梯度惩罚的问题在于它只是一个惩罚，只能在局部生效。真正妙的方案是构造法：构建特殊的 f，使得不管 f 里边的参数是什么，f 都满足 L 约束。 事实上，WGAN 首次提出时用的是参数裁剪——将所有参数的绝对值裁剪到不超过某个常数，这样一来参数的 Frobenius 范数不会超过某个常数，从而 |f|L 不会超过某个常数，虽然没有准确地实现 |f|L=1，但这只会让 loss 放大常数倍，因此不影响优化结果。参数裁剪就是一种构造法，这不过这种构造法对优化并不友好。 简单来看，这种裁剪的方案优化空间有很大，比如改为将所有参数的 Frobenius 范数裁剪到不超过某个常数，这样模型的灵活性比直接参数裁剪要好。如果觉得裁剪太粗暴，换成参数惩罚也是可以的，即对所有范数超过 Frobenius 范数的参数施加一个大惩罚，我也试验过，基本有效，但是收敛速度比较慢。 然而，上面这些方案都只是某种近似，现在我们已经有了谱范数，那么可以用最精准的方案了：将 f 中所有的参数都替换为 w/‖w‖2。这就是谱归一化（Spectral Normalization），在Spectral Normalization for Generative Adversarial Networks [2] 一文中被提出并实验。 这样一来，如果 f 所用的激活函数的导数绝对值都不超过 1，那么我们就有 |f|L≤1，从而用最精准的方案实现了所需要的 L 约束。 注：“激活函数的导数绝对值都不超过 1”，这个通常都能满足，但是如果判别模型使用了残差结构，则激活函数相当于是 x+relu(Wx+b)，这时候它的导数就不一定不超过 1 了。但不管怎样，它会不超过一个常数，因此不影响优化结果。 我自己尝试过在 WGAN 中使用谱归一化（不加梯度惩罚，参考代码见后面），**发现最终的收敛速度（达到同样效果所需要的 epoch）比 WGAN-GP 还要快，效果还要更好一些。**而且，还有一个影响速度的原因：就是每个 epoch 的运行时间，梯度惩罚会比用谱归一化要长，因为用了梯度惩罚后，在梯度下降的时候相当于要算二次梯度了，要执行整个前向过程两次，所以速度比较慢。 ","date":"2020-11-15","objectID":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/:3:2","tags":null,"title":"谱归一化","uri":"/%E8%B0%B1%E5%BD%92%E4%B8%80%E5%8C%96/"},{"categories":["深度学习论文阅读笔记"],"content":"it is empty! ","date":"2020-10-13","objectID":"/convolutional-neural-network-architecture-for-geometric-matching/:0:0","tags":null,"title":"Convolutional neural network architecture for geometric matching","uri":"/convolutional-neural-network-architecture-for-geometric-matching/"},{"categories":["深度学习论文阅读笔记"],"content":"参考 参考 ","date":"2020-10-13","objectID":"/gan%E7%9A%84%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"GAN的训练技巧总结","uri":"/gan%E7%9A%84%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"},{"categories":null,"content":" 下列说法正确的是（A B） 链接 A JAVA程序的main方法必须写在类里面\rB JAVA程序中可以有多个名字为main方法 --\u003emain方法重载，\rC JAVA程序中类名必须与文件名一样 --\u003e内部类可以不同\rD JAVA程序的main方法中，如果只有一条语句，可以不用{}（大括号）括起来\r Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持，下面关于Java反射的描述，哪些是错误的：( A D F ) 链接 A Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下\rB 通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法\rC 通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员\rD Java反射机制提供了字节码修改的技术，可以动态的修剪一个类\rE Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多\rF Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率\r A：Class类在java.lang包下，错；\rB：动态代理可以通过接口与类实现，通过反射形成新的代理类，这个代理类增强了原来类的方法。对；\rC：反射可以强制访问private类型的成员，对；\rD：反射并不能对类进行修改，只能对类进行访问，错；\rE：反射机制对永生堆要求较多，对；\rF：即使使用换成，反射的效率也比调用类的方法低，错；\r 下面有关forward和redirect的描述，正确的是(B C D) ？ 链接 A forward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求--\u003e并不是全权，还是要经过服务器\rB 执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址\rC 执行redirect时，服务器端告诉浏览器重新去请求地址\rD forward是内部重定向，redirect是外部重定向\rE redirect默认将产生301 Permanently moved的HTTP响应\r 1.从地址栏显示来说\rforward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.\rredirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.\r2.从数据共享来说\rforward:转发页面和转发到的页面可以共享request里面的数据.\rredirect:不能共享数据.\r3.从运用地方来说\rforward:一般用于用户登陆的时候,根据角色转发到相应的模块.\rredirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.\r4.从效率来说\rforward:高.\rredirect:低.\r 阅读如下代码。 请问，对语句行 test.hello(). 描述正确的有（） package NowCoder;\rclass Test {\rpublic static void hello() {\rSystem.out.println(\"hello\");\r}\r}\rpublic class MyApplication {\rpublic static void main(String[] args) {\r// TODO Auto-generated method stub\r Test test=null;\rtest.hello();\r}\r}\r/*\r能编译通过，并正确运行\r*/\r 当程序执行Test tset时：jvm发现还没有加载过一个称为”Test”的类，它就开始查找并加载类文件”Test.class”。它从类文件中抽取类型信息并放在了方法区中，jvm于是以一个直接指向方法区lava类的指针替换了'test'符号引用，以后就可以用这个指针快速的找到Test类了。所以这也是为什么可以直接test.任何静态的东西\r J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（A ）方法 A service\rB doget\rC dopost\rD init\r HttpServlet容器响应Web客户请求流程如下：\r1）Web客户向Servlet容器发出Http请求；\r2）Servlet容器解析Web客户的Http请求；\r3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；\r4）Servlet容器创建一个HttpResponse对象；\r5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；\r6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；\r7）HttpServlet调用HttpResponse的有关方法，生成响应数据；\r8）Servlet容器把HttpServlet的响应结果传给Web客户。\rdoGet() 或 doPost() 是创建HttpServlet时需要覆盖的方法.\r 一个文件中的字符要写到另一个文件中，首先需要（ ）。 FileInputStream fin = new FileInputStream(this.filename);。\r 程序的逻辑很简单。程序必须打开两个文件，以可读的方式打开一个已有文件和以可写的方式打开一个新文件，后将已有文件中的内容，暂时存放在内存中，再写入新的文件，后关闭所有文件，程序结束。\r根据题意，首先需要读入一个文件中的字符，需要FileInputStream fin = new FileInputStream(this.filename);\r 创建数组的两种方式： int[] test;\rint test[];\r 下面有关java基本类型的默认值和取值范围，说法错误的是？(B) A 字节型的类型默认值是0，取值范围是-2^7—2^7-1\rB boolean类型默认值是false，取值范围是true\\false\rC 字符型类型默认是0，取值范围是-2^15 —2^15-1 --\u003e应该是\\u0000 0 —-\\uFFFF\rD long类型默认是0，取值范围是-2^63—2^63-1\r 默认值 取值范围 示例\r字节型 ： 0 -2^7—-2^7-1 byte b=10;\r字符型 ： ‘ \\u0000′ 0—-2^16-1 char c=’c’ ;\rshort : 0 -2^15—-2^15-1 short s=10;\rint : 0 -2^31—-2^31-1 int i=10;\rlong : 0 -2^63—-2^63-1 long o=10L;\rfloat : 0.0f -2^31—-2^31-1 float f=10.0F\rdouble : 0.0d -2^63—-2^63-1 double d=10.0;\rboolean: false true\\false boolean flag=true;\r 关于 Socket 通信编程，以下描述正确的是：（C ） A 客户端通过new ServerSocket()创建TCP连接对象\rB 客户端通过TCP连接对象调用accept()方法创建通信的Socket对象\rC 客户端通过new Socket()方法创建通信的Socket对象\rD 服务器端通过new ServerSocket()创建通信的Socket对象\r 客户端通过new Socket()方法创建通信的Socket对象\r服务器端通过new ServerSocket()创建TCP连接对象 accept接纳客户端请求\r 非抽象类实现接口后，必须实现接口中的所有抽象方法，除了abstract外，方法头必须完全一致。(错误) 正确\r错误 ✌ --\u003e子类的返回类型可以小于父类的返回类型,例如\r//------------------------------------\rinterface A{\rObject a();\r}\rclass B implements A{\r@Override\rpublic String a() {\rreturn null;\r}\r}\r 方法头指：修饰符+返回类型 +方法名（形参列表）\r接口的访问权限：public\r两同两小一大原则:\r返回值和参数列表相同\r返回值类型小于等于父类的返回值类型\r异常小于等于父类抛出异常\r访问权限大于等于父类\r 下列哪个选项是Java调试器？如果编译器返回程序代码的错误，可以用它对程序进行调试。 jdb.exe\r java,exe是java虚拟机\rjavadoc.exe用来制作java文档\rjdb.exe是java的调试器\rjavaprof,exe是剖析工具\rjavac : 这是java的编译器，它用于把java源文件（以.java后缀结尾）编译成java字节码文件（以.class后缀结尾）；\r 以下哪几种方式可用来实现线程间通知和唤醒：( A C) A Object.wait/notify/notifyAll\rB ReentrantLock.wait/notify/notify","date":"0001-01-01","objectID":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/:0:0","tags":null,"title":"","uri":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/"}]