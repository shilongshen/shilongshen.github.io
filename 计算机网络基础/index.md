# 计算机网络基础


# 网络基础知识

TCP/IP是通信协议的统称

TCP/IP就是IP,TCP,HTTP等协议的集合。

简单的说，协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。两台计算机之间必须能够支持相同的协议，并准守相同协议进行处理，这样才能实现相互通信。

## 分组交换协议

分组交换协议是指将大数据分割成一个个叫做包的较小单位进行传输的方法。

## 协议的分层

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201216211853.png)

每个分层都接受由它下一层所提供的特定服务，并且负责为它的上一层提供特定的服务。上下层之间进行交互时所遵守的约定称为接口。同一层之间的交互叫做“协议”。

## 传输方式的分类

### 面向有连接型与面向无连接型

通过网络发送数据可以大致分为面向有连接型与面向无连接型。

- 面向有连接型：字发送数据数据之前，需要在收发主机之间建立一条通信线路。就好比人们平常打电话 （如TCP协议）
- 面向无连接型：不要求建立和断开连接。发送端可以在任何时候自由发送数据。反之，接收端也永远不知道自己会在何时收到数据。因此在面向无连接型时，接收端常常需要确认是否接收到数据。就好比去邮局寄包裹 （如UDP协议，IP协议）

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218194245.png)

### 电路交换和分组交换

网络通信方式大致可以分为两种：电路交换和分组交换。

- 电路交换历史久远，主要用于过去的电话网

  - 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

    

- 分组交换则是比较新的通信技术，TCP/IP则是采用了分组交换技术（重点介绍）。

  - 让连接到通信电路的计算<u>机将所要发送的数据分为多个数据包，按照一定的顺序排列之后分别发送</u>。这就是分组交换。有了分组交换，数据被细分之后，所有计算机就可以一齐收发数据。
  - 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。
  - 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。

  ![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218144041.png)

## 地址

TCP/IP通信中使用MAC地址、IP地址、端口号等信息作为地址标识。甚至在应用层中，可以使用电子邮件地址作为网络通信的地址。

地址应该具有唯一性和层次性

MAC地址和IP地址在标识一个通信主体时虽然都具有唯一性，但是其中只有IP具有层次性。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218151451.png)



# TCP/IP的基础知识

[参考](https://www.cnblogs.com/laojiao/p/9653108.html)



互联网进行通信时需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族。

因此**互联网的协议就是TCP/IP，TCP/IP就是互联网的协议**。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201216200749.png)

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201216170841.png)



![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201216194805.png)



http是应用层协议，tcp是传输层协议，IP是网络层协议，不是同一层的协议，协议是一层层打包的。
像这样**［以太［IP［TCP［http［应用数据］］**

---



## OSI与TCP/IP的区别和联系

ISO制定了OSI模型，OSI参考模型中各个分层的作用：

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218162126.png)





ISO制定的OSI参考模型的过于庞大、复杂招致了许多批评。与此对照，由技术人员（IEFT）自己开发的TCP/IP协议栈获得了更为广泛的应用。如图所示，是TCP/IP参考模型和OSI参考模型的对比示意图。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201218155408.png" style="zoom:200%;" />



TCP/IP参考模型分为四个层次：应用层、传输层、网络互连层和主机到网络层。

在TCP/IP参考模型中，去掉了OSI参考模型中的会话层和表示层（这两层的功能被合并到应用层实现）。同时将OSI参考模型中的数据链路层和物理层合并为主机到网络接口层。

## 网络7层协议，4层，5层？

7层指OSI模型，包括物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

4层指TCP/IP，包括网络接口层、网络层、传输层、应用层

5层只是OSI和TCP/IP的综合，是业界产生出来的非官方协议模型，但是很多具体的应用。实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。五层体系结构包括：物理层、数据链路层、网络层、传输层、应用层、。 

**下面将针对“5层”进行介绍**

## TCP/IP分层模型与通信示例

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218211306.png)



每个分层中都会对所发送的数据附加一个首部，在这个首部中包含了必要的信息

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218211500.png)



<u>网络中传输的数据包由两部分组成：一部分是协议要用到的首部，另一部分是上层传过来的数据。</u>

在数据包的首部明确表明了协议应该如何读取数据。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201218215342.png" style="zoom:200%;" />

TCP/IP各层对邮件的收发处理：

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218213723.png)



每个包首部至少都会有两个信息：一个是发送端和接收端地址（以太网会用MAC地址，IP会用IP地址，TCP会用端口号，即使是应用程序，也会用电子邮件这样的信息作为一种地址标识）；**另一个是上层协议的协议类型**（一个标识位，用来标识上一层的协议信息）。

[什么是端口](https://blog.csdn.net/iteye_10189/article/details/82009690?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-2.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-2.not_use_machine_learn_pai)

分层中的包信息：

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201218214518.png" style="zoom:200%;" />

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201218215303.png" style="zoom:200%;" />

# 1.物理层（硬件）

## bit,byte,帧的区别和联系

1byte=8bit

在网络中，网络设备将“bit”组成一个个的byte，然后这些字节“封装”成**帧**，在网络上传输。为什么要把数据“封装”成帧呢？因为用户数据一般都比较大，有的可以达到MB字节，一下子发送出去十分困难，于是就需要把数据分成许多小份，再按照一定的次序发送出去。
 以太网的帧值总是在一定范围内浮动，最大的帧值是1518字节，最小的帧值是64字节。在实际应用中，**帧的大小是由设备的MTU（最大传输单位）即设备每次能够传输的最大字节数自动来确定的**。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218211500.png)

## 物理层的任务

物理层是TCP/IP中最底层、负责数据传输的**硬件**。这种硬件就相当于**以太网**或**电话线路**等物理层的设备。

物理层的上一层为数据链路层，接收来自数据链路层发送来的数据帧，将数据帧转换为数据比特流。

> 计算机以二进制0,1来表示信息，然而实际的通信媒介之间处理的却是电压的高低、光的闪灭以及电波的强弱等信号。<u>把这些信号转换成0,1信号的正是物理层</u>。
>



物理层需考虑怎样才能在连接各种计算机的传输媒介上传输数据比特流，而不是指具体的传输媒体。硬件设备、传输媒介种类、通信手段多样，物理层要屏蔽掉这些差异，使上面的数据链路层感受不到这些差异，这样数据链路层能只管如何完成本层的协议和服务。



## 中继器

中继器是物理层延长网络的设备（通过中继器进行网络延长）。由电缆传来的信号经由中继器的波形调整和方法再传给另一个电缆。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330193835.png)

除此之外只具有中继器功能的HUB称为**集线器**，也是物理层设备

# 2.数据链路层

## 计算机网络的连接方式

计算机网络是指计算机与计算机连接组成的网络，现实中计算机是通过**电缆**相互连接的。根据数据链路的不同选用的电缆类型也不相同。而媒介本身也可以分为电波、微波等不同类型的电磁波。

LAN：局域网; WAN:广域网

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218165722.png)



## 网卡

任何一台计算机连接网络时，都必须使用网卡（网络接口卡NIC），也被称为网络适配器、LAN卡

---



明确：

- 我们可以将数据链路层视为让网卡起作用的“驱动程序”。驱动程序是在操作系统与硬件之间起到桥梁作用的**软件**。

## MAC地址

MAC地址由设备的制造厂商针对每块**网卡**进行分别的指定。

人们可以通过制造商内部产品编号唯一确定MAC地址。但是却无法确定哪家厂商的哪个网卡被用在了哪个地方（不具有层次性）。

<u>MAC地址用于识别数据链路中互连的节点</u>。

用于表示同一链路中不同计算机的一种标识

## 网桥

数据链路层上连接两个网络的设备。它能够识别数据链路中的数据帧，并将这些数据帧临时存储与内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。

数据链路的数据帧中有一个数据位叫做**FCS**，用于校验数据是否正确送达目的地。网桥通过检查这个这个域中的值，将那些损坏的数据丢弃，从而避免发送给其他网段。此外，网桥还能够通过**地址自学机制**和过滤功能控制网络的流量

这里所说的地址是指MAC地址、硬件地址、物理地址以及适配器地址，也就是针对网卡分配的具体地址。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218200346.png)

网桥的自学功能：**根据源MAC地址进行自学**

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201226091012.png)



## 数据链路层的作用

<u>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范</u>。通信媒介包括了双绞线电缆、同轴电缆、光纤、电波等介质。

计算机以二进制0,1来表示信息，然而实际的通信媒介之间处理的确是电压的高低、光的闪灭以及电波的强弱等信号。把这些信号转换成0,1信号的正是物理层。数据链路层的数据也不是单纯的0,1信号，而是将他们集合成一个称为“帧”的块，再进行传输。



## 信道复用技术

频分多路复用 Frequency-division multiplexing，FDM 

波分多路复用 Wavelength Division Multiplexing, WDM 

时分多路复用 Time-Division Multiplexing，TDM 

码分复用  (Code Division Multiplexing)，CDM

空分多路复用 Space Division Multiplexing, SDM

## 共享介质型网络

从通信介质的使用方法上来看，网络可以分为共享介质型和非共享介质型。

共享介质型就是多个设备共享同一个通信介质的一种网络。在这种方式下，设备之间使用同一个载波信道进行发送和接收，基本采用半双工通信方式。

共享介质型网络有两种介质访问控制方式：争用方式和令牌传递方式。

### 争用方式

也称为CSMA（载波监听多路访问）

这种方式采用<u>先到先得</u>的方式占用信道发送数据

这种方式如果多个站同时发送帧，会产生冲突现象。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201220171347.png)



改良的CSMA方式-CSMA/CD方式

#### CSMA/CD

CSMA/CD要求每个站提前检查冲突，一旦发生冲突，则尽早释放信道，原理：

- 如果载波信道上没有数据流动，则任何站可以发送数据
- 检查是否会发生冲突。一旦发生冲突时，放弃发送数据，同时立刻释放信道
- 放弃发送后，随机等待一段时间，再重新抢占介质，重新发送帧。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201220171840.png)

常见问题：有关CSMA/CD协议特点描述正确的是（ *AC*  ）？

```
A可抢占性的   //放弃发送后，随机等待一段时间，再重新抢占介质，重新发送帧
B不可抢占性的
C半双工介质访问控制协议
D全双工介质访问控制协议
```



### 令牌传递方式

令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文。是控制传输的一种方式。只有获得令牌的站才能够发送数据。

两个特点：

1. 不会冲突
2. 每个站有平等循环获得令牌的机会。因此，即使网络拥堵也不会导致性能下降

在网络不拥堵的情况下利用效率不高。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221085547.png)



## 非共享介质型网络

网络中的每个站直连交换机，由交换机来负责转发数据帧。此方法中，发送端和接收端不共享通信介质，可以采用全双工的方式进行通信

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330193935.png)



## 半双工和全双工通信

半双工指，在某一时刻只能够发送或者只能够接收的通信方式。类似于无线电收发器

全双工指，在某一时刻既可以发送数据页可以接收数据的通信方式，类似于电话



## 根据MAC地址转发

以太网**交换机**（也称为交换集线器，交换机的每一个端口可以看成是一个网桥），这是一种将非介质共享型网络中所使用的交换机用在以太网中的技术。

以太网交换机就是持有多个端口的网桥。它们<u>根据数据链路层中每个帧的目标MAC地址，决定从哪个网络端口发送数</u><u>据</u>。这时所参考的，用于记录发送接口的表就叫做**转发表**。

转发表的内容是**自动生成**的。

数据链路层中的每个通过点在接到包时，会从中将<u>源MAC地址</u>以及<u>曾经接收地址发送的数据包的接口</u>作为对应关系记录在转发表中。（根据源MAC地址进行自学）

以某个MAC地址作为源地址的包有某一接口接收，实质上可以理解为该MAC地址就是该接口的目标

换句话说，**以该MAC地址作为目标地址的包，经由该接口送出即可**。 

这一过程称为自学过程。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221092937.png)

> 交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入转发表中。为了发送数据帧到  B，先查转发表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A  发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。

## 以太网

**以太网是一种星型拓扑结构局域网。**

早期使用集线器进行连接，**集线器是一种物理层设备， 作用于比特而不是帧**，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

目前**以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发**。

### 以太网帧格式



![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330193450.png)

以太网的帧的前端有一个叫做前导码的部分，表示一个一台网帧的开始，也是对端网卡能够确保与其同步的标志。



以太网帧本体的前端是以太网的首部。共14个字节。然后是数据，帧尾是FCS。

- 目标MAC地址：目标工作站物理地址
- 源MAC地址：发送端工作站物理地址
- 类型：表明以太网上一层：网络层，的协议类型
- FCS：用于检查帧是否损坏。



![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221095014.png)



## PPP

PPP (point-to-point protocol) 指点对点连接计算机的协议。相当于位于数据链路层。

PPP与以太网和FDDI不同，后两者不仅与数据链路层有关，还与物理层有关。具体来说，以太网使用同轴光缆或双绞线光缆，它可以决定其中的0,1信号被解释为何种电子信号。

而<u>PPP属于纯粹的数据链路层，与物理层没有关系。换句话说，仅有PPP无法实现通信，还需要物理层的支持</u>。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330194035.png)

互联网用户通常需要连接到某个 ISP （互联网供应商）之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201221103509.png" style="zoom:50%;" />

### PPP的帧格式

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221105410.png)



每个帧的**前后**加上8为字节“01111110”用于区别帧，称为**标志码**





## 信道分类

### 广播信道

一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。



### 点对点信道

因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。



### 小结

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221133530.png)



# 3.网络层



- **IP** : 是跨越网络传送数据包，使整个互联网都能收到数据的协议
  - 虽然IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发。因此属于**非可靠性传输协议**
- **ICMP** : IP数据包在发送过程中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。ICMP就是为这一功能制定的。它有时也用于诊断网络的健康状况
- **ARP** ： 从分组数据包的IP地址中解析出物理地址（MAC）地址的一种协议 



## IP地址

IP地址由网络号和主机号两部分组成。

两个主机即使主机号不同，但是网络号相同，这说明了它们处于同一网段。通常处于同一网段的主机也都属于同一个部门或集团组织。这为IP寻址带来了极大的方便。因此IP地址具有层次性。

<u>连接到网络中的所有主机用于通信的目标地址</u>



### 主机，路由器和节点的区别

- 主机：配置有IP地址，但是不进行路由控制（中转分组数据包）的设备
- 路由器：既配有IP地址又具有路由控制功能的设备
- 节点：主机和路由器的统称



## 路由器

路由器是网络层上连接两个网络、并对分组报文进行转发的设备。网桥是根据物理地址（MAC地址）进行处理，而路由器则是根据IP地址进行处理的。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218201344.png)

## 路由器的结构

路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201227153155.png" style="zoom:80%;" />

## 路由器的分组转发流程

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N（即网络标识，网路标识相同的计算机必须属于同一链路）。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。

## 路由选择协议

路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。

互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

可以把路由选择协议划分为两大类：

- 自治系统内部的路由选择：RIP 和 OSPF
- 自治系统间的路由选择：BGP



## 网络层和数据链路层的关系

数据链路层的主要作用是在互连**同一种**数据链路的结点间进行包传递。而一旦跨越**多种数据链路**就需要借助网络层。<u>网络层可以跨越不同的数据链路进行数据包的传输</u>。

- 数据链路层提供**直连**两个设备之间的通信功能
- 网络层负责在没有直连的两个网络之间进行通信传输。

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，**IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。**

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221134906.png)

## MAC地址和IP地址的联系

问题：

- 数据链路上只直到接收端的MAC地址不就知道数据是准备发送给主机B的吗，为什么还需要知道它的IP地址？

回答：

- 考虑发送给其他数据链路中的某一个主机时的情况。如下图，主机A想要发送数据给主机B，则必须经过路由器C。路由器C隔断了两个网络，所以无法实现直接从主机A发送到主机B。必须先将数据发送给路由器C的MAC地址C1。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331090207.png)

## IP基础知识

IP大致分为三个作用模块

- IP寻址
- 路由（最终节点为止的转发）
- IP分包与组包

### IP地址属于网络层

- 在TCP/IP通信中的所有主机和路由器都必须配置IP地址
- 无论主机和哪种形式的数据链路相连，其IP地址的形式都不会改变。以太网、无线局域网、PPP等，都不会改变IP地址的形式



### 路由控制

路由控制是指将分组数据发送到最终目标地址的功能。通过IP地址的网络标识表示进行路由控制。

#### 多跳路由

“跳”：网路中在同一个数据链路中进行传输的一个区间。在数据链路中通过MAC地址进行数据帧传输。此时一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。在这一条的区间中，电缆可以通过网桥或交换集线器相连，不会通过路由器或网关相连。

IP路由又称为多跳路由，指路由器或主机在转发数据包时，只指定下一个路由器或主机，而不是将到最终目标地址的所有通路都指出。

因为每一个区间在转发数据包时会指定下一跳的操作，直到最终目标地址。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221142018.png)

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331085845.png)

#### 路由控制表

为了将数据包发送给目标主机，所有主机都维护一张路由控制表。**该表记录IP数据在下一步应该发送给哪一个路由器**（根据网络标识）。数据包将根据路由控制表在各个数据链路传递。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330194127.png)

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331094214.png)

- 路由控制表中记录网络地址以及下一步应该发送至路由器的地址。
- 在发送IP包时，首先要通过确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有**相同网络标识**的记录，根据该记录将IP包转发给相应的下一个路由器。

### 数据链路的抽象化

<u>不同的数据链路最大的不同在于它们的最大传输单位（MTU）不同。</u>

以太网的MTU为1500字节，

FDDI的MTU为4352字节，

为了解决这一问题，IP进行分片处理，将<u>较大的IP包分为多个小的IP包</u>进行传输，分片的包到达目标地址后再被组合起来。

即从IP的角度看，它完全可以忽略数据包在途中各个数据链路上的MTU。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330194212.png)

### IP地址属于面向无连接型

IP地址属于面向无连接型，不需要建立与目标地址间的连接，属于非可靠传输。



## IP地址基础知识

### IP数据包格式

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221144024.png)

**（IPv4）长度为32位，（IPv6）长度为128位**

- **版本**   : 有 4（IPv4）和 6（IPv6）两个值；
- **首部长度**   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
- **区分服务**   : 用来获得更好的服务，一般情况下不使用。
- **总长度**   : 包括首部长度和数据部分长度。
- **生存时间**   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
- **协议**  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。
- **首部检验和**  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
- **标识**   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
- **片偏移**   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

### 网络标识和主机标识

IP地址由网络标识和主机标识两部分组成，

- 同一段内的主机的网络标识是一样的（网路标识相同的计算机必须属于同一链路）
- 同一段内的主机标识是不一样的

由此保证IP地址的唯一性。

IP数据包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。即使不看主机标识，只要一见到网络标识就能够判断出是否出现为该网络段的主机。

那第几位到第几位是网络标识，第几位到第几位是主机标识呢？有<u>两种</u>类型，最初两者是按照**分类**进行区别。而现在基本以**子网掩码**区分。以下将分别介绍

### IP地址的分类

IP 地址 ::= {< 网络标识 >, < 主机标识 >}

可分为A类，B类，C类，D类

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201221152410.png)

### 子网掩码

**作用：划分出更加细粒度的IP地址，提高利用率。**

**利用子网掩码来对IP地址进行划分（划分出网络标识和主机标识）**

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

注意，外部网络看不到子网的存在。

子网掩码用二进制方式标识的话，也是 32位的数字。它对应网络标识的部分全部为1，对应主机标识的部分全部为0，**通过这种方式可以灵活的指定网络标识的长度。**

> 同一个IP地址根据不同的子网掩码可以划分出不同的网络标识

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222144826.png)

> 作者：纪言
> 链接：https://www.zhihu.com/question/56895036/answer/447915532
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 首先子网掩码这名字取得很好，它是用来划分**子网**的网段和**遮掩**部分IP地址。换个说法就是：**它是用来划分IP地址中哪一部分是网络号，哪一部分是机器号**（这话教科书里写的）。网路号对应网络标识，网络标识相同的机器处于同一网段，即同一链路；机器号对应主机标识。
>
> 那么，问题来了 ：
>
> **怎么划分子网网段？**
>
> **为什么要遮掩IP地址？怎么个遮掩法？**
>
> 现在我们有这么个**IP地址**：192.168.1.129
>
> 我们并不知道它的网络号，也不知道它属于哪部分子网网段。我们现在就需要一个东西来划分出子网网段，这个东西就叫：**子网掩码**。
>
> 再，我们给出具体**子网掩码**：255.255.255.0
>
> 什么要这么给？因为子网掩码的长度要和IP地址相同32位，每8位预先被划分为一段。255的二进制就是1111 1111。
>
> 那么我们把子网掩码设置为255.255.255.193行不行？
>
> 这需要看它的二进制，子网掩码还需要满足一个条件才可以使用：它的二进制中1和0必须是连续的。
>
> 255.255.255.193的二进制：
>
> 1111 1111.1111 1111.1111 1111.1100 0001
>
> 可以看出它1并不连续，所以255.255.255.193不能作为子网掩码使用。
>
> 255.255.255.0就很符合条件。
>
> 那子网掩码怎么用？
>
> 答：用乘法来遮掩IP地址。1×1=1、1×0=0、0×0=0、0×1=0
>
> IP地址：192.168.1.129      
>
> 二进制：
>
> 1100 0000.1010 1000.0000 0001.1000 0001
>
> 子网掩码：255.255.255.0  
>
> 二进制：
>
> 1111 1111.1111 1111.1111 1111.0000 0000
>
> 计算：
>
> ```text
> 1100 0000.1010 1000.0000 0001.1000 0001
> 1111 1111.1111 1111.1111 1111.0000 0000
> ————————————————————
> 1100 0000.1010 1000.0000 0001.0000 0000
> ```
>
> 计算后的这段二进制代码相比于原来的IP地址，后面8位被用0遮掩了。
>
> 为什么要遮掩？因为我们不必关心后面8位是1还是0了。子网网段已经被划分出来了。
>
> 1100 0000.1010 1000.0000 0001.0000 0000的十进制：192.168.1.0
>
> 也就是说，从192.168.1.0到192.168.1.255都是同一个子网网段，里面的0—255号可以分配给不同的机器。
>
> 0—255号都是机器的号码，IP地址显示的就是其中129号。
>
> 192.168.1.0就是所谓的**网络号**，也可以写作192.168.1或者192.168.1.0\24（24指的是IP地址中有24位未被遮掩）
>
> IP地址的意思就很明白了，网段（网络号）加上机器号码。**同一个IP地址根据不同子网掩码，会划分出不同的网络号和机器号。**
>
> 
>
> —————————————————————————————————————
>
> 
>
> 但是，现在就出现了个问题，我子网掩码的最后8位全是0，要是最后8位不全为0怎么办？又是什么意思呢？
>
> 现在我们就要看上面子网掩码为255.255.255.0的时候机器号码是从0到255的，那如果我想在0到255里再划分一部分呢？
>
> 给出**新IP地址**：192.168.1.188    再给出**新的子网掩码**：255.255.255.224
>
> 现在IP的网络号就不是192.168.1.0了，不再是网段192.168.1.0到192.168.1.255了
>
> ```text
> 1100 0000.1010 1000.0000 0001.1011 1100  
> 1111 1111.1111 1111.1111 1111.1110 0000  
> ————————————————————
> 1100 0000.1010 1000.0000 0001.1010 0000
> ```
>
> 不再是24位未被遮掩了，而是27位未被遮掩。被遮掩的后5位，我们不必再关心它是1还是0了。 
>
> 这就意味着：后5位不论怎么变换，都是在同一个网段里。
>
> 后5位的变化是在
>
> 1100 0000.1010 1000.0000 0001.101**0 0000** 
>
> 到
>
> 1100 0000.1010 1000.0000 0001.101**1 1111**
>
> 之间的。
>
> 它的十进制：192.168.1.160到192.168.1.191是由**新的子网掩码**划分出来的子网网段。
>
> 我们称192.168.1.160\27是它的网络号，它的机器号是在160到191之间任意分配出去。之前的IP地址：192.168.1.188属于其中。
>
> 总结：子网掩码就是用来遮掩IP地址并划分网段的工具，根据**遮掩的位数不同**来划分不同的网段。

### 无分类

**无分类编址 CIDR** 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   **构成超网**  。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。





### 广播地址

作用：用于在同一链路相互连接的主机之间发送数据包。

将IP地址中的主机标识全都设为1就形成了广播地址

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222145615.png)



### IP地址聚合（CIDR与VLSM）

[参考](https://blog.csdn.net/aipanyu/article/details/86600392)

**无类域间路由技术（CIDR）（超网技术supernet）**

将现有的IP地址合并成较大的、具有更多主机地址的路由域。

**CIDR提出“网络前缀（network-prefix）”代替“网络号+主机号”**，形成新的无分类的二级地址结构，

​      <u>即IP地址表示为：网络前缀+主机号</u>

CIDR不在使用子网的概念，是一种无分类的二级地址结构。采用“斜线记法”

例：200.16.23.0/20 其中前20位为网络前缀，后12位是主机号。

CIDR将网络前缀相同的连续的IP地址组成一个“CIDR地址块”，一个CIDR地址块是由起始地址与块地址数来表示的。地址块的起始地址是指地址块中数值最小的一个。

例：200.16.23.0/20表示一个地址块时，起始地址为200.16.23.0，地址块中的地址数为2^12次。

**CIDR中的广播地址：将主机号全置为1。**

例：网络195.1.22.64/27的广播地址就要考虑5位主机号置1。由于64的二进制数为 0100 0000，后5位置1后为01011111（为十进制数95），那么网络195.1.22.64/27的广播地址为195.1.22.95。



## ARP

ARP是一种解决MAC地址问题的协议。

> 在数据链路层中不使用IP地址进行通信，而是使用MAC地址。知道了目标的IP地址还需要知道其对应的MAC地址，这样从才能够实现在数据链路上进行传输。

以目标IP地址为线索，用来定位下一个应该接收数据包的网络设备对应的MAC地址。如果目标主机不在同一条链路，可以通过ARP查找下一跳路由器的MAC地址

ARP只适用于IPv4,IPv6中可以用ICMPv6来替代ARP。

### ARP 的工作机制

- ARP是借助ARP请求和ARP响应两种类型的包确定MAC地址。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222193309.png)

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222193418.png)



## ICMP

ICMP的主要功能：**确认IP包是否成功送达目标地址**，通知在发送过程中IP包被废弃的主要原因，改善网络设置等。

有了这些功能之后，就可以获得网络是否正常、设置是否有误以及设备有何异常等情况。从而便于在网络上的问题诊断。

在IP通信中如果某个IP包因为某种原因未能到达目标地址，那么这个具体的原因有ICMP负责通知。

ICMP的这种通知消息会使用IP进行发送。发送主机分解该ICMP的首部和数据域以后得知具体发生问题的原因。

ICMP的信息大致可以分为两类：

- 通知出错原因的信息
- 用于诊断的查询信息

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222200044.png)

### Ping

Ping 是 ICMP 的一个重要应用（ICMP回送信息），主要<u>用来测试两台主机之间的连通性</u>。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

### Traceroute

Traceroute 是 ICMP 的另一个应用（ICMP超时信息），它可以显示由执行程序的主机到达特定主机之前经历多少路由器。。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2  收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。



## NAT

功能：用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以<u>使用 NAT 来将本地 IP 转换为全球 IP</u>。

在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n  台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得<u>多个专用网内部的主机共用一个全球  IP 地址</u>。<u>使用端口号的 NAT 也叫做网络地址与端口转换 NAPT</u>。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331104721.png)



## 虚拟专用网 VPN

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（**专用地址**）。

> 在[公用网络](https://baike.baidu.com/item/公用网络/12752077)上建立[专用网络](https://baike.baidu.com/item/专用网络/795899)，进行[加密](https://baike.baidu.com/item/加密/752748)通讯。在[企业网络](https://baike.baidu.com/item/企业网络/2119389)中有广泛应用。[VPN](https://baike.baidu.com/item/VPN)网关通过对[数据包](https://baike.baidu.com/item/数据包/489739)的加密和数据包目标地址的转换实现[远程访问](https://baike.baidu.com/item/远程访问/3326708)。
>
> ​	VPN属于[远程访问](https://baike.baidu.com/item/远程访问)技术，简单地说就是利用[公用网络](https://baike.baidu.com/item/公用网络)架设[专用网络](https://baike.baidu.com/item/专用网络)。例如某公司员工出差到外地，他想访问企业[内网](https://baike.baidu.com/item/内网)的[服务器](https://baike.baidu.com/item/服务器)资源，这种访问就属于远程访问。
>
> 

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

**VPN 使用公用的互联网作为本机构各专用网之间的通信载体**。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。

下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是  10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1  对**内部数据进行加密**，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址  194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201222202602.png" style="zoom:50%;" />







# 4.传输层

传输层的主要功能是能够让应用程序之间实现通信

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330194308.png)

- **TCP** ： 是一种面向有连接的传输层协议。能够保证数据的**可靠**传输。有**重发控制，顺序控制，流量控制，拥塞控制**，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。
  
  - TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。
  
  <img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406193105.png" style="zoom:67%;" />
  
- **UDP** ：是一种<u>面向无连接</u>的传输层协议。它不会关注对端是否真的接收到数据（不可靠传输）。 尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。（<u>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信</u>。）

- TCP和UDP的区别：

  - TCP可以在丢包时进行重发，而UDP不可以。
  - TCP可以对次序乱掉的分包进行顺序控制，而UDP不可以。
  - TCP只有在确认对端存在的时候才会发送数据，从而可以控制通信流量的浪费。而UDP不可以。

  ![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406192939.png)

## 套接字（Socket）

应用在使用TCP或UDP时，会用到操作系统提供的类库。这种类库一般被称为API（应用编程接口）。

使用TCP或UDP通信时，会广泛使用到套接字（Socket）的API。

[参考](https://blog.csdn.net/pashanhu6402/article/details/96428887#t11)

应用程序利用套接字，可以设置对端的IP地址、端口号，并实现数据的发送与接收

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201231110430.png)



Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组**接口**。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201231112220.png)

> 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。
>

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“**打开open –> 读写write/read  –>  关闭close**”模式来操作。我的理解就是<u>Socket就是该模式的一个实</u>现，socket即是一种特殊的文件，<u>一些socket函数就是对其进行的操作</u>（读/写IO、打开、关闭）

`socket是“open—write/read—close”模式的一种实现`



## 端口号

- 数据链路中的地址：MAC地址；作用：识别同一链路中的不同计算机
- 网络层中的地址:IP地址；作用：识别TCP、IP网络中互连的主机和路由器
- 传输层的地址：**端口号**（程序地址）；作用：**识别同一台计算机中的不同应用程序**。

## TCP

### TCP首部格式

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201223204444.png" style="zoom: 50%;" />



- **序号**   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

  - 按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。

  <img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201223205741.png" style="zoom:80%;" />

- **确认号**   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

- **数据偏移**   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

- **确认 ACK**   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息称为**确认应答**（ACK）

- **同步 SYN**   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

- **终止 FIN**   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

- **窗口**   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



### 通过序列号和确认应答来提高可靠性

**序号**   ：用于对字节流进行编号。能够识别是否已经接收数据，又能够判断是否需要接收。

按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201223205741.png" style="zoom:80%;" />

### 重发超时

如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：
$$
RTTs=(1-a)*(RTTs)+a*RTT
$$
 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，**TCP 使用的超时时间计算如下**：
$$
RTO=RTTs+4*RTTd
$$

 其中 RTTd 为偏差的加权平均值。

### 连接管理

TCP是面向有连接的通信传输。因此在通信会做好通信两端的准备工作。

即通过三次握手和四次挥手来进行连接管理。

### TCP三次握手

TCP是面向有连接的通信传输。需要在数据通信之前先做好通信两端之间的准备工作。



<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201223212343.png" style="zoom: 50%;" />



假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

**三次握手的原因**

1. 第三次握手是为了**防止失效的连接请求到达服务器，让服务器错误打开连接。**

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210429100632.png" style="zoom: 67%;" />

> 网络报文的生存时间往往都会超 TCP 请求超时时间，如果两次握手就可以创建连接 ，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B 机器会以为是 A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYN_SENT ，所以直接丢弃了 B 的确认数据 ，以致最后只是 B 机器单方面创建连接完毕。
>
> 谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，**以致延误到连接释放以后的某个时间才到达 server**。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。<u>假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了</u>。
>
> <u>由于现在 client 并没有发出建立连接的请求(通过检测server的ack)，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。</u>
>
> 采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。
>
> client通过检测server返回的ack,如果ack不对(是失效的请求连接到达server,使得server进行第2次握手),这个时候client不会进行第三次握手,而是向server发送一个reset信号,server接收到reset信号后就会变成Listen状态.
>
> 
>
> 作者：山尽
> 链接：https://www.zhihu.com/question/24853633/answer/573627478
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



> 注意是客户端忽略  -->客户端不会向服务端发送数据，服务端就会进行空等待中，进而浪费了服务端的资源
>
> 本质上是通过序列号来确认，即原因2
>
> 

2. 两次握手无法进行序列号的确认工作  -->用三次握手来确认双方都可以获得对方的 序列号（seq）

[参考1](https://mp.weixin.qq.com/s/NIjxgx4NPn7FC4PfkHBAAQ)

[参考2](https://blog.csdn.net/meism5/article/details/90414236)

> **TCP 的可靠连接是靠 seq（ sequence numbers 序列号）来达成的。**三次握手是为了确保对方获得自己的序列号
>
> TCP建立的的传输是双工的,也就是说即可以从A到B传输,也可以从B到A进行传输
>
> 为了确保B知道A传输过来的数据是否合法,以及为了确保A知道B传输过来的数据是否合法,需要对双方的初始序列号进行确认
>
> 两次握手只能够保证A和B就A的初始序列号达成一致,但是无法对B的初始序列号达成一致,所以还需要进行第三次握手
>
> 如何使得双方对初始序列号达成一致?通过确认应答号来确定

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210429140628.png" style="zoom:67%;" />

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406190956.png" style="zoom:67%;" />



<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406191035.png" style="zoom:67%;" />

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406191818.png" style="zoom:67%;" />

**为什么要回传SYN**

接收端传回发送端的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号。？--->不是通过序列号来确认的吗

### TCP四次挥手

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201223212544.png" style="zoom: 67%;" />

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- A 发送连接释放报文，FIN=1。

- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

- 当 B 不再需要连接时，发送连接释放报文，FIN=1。

- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（**最大报文存活时间**）后释放连接。

  -->最大分段寿命（Maximum Segment Lifetime (MSL) ，默认使用2分钟）

  

- B 收到 A 的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 **CLOSE-WAIT** 状态。<u>这个状态是为了让服务器端接收还未传送完毕的数据</u>，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文能够到达**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

  - 为什么要等待2MSL呢？

    如果B没有收到A发送来的确认报文①，B就会重新发送请求释放报文②，这其中有两个过程①②,所以TIME_WAIT的时间是2MSL

    (注意一个端在网络中的寿命是不会比最长分段寿命长的)

- 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，等待一段时间是为了**让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文**。



> *为什么建立连接是三次握手，关闭连接确是四次挥手呢？*
>
> 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
>
> 而关闭连接时，服务器收到对方的FIN报文后，表示的是客户端请求断开连接，服务端接收到这个信号的时候不会立刻断开连接，因为还存在没有接收的数据，这个时候服务端会先向客户端回应一个ACK信号，表示服务端收到了客户端的断开请求连接
>
> 这时就进入了close-wait状态了，用于服务端接收还未传送的数据。
>
> 当服务端接收完毕后，再向服务端发送FIN=1和ACK=1，表示自己可以断开连接了
>
> 因此，服务端的ACK和FIN一般都会分开发送，从而导致多了一次。
>
> - 本质的原因是在建立连接的时候，因为客户端和服务端之间不存在数据的传送，因此无需将ACK和SYN分开进行发送
> - 而断开连接时，因为客户端和服务端之间存在数据的传送，所以需要将服务端需要将数据接收完才断开连接，所以FIN和ACK是分开发送的。
>
> <img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210429100512.png" style="zoom:67%;" />
>
> 

### TCP以段为单位发送数据

在建立TCP的连接过程中，也可以确立发送数据包的单位。我们可以称之为最大消息单位（MSS）。

TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。，进行重发时也是以MSS为单位。

MSS是在三次挥手时，在两端主机计算出来的。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201225153128.png" style="zoom:67%;" />

### 利用窗口控制提高传输速度

TCP以1个段为单位，每发送一个段就要进行一次确认应答处理，这种传输方式的一个缺点是，包的往返时间越长通信性能就越低。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201225154510.png" style="zoom:50%;" />



为此，TCP引入了窗口这个概念，能够提高传输的速度。即**发送端主机在发送一个段后不必一直等待确认应答，而是继续发送**。如下图：

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201225154646.png)



**窗口是指无需等待确认应答就可以继续发送数据的最大值**

如下图：

- 在窗口内的数据即使没有收到确认应答也可以发送出去
- 发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据（如果没有收到确认应答需要重发）
- 收到确认应答的情况下，发送端的可以将窗口滑动到确认应答中序列号的位置。

通过这种方式可以顺序的将多个段同时发送提高通信性能。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201225154847.png" style="zoom:80%;" />

### 窗口控制和快速重发控制

分为两种情况：1. 确认应答未能返回的情况（接收端主机成功接收到发送端主机发送的报文，但是接收端主机返回的确认应答未成功被发送端主机收到） 2.某个报文丢失的情况（接收端主机未成功接收到发送端主机发送的报文）

1. 确认应答未能返回的情况

   在没有使用窗口控制的情况下，没有收到确认应答的数据都会被重发

   但是在使用窗口控制的情况下，某些确认应答即便丢失了也不需要重发（**通过下一个确认应答进行确认**）

   <img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201225160355.png" style="zoom:80%;" />



2. 某个报文丢失的情况

   接收端主机在没有收到自己所期望序号的数据时，会对之前收到的数据进行确认应答。

   发送端一旦收到某个确认应答后，又连续3次收到同样的确认应答，则认为数据段已经丢失，需要进行重发。这种机制被称为**快速重发机制**

   

   ![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201225160626.png)



### 流量控制

TCP提供流控制可以**让发送端根据接收端的实际接收能力控制发送的数据量**

- TCP首部中，专门有一个字段用来通知窗口的大小，接收主机可以将自己可以接收的缓冲区大小放入这个字段中通知给发送端
- 窗口大小的值就是由接收端主机确定的
- 接收区缓冲区一旦面临数据溢出，窗口大小的值就会被设置成一个更小的值，从而控制发送端主机发送数据



### 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。**流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度**。

- 在网络拥堵时减少数据的发送。

发送的最初执行慢开始，令 cwnd（报文段大小） = 1，发送方只能发送 1 个报文段；当收到确认后，将 **cwnd 加倍**，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd  增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >=  ssthresh 时，进入拥塞避免，每个轮次**只将 cwnd 加 1**。

如果出现了超时，则令 **ssthresh = cwnd / 2**，然后重新执行慢开始

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201225164300.png)

# 5.应用层

TCP/IP应用架构绝大多属于客户端/服务端模型。提供服务的程序叫做服务端，接受服务的程序叫客户端。在这种通信模式中，提供服务的程序会预先被部署到主机上，等待接收任何时刻客户可能发送的请求。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201218202543.png)

TCP和IP等下层协议是不依赖于上层应用类型、适用面非常广的协议，而应用协议则是为了实现**某种应用**而设计和创造的协议。

> 相当于传输层及以下部分是通用的部分，不管什么应用都可以通过这一通用部分进行传输；而在应用层中有不同的应用，针对不同的应用应该采用不同的应用协议。

网络应用由不同的用户和软件供应商开发。为了实现网络应用的功能，在应用层之间进行通信时将其连接的协议是十分重要的。

应用可以直接享用传输层以下的基础部分。开发者只需要关心选用哪种应用协议，如何开发即可，而不必担心应用中的数据该以何种方式发送到目标主机。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406111712.png)

常见的应用协议：

- 浏览器与服务端之间的通信协议为HTTP，所传输数据的主要格式为HTML。
- 发送电子邮件时用到的协议为SMTP协议或MIME协议。
- 文件传输协议:FTP。文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上
- 远程登录协议：SSH 协议或TELNET协议。
- 网络管理协议：SNMP协议。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20210330194402.png)



SNMP：简单网络管理协议 使用无连接UDP
SSH：安全外壳协议 采用面向连接的TCP协议传输 应用22号端口 安全系数较高。
DHCP：动态主机配置协议 使用UDP进行工作
TELNET：是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式



## DNS

### DNS的产生

起因：IP地址不便于记忆。

解决方法：为每一台计算机赋予一个唯一的主机名。主机名与IP地址一一对应

在进行网络通信时直接使用主机名，系统自动将其转换为对应的IP地址。

**DNS系统：有效管理主机名和IP地址之间对应关系的系统。**它可以维护一个用来表示主机名和和IP地址之间对应关系的数据库。

**域名**：为了识别主机名称和组织名称的一种具有<u>分层</u>的名称。

例如：`kusa.ac.jp`。在使用域名时，可以在每个主机名后面追加上域名。例如:`pepper.kusa.ac.jp`,`piyo.kusa.ac.jp`

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222162109.png)

**域名服务器**：指管理域名的主机和相应的软件。

它可以管理所在分层的域的相关信息。其所管理的分层叫做ZONE 。

**DNS解析器**：进行DNS查询的主机和软件。

**DNS查询**

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201222163017.png)



## DHCP

**功能：实现IP地址的自动配置、统一管理IP地址分配。**

DHCP让即插即用成为可能

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331103754.png)

工作原理：

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210331104130.png)

## 文件传输协议:FTP

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。



- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201225172113.png)



主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。





## Web基础

万维网（WWW，World Wide Web）是将互联网中的信息以**超文本**形式展示的**系统**。也叫作Web。

可以显示Web信息的**客户端软件**称为Web浏览器。简称为浏览器。

借助浏览器，人们不需要考虑该信息保存在在哪个服务器，只需要点击鼠标就可以访问页面的链接并打开相关信息。

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201229200513.png" style="zoom:80%;" />

### Web基本要素

#### URL

- （统一资源定位符）：用来表示互联网中资源（文件）的具体位置

它是  URI（**U**niform **R**esource **I**dentifier，统一资源标识符）的子集，**URL 在 URI 的基础上增加了定位能力**。URI 除了包含 URL，还包含 URN（Uniform Resource  Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523  用来定义一个书籍名称，但是却没有表示怎么找到这本书。

- URI包含了URL

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201229220244.png)





#### HTML（超文本标记语言）

- 是记录Web页中的一种**语言**。HTML具有纯文本的功能。在页面中不仅可以为文字或图像附加链接，当用户点击那些链接时还可以呈现该链接所指示的内容，因此它可以将整个互联网中任何一个Web服务器中的信息以链接的形式展现。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201231100049.png)



#### HTTP（文档传输协议）

- 当用户在浏览器上输入要访问的Web页的URL后HTTP的处理就会开始。HTTP默认使用80端口。它的工作机制为，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。

> HTTP有两个版本，一个是HTTP1.0另一个是HTTP1.1
>
> - HTTP1.0中每一个命令和应答都会触发一次TCP的连接和断开
> - HTTP1.1允许在一个TCP连接上发送多个命令和应答；大大减小TCP连接和断开操作，从而提高了效率。

### JavaScript :

- 是一种嵌入在HTML中的编程语言，作为客户端程序运行于多种类型的的浏览器中。 

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201229212959.png" style="zoom:80%;" />



---



### CGI

- 是一种Web服务器调用外部程序时所使用的一种服务端应用的规范。

引入CGI以后客户端请求会触发Web服务器运行另一个程序，客户端的请求也会输给这个程序。该程序运行结束后就会将生成的HTML和其他数据再返回给客户端。

利用CGI可以针对用户的操作**返回给客户端动态的信息**。

### Web 页面请求过程

#### 1. DHCP 配置主机信息

- 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。
- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。
- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。
- 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width  space>FF:<zero-width space>FF:<zero-width  space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。
- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP  ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP  报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。
- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。



#### 2. ARP 解析 MAC 地址

- 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。
- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。
- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。
- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。
- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。
- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP  查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width  space>FF:<zero-width space>FF:<zero-width  space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。



#### 3. DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。



#### 4. HTTP 请求页面

- 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
- 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201216170841.png)

### 从输入URL到页面加载发生了什么

- DNS域名解析
- TCP建立连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 断开连接

---



## HTTP基本概念

HTTP协议用于客户端和服务器之间的通信

HTTP规定，客户端和服务端通过请求和响应的交换达成通信。

#### 请求和响应报文

客户端发送一个请求报文给服务端，服务端根据请求报文中的信息进行处理，并将处理的结果放入响应报文中返回给客户端。

- 报文的结构为：报文首部+空行+报文实体。其中报文首部又由请求行/状态行+首部字段构成。通常并不一定要有报文实体。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230102955.png)

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230103323.png)

##### **请求报文结构**

- 请求方法
- 请求URL
- 协议版本
- 可选的请求首部字段
- 内容实体

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230094556.png)





---

##### **响应报文结构**

- 协议版本
- 状态码（表示请求成功或失败的数字代码）
- 用来解释状态码的原因短语
- 可选的响应首部字段
- 实体主体

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230094622.png)



##### 报文主体和实体主体

- 报文：是HTTP通信中的基本单位，由8位组字节流构成，通过HTTP通信传输。
- 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。

- HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速度
- HTTP报文的主体用于传输请求或响应的实体主体

通常情况下报文主体等于实体主体，只有当传输过程中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

### HTTP方法

请求报文中包含了方法字段，常用方法如下:



#### GET

> 获取资源

当前网络请求中，**绝大部分使用的是 GET 方法**。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402151039.png)





#### POST

> 传输实体主体

POST 主要用来传输数据，而 GET 主要用来获取资源。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402151238.png)

更多 POST 与 GET 的比较请见[参考](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E4%B9%9Dget-%E5%92%8C-post-%E6%AF%94%E8%BE%83)。

#### PUT

> 上传文件

要求在请求报文的主体中包含文件内容，然后保存到请求URI指定位置。

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402160044.png)



#### DELETE

> 删除文件

与 PUT 功能相反，并且同样不带验证机制。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402160406.png)

#### HEAD

> 获取报文首部

和 GET 方法类似，但是不返回报文实体主体部分。

主要用于确认 URL 的有效性以及资源更新的日期时间等。

#### PATCH

> 对资源进行部分修改

PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

```
PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: "e0023aa4e"
Content-Length: 100

[description of changes]
```



#### OPTIONS

> 查询支持的方法；查询针对请求URI指定的资源支持的方法

查询指定的 URL 能够支持的方法。

会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402160605.png)

#### CONNECT

> 要求在与代理服务器通信时建立隧道

使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402161001.png)



#### TRACE

> 追踪路径,服务器会将通信路径返回给客户端。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。

通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402161240.png)

---



![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402160827.png)

---



### HTTP状态码

服务器返回的   **响应报文**   中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |



#### 1XX 信息

- **100 Continue**  ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。



#### 2XX 成功

- **200 OK**

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230110831.png)

- **204 No Content**  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230110908.png)

- **206 Partial Content**  ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111041.png)

#### 3XX 重定向

- **301 Moved Permanently**  ：永久性重定向

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111333.png)

- **302 Found**  ：临时性重定向

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111426.png)

- **303 See Other**  ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111528.png)

- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified**  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，**如果不满足条件，则服务器会返回 304 状态码**。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111618.png)

- **307 Temporary Redirect**  ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。



#### 4XX 客户端错误

- **400 Bad Request**  ：请求报文中存在语法错误。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402184802.png" style="zoom: 67%;" />

- **401 Unauthorized**  ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185042.png" style="zoom: 67%;" />

- **403 Forbidden**  ：请求被拒绝。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111828.png)

- **404 Not Found**

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230111746.png)

#### 5XX 服务器错误

- **500 Internal Server Error**  ：服务器正在执行请求时发生错误。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185132.png" style="zoom:67%;" />



- **503 Service Unavailable**  ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185236.png)

### HTTP首部

使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容

HTTP首部字段结构：

```
首部字段名：字段值
```

一个字段名可以有多个字段值

有4种HTTP首部字段类型

- 通用首部字段

- 请求首部字段

- 响应首部字段

- 实体首部字段

各种首部字段及其含义如下（不需要全记，仅供查阅）：



#### 通用首部字段

| 首部字段名        | 说明                                       |
| ----------------- | ------------------------------------------ |
| Cache-Control     | 控制缓存的行为                             |
| Connection        | 控制不再转发给代理的首部字段、管理持久连接 |
| Date              | 创建报文的日期时间                         |
| Pragma            | 报文指令                                   |
| Trailer           | 报文末端的首部一览                         |
| Transfer-Encoding | 指定报文主体的传输编码方式                 |
| Upgrade           | 升级为其他协议                             |
| Via               | 代理服务器的相关信息                       |
| Warning           | 错误通知                                   |



#### 请求首部字段

| 首部字段名          | 说明                                            |
| ------------------- | ----------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                        |
| Accept-Charset      | 优先的字符集                                    |
| Accept-Encoding     | 优先的内容编码                                  |
| Accept-Language     | 优先的语言（自然语言）                          |
| Authorization       | Web 认证信息                                    |
| Expect              | 期待服务器的特定行为                            |
| From                | 用户的电子邮箱地址                              |
| Host                | 请求资源所在服务器                              |
| If-Match            | 比较实体标记（ETag）                            |
| If-Modified-Since   | 比较资源的更新时间                              |
| If-None-Match       | 比较实体标记（与 If-Match 相反）                |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输逐跳数                                  |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                  |
| Range               | 实体的字节范围请求                              |
| Referer             | 对请求中 URI 的原始获取方                       |
| TE                  | 传输编码的优先级                                |
| User-Agent          | HTTP 客户端程序的信息                           |

 

#### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |



#### 实体首部字段

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的 URI     |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置范围     |
| Content-Type     | 实体主体的媒体类型     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改日期时间 |



### HTTPS

HTTP存在的问题

- 通信使用明文（不加密），内容可能被窃听

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185726.png" style="zoom:67%;" />

- 不验证通信双方的身份，可能不是和预想的通信方在通信。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185909.png" style="zoom:67%;" />

- 无法证明报文的完整性，内容可能被篡改。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402185946.png" style="zoom:67%;" />

什么是HTTPS：

**与SSL组合使用的HTTP被称为HTTPS.（超文本传输安全协议）。**

HTTPS=HTTP+通信加密+证书+完整性保护

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230152528.png)



SSL是一种网络安全技术，其能够为HTTP提供通信加密、证书、完整性保护

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230152815.png)

> HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。
>
> 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。



#### 共享秘钥加密

加密和解密使用**同一个**秘钥，也称为对称秘钥加密

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402190540.png" style="zoom:67%;" />

优点：运算速度快

存在问题：无法安全的将秘钥发送给对方

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230155751.png)

#### 公开秘钥加密

- 发送密文的一方使用对方的公开秘钥进行加密处理
- 对方收到被加密的信息后，在使用自己的私有秘钥进行解密（也称为非对称秘钥加密）
- 即使用公开密钥进行加密，使用私有密钥进行解密。

优点：使用这种方式可以不需要发送用于解密的私有秘钥，也不必担心密钥被攻击者窃听而盗走

缺点：运算速度慢

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230160208.png)

#### HTTPS加密方式

上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key  传输给通信方。而非对称密钥加密方式可以保证传输的安全性（但是传输效率低），因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。HTTPS  采用**混合**的加密机制，正是利用了上面提到的方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201230161327.png" style="zoom: 33%;" />



#### 认证

存在问题：

公开秘钥加密方式的问题：**无法证明公开秘钥本身就是货真价实的公开秘钥**。（无法证明收到的公开秘钥就是预想的那台服务器发行的公开秘钥）

解决方法：

- 通过使用   **证书**   来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，**服务器会把证书发送给客户端**。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

> 如何将公开秘钥安全的转交给客户端：
>
> ​	多数浏览器开发商发布版本时，会**事先**在内部植入常用认证机构的**公开秘钥**
>
> 浏览器通过认证机构的**公开秘钥**来验证数字签名，以证实服务器公开密钥的真实性。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230165147.png)



#### 完整性保护

**SSL 提供报文摘要功能来进行完整性保护。**

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

<u>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作</u>。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

#### HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

### HTTP2.0





---



<img src="https://gitee.com/shilongshen/image-bad/raw/master/img/20201229213747.png" style="zoom:80%;" />





## HTTP协议相关

### 持久连接

也称为keep-alive

特点为：只要任意一端没有明确的提出断开连接则保持TCP连接状态。

在HTTP1.1中，所有的连接默认都是持久连接

#### HTTP长连接、短链接

- 长连接：就是持久连接，一次建立可以进行多次通信
- 短链接：一次建立只进行一次通信

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406195923.png" style="zoom:67%;" />

### 管线化

管线化技术出现后，不用等待响应就可以发送下一个请求。

这样就能够同时并行发送多个请求，而不需要一个一个等待响应了。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230141351.png)

### Cookie

- Cookie技术通过在请求和响应报文中写入Cookie信号来控制客户端的状态
- 对通信状态进行保存

> Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

HTTP是不保存状态的协议，即无状态协议，**HTTP协议自身不对请求和响应之间的通信状态进行保存。**因此需要使用Cookie技术。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230095333.png)

> **用途**：
>
> 比如，用户登录在一家购物网站，即使他跳转到该站的其他页面后，也能够继续保持登录状态。针对这个实例，网站为了能够掌握是谁发送的请求，需要保存用户的状态。
>
> - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
> - 个性化设置（如用户自定义设置、主题等）
> - 浏览器行为跟踪（如跟踪分析用户行为等）

>  **分类**：
>
>  - 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
>  - 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。

过程：

- 客户端发送请求报文
- 服务端返回响应报文，响应报文中的首部字段有一个叫做Set-Cookie字段
- 客户端通过响应报文中的Set-Cookie字段得知，自动保存Cookie
- 在下次客户端发送请求报文时，请求报文中会自动包含Cookie字段
- 服务端发现请求报文中的Cookie字段后，会去检查是哪一个客户端发送过来的请求，然后对比服务器上的记录，最后得到之前的状态信息

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230100626.png)



![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230100704.png)

###  Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在**服务器端**，存储在服务器端的信息更加安全。

> 利用Session将用户信息存储在服务端,将用户状态与SessionID进行绑定，通过SessionID来识别不同的用户。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：（通过Cookie来管理Session）

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 **Session ID**，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，<u>服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</u>

应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID  值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session  管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402112017.png)

![image-20210402112156050](C:\Users\ssl\AppData\Roaming\Typora\typora-user-images\image-20210402112156050.png)

#### 浏览器禁用 Cookie

此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术（将Session ID直接附加到URL路径后面），将 Session ID 作为 URL 的参数进行传递。

####  Cookie 与 Session 选择

- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
- 对于大型网站，<u>如果用户所有的信息都存储在 Session 中，那么开销是非常大的</u>，因此不建议将所有的用户信息都存储到 Session 中。

<img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210406200502.png" style="zoom:80%;" />

### 虚拟主机

HTTP1.1规范允许一台HTTP服务器搭建多个Web 站点。

即使物理层面只有一台主机，但是只要使用虚拟主机的功能，就可以假想有多台服务器

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230142123.png)

客户端通过域名来访问服务器，域名首先会通过DNS解析成IP地址。即虚拟主机具有不同的域名，但是一台服务器上的虚拟主机的IP地址是相同的。所以需要区别不同的虚拟主机。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230142448.png)



### 代理

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URL，会直接发送给前方持有资源的目标服务器。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230142725.png)

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402140827.png)

使用代理服务器的原因：

- 利用缓存技术减少网络带宽的流量

- 组织内部针对特定网站的访问控制

  ...

缓存代理：会预先将资源副本（缓存）保存在代理服务器上，当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获
取资源，而是将之前缓存的资源作为响应返回。

### 网关

网关与代理的不同之处在于，网关能够使通信线路上的服务器提供非HTTP协议服务

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230143216.png)

网关能够提高通信的安全性。因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用
SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

### 隧道

隧道可以按照要求建立一条与其他服务器的通信线路，届时可以使用SSL等加密手段进行通信。

隧道的目的是确保通信的安全性。

隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230143457.png)

### 缓存

缓存指代理服务器或客户端本地磁盘内保存的资源副本

利用缓存可以减少堆源服务器的访问，节省了通信流量和通信时间

![](https://gitee.com/shilongshen/image-bad/raw/master/img/20201230143725.png)



### 内容协商

通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

![](https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210402141839.png)

#### 1. 类型

**1.1 服务端驱动型**

客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

它存在以下问题：

- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

**1.2 代理驱动型**

服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。



#### 2. Vary

```
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。



### 内容编码

内容编码将实体主体进行压缩，从而减少传输的数据量。

常用的内容编码有：gzip、compress、deflate、identity。

浏览器发送 Accept-Encoding  首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送  Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的  Vary 首部字段至少要包含 Content-Encoding。



### 范围请求

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

#### 1. Range

在请求报文中添加 Range 首部字段指定请求的范围。

```
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```

请求成功的话服务器返回的响应包含 206 Partial Content 状态码。

```
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```



#### 2. Accept-Ranges

响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。

```
Accept-Ranges: bytes
```



#### 3. 响应状态码

- 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。



### 分块传输编码

Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。



### 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。

例如，上传多个表单时可以使用如下方式：

```
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

---

# 参考

https://github.com/CyC2018/CS-Notes

上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.

竹下隆史. 图解 TCP/IP[M]. 人民邮电出版社, 2013.



# 常见问题

1. 某一速率	为  100M  的交换机有  20  个端口，则每个端口的传输速率为（  ）

   ```
   100M
   ```

   交换机独享带宽；交换机与网桥的区别是交换机具有背板带宽容量，可以为每个端口分配相同带宽，这区别于网桥的带宽征用

   

2. 报文分组交换方式是把长的报文分成若干个较短的报文组，报文分组是交换单位，它与报文交换方式不同的是，报文分组交换有（）

   ```
   报文分组编号
   ```

     电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 

     报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 

     分组交换：单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查看转发表，转发到下一个结点。 

3. 运输层为运行在不同主机上的进程彼此之间提供了逻辑通信，而网络层则提供了主机之间的逻辑通信。（ ）

   ```
   正确
   ```

   传输层是进程到进程，俗称端到端。网络层是主机到主机，俗称点到点。 

4. 下面哪一个地址不能用作某个局域网内网IP（C）

   ```
   A.192.168.201.114
   
   B.172.16.4.25
   
   C.127.0.0.1
   
   D.10.0.0.1
   ```

     A类地址中，10.0.0.0到10.255.255.255是私有地址

     在B类地址中，172.16.0.0到172.31.255.255是私有地址

     在C类地址中，192.168.0.0到192.168.255.255是私有地址

     **127.0.0.1 本机回送地址  做测试用**

5. 下列关于单模光纤与多模光纤的区别描述错误的是？(B)

   ```
   
   A.光的传输方式不同
   
   B.带宽容量也不一样，多模光纤较大
   
   C.多模光纤用于短距离的系统
   
   D.单模光纤用于长距离的系统
   ```

   **单模**光纤传输模式单一，因此干扰小，**带宽大**，适合长距离传输
    多模光纤是在一条光纤中传输多条光路，适合短距离传输

6. 公司办公室的一台计算机通过IP可以访问外网，无法使用域名访问外部web服务器,造成这种情况可能的原因是（  A,B    ）

   ```
   A该计算机的DNS缓存有错
   
   B没有指定正确的DNS服务器
   
   C该计算机与DNS服务器IP地址在不同的网段
   
   D网关设置出错
   ```

     **IP地址与路由器网关地址必须在同一网段，DNS则不需要，DNS服务器地址一般由运营商指定；所以C错**

     **如果网关设置错误，不能访问外网。题目中是可以通过IP地址访问外网的；所以D错**

7. 总部给某分公司分配的网络地址是172.16.2.0/24,该分公司有三个部门（不同的部门属于不同的网段，即不同的网络标识），每个部门计算机不多于30台,在网络配置时，进行子网划分，可以使用的子网掩码是（B,C）

   ```
   A.255.255.255.128
   
   B.255.255.255.192
   
   C.255.255.255.224
   
   D.255.255.255.240
   ```

   利用子网掩码来划分网络标识和主机标识。同一网段内的主机的网络标识是一样的。同一网段内的主机的主机标识是不一样的。

     1.分公司的网络地址是172.16.2.0/24（其中24表示网络表示的长度），子网掩码长度就是24位11111111.11111111.11111111.00000000（子网掩码对应网络标识部分为1，对应主机表示部分为0.）； 

     2.分公司3个部门，那么就用第25位和第26位来区分三个部门，11111111.11111111.11111111.**11**000000（00~11），直接排除A； 

     3.那么各个部门用来区分自己的子网掩码只剩下最后6位（27~32位）来表示了； 

     4.若用255.255.255.192，最后8位是11000000，只能表示11000000~11111111除去广播地址一共62台
   

     5.若用255.255.255.224，最后8位是11100000，只能表示11100000~11111111除去广播地址一共30台
   

     6.若用255.255.255.240，最后8位是11110000，只能表示11110000~11111111除去广播地址一共14台 

8. 下面有关http keep-alive说法错误的是？(D)

   ```
   
   A.在HTTP1.0和HTTP1.1协议中都有对KeepAlive的支持。其中HTTP1.0需要在request中增加“Connection： keep-alive” header才能够支持，而HTTP1.1默认支持
   
   B.当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接
   
   C.可以在服务器端设置是否支持keep-alive
   
   D.当你的Server多为动态请求，建议开启keep-alive增加传输效率
   
   ```

     **HTTP/1.0**

   ​    在HTTP/1.0版本中，并没有官方的标准来规定Keep-Alive如何工作，因此实际上它是被附加到HTTP/1.0协议上，如果客户端浏览器支持Keep-Alive，那么就在HTTP请求头中添加一个字段 **Connection:  Keep-Alive**， 当服务器收到附带有Connection:  Keep-Alive的请求时，它也会在响应头中添加一个同样的字段来使用Keep-Alive。这样一来，客户端和服务器之间的HTTP连接就会被保  持，不会断开（超过Keep-Alive规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接 

     **HTTP/1.1**

     在HTTP/1.1版本中，官方规定的Keep-Alive使用标准和在HTTP/1.0版本中有些不同，默认情况下所在HTTP1.1中所有  连接都被保持，除非在请求头或响应头中指明要关闭：Connection: Close ，这也就是为什么Connection:  Keep-Alive字段再没有意义的原因。另外，还添加了一个新的字段Keep-Alive:，因为这个字段并没有详细描述用来做什么，可忽略它 

     Not reliable（不可靠） 

     HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive没能改变这个结果。另外，**Keep-Alive**也不能保证客户端和服  务器之间的连接一定是活跃的，在HTTP1.1版本中也如此。**唯一能保证的就是当连接被关闭时你能得到一个通知**，所以不应该让程序依赖于Keep-  Alive的保持连接特性，否则会有意想不到的后果 

9. ATM（异步传输模式）技术中“异步”的含义是（  C ） 

   ```
   A.采用的是异步串行通信技术
   
   B.网络接入用的是异步控制方式
   
   C.周期性地插入 ATM 信元
   
   D.可随时插入 ATM 信元
   ```

   ATM是一种传输模式，在这一模式中，信息被组织成信元，因包含来自某用户信息的各个信元不需要周期性出现，这种传输模式是异步的。

   是一种异步时分多路复用方式

10. 万维网用URL标识分布因特网上的各种文档。 

```
正确
```

URL 统一资源定位符  （网址） URI 统一资源标识符

11. 若将网络21.3.0.0/16划分为128个规模相同的子网，则每个子网可分配的最大可用IP地址个数是 。  

```
510
```

  21.3.0.0/16 

  子网掩码为 255.255.0.0 是标准的B类地址 

  由于要划分128个子网，那么继续划分子网后的子网掩码255.255.254.0 （11111111.11111111.11111110.00000000）

  每个子网中的主机号的范围是00000000 00000000 00000000 00000000 ~ 00000000 00000000  00000001 11111111 共512个但是要去掉全0和全1。**全0为本网段网络号，全1为广播地址**。所以共有510个可用IP （2^9-2=512-2=510）

12. 计算机接入Internet时，可以通过公共电话网进行连接。以这种方式连接并在连接时分配到一个临时性IP地址的用户，通常使用的是（）    

    ```
    SLIP/PPP协议连接方式
    ```

    SLIP是串行线路协议（Serial Line IP）的英文缩写。PPP是[点对点协议](https://baike.baidu.com/item/点对点协议)（Point to Point Protocol）的英文缩写。以这种方式入网时，用户所需要的硬件设备包括一台微型计算机、一条电话线、一台[调制解调器](https://baike.baidu.com/item/调制解调器)(MODEM)、一根RS-232电缆，利用调制解调器通过公共电话网进行Internet连接.

13. 代表以双绞线为传输介质的快速以太网（）。

    ```
    100BASE-T
    ```

    快速以太网是百兆带宽的，T代表twist指双绞线;F代表fiber指光纤

14. 在多路复用技术中，WDM表示为（  ）。

```
波分多路复用
```

  频分多路复用 Frequency-division multiplexing，FDM 

  波分多路复用 Wavelength Division Multiplexing, WDM 

  时分多路复用 Time-Division Multiplexing，TDM 

  空分多路复用 Space Division Multiplexing, SDM

15.以太网最小帧长为 ( )

```
64B
```

以太网的帧开销是18字节，是“目的MAC（6）＋源MAC（6）＋Type（2）＋CRC（4）”。以太网最小帧长为64字节，那么IP报文最小为46字节，而局域网规定IP最大传输单元1500字节，实际上加上以太网帧的18字节，就是1518字节。

按照标准，10Mbps以太网采用中继器时，连接最大长度为2500米，最多经过4个中继器(以太网中使用中继器的5-4-3-2-1原则)，因此规定对于10Mbps以太网规定一帧的最小发送时间必须为51.2μs。51.2μs也就是512位数据在10Mbps以太网速率下的传播时间，常称为512位时。这个时间定义为以太网时隙。512位时=64字节，因此以太网帧的最小长度为512位时=64字节。

16.如果子网掩码是255.255.192.0;那么下面哪个主机无须使用路由器即可与主机129．23．124．10通讯。（B）

```
A 129．23．191．21

B 129．23．127．222

C 129．23．130．33

D 129．23．148．127
```

  

//与主机129．23．124．10可以通信的话即要求两个主机在一个网段(网络标识相同)； 

子网掩码：1111 1111 . 1111 1111 . **1100 0000** . 0000 0000

IP地址：（前16位都相同就不写了）

124：=01111100；

191：=10111111;

127：=01111111

130：=10000010

148：=10010100

考虑124与192作位运算：

```
1100 0000 //192
0111 1100 //124
---------
0100 0000 //64
```

所以主机129．23．124．10的网络标识为129．23．64．0 / 18

考虑191与192作位运算：

```
1100 0000 //192
1011 1111 //191
---------
1000 0000 //128
```

所以A 129．23．191．21的网络标识为129．23．128．0 / 18，与目标主机网络标识不一样。

可以分别验证BCD选项。发现只有B的网络标识与目标主机标识一样

17. IP地址块为211.168.15.192/26、211.168.15.160/27和211.168.15.128/27三个地址块经聚合后可用地址数为（）？

```
126
```

  

  **211.168.15. 11**000000 /26

   **211.168.15. 101**00000 /27  

   **211.168.15. 100**00000  /27

   可得聚合地址块为**211.168.15. 1**0000000 /25，即211.168.15. 128  

   掩码是IP二进制前面相同的位数，由于从    1～25位三个子网完全相同，所以经过聚合后的地址为211.168.15. 128/25  

   所以可用地址为：2^(32-25)-2=126  

18. 以下情况下不一定出现TCP分节RST的情况是：（C）

    ```
    
    
    服务器端端口未打开而客户端来连接时
    
    SO_RCVTIMEO选项设置了超时时间并超时
    
    C. 服务器主机崩溃后重启
    
    在一个已关闭的socket上收到数据
    
    
    ```

      TCP首部有6个标志比特，也叫标志位，分别是URG(紧急指针有效)、ACK(确认序号有效)、PSH(接收方应该尽快将这个报文段交给应用层)、**RST(重置连接、复位连接)**、SYN(同步序号用来发起一个连接)、FIN(发送端完成发送任务)。 

      一般来说，无论何时一个报文段发往基准的连接（由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接）出现错误，TCP都会发出一个复位报文段。 

      一般出现RST的集中场景：1.访问不存在的端口连接请求；2.异常终止一个连接；3.检查半打开连接。 

19.   若下图为10 BaseT 网卡接收到的信号波形，则该网卡收到的比特串是（ ）。

    ​      ![img](https://uploadfiles.nowcoder.com/images/20161106/3814779_1478426963766_BE8C5FA0AAFCF3881F972982BADD3944)    

    ```
    0011 0110
    ```

    

      以太网数据编码格式为：**曼彻斯特编码**

      **编码规则为：1.**位中间电平从高到低跳变表示"0"（即下降沿），位中间电平从低到高跳变表示"1"（即上升沿）。 

    ​             **或者 2.**位中间  电平从高到低跳变表示"1"，位中间电平从低到高跳变表示"0"。 

      ![img](https://uploadfiles.nowcoder.com/images/20170402/2178882_1491120445805_017817989C503B011C0C1E8899CD7F03)

      因此答案为1：11001001  或者2：00110110 选A 

20. 下面有关TCP协议的描述，说法错误的是？(D)

    ```
    
    A.TCP使用窗口机制进行流量控制
    
    B. 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，需要四次握手
    
    C. TCP连接建立需要三次握手
    
    D. 被动关闭socket后，会进入到TIME_WAIT状态
    
    ```

    答案解析：TCP是面向连接的服务；三次握手（建立连接）和四次挥手（关闭连接）；使用滑动窗口机制进行流量控制；TCP要保证在所有可能的情况下使得所有的数据都能够被投递，**当你关闭一个socket时，<u>主动关闭一端</u>的socket将进入TIME_WAIT状态，而<u>被动关闭一方</u>则转入CLOSED状态，这的确能够保证所有的数据都被传输**。所以D说法错误 

21. 信道利用率最高的是（B   ）

    ```
    A.停等协议
    
    B. 选择性重传
    
    C. GBN
    ```

      停止等待协议（stop-and-wait）是最简单但也是最基础的数据链路层协议。很多有关协议的基本概念都可以从这个协议中学习到。  

      停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。  

      特点：最简单的设计，发送一帧，确认一帧。  

      

      回退n帧的ARQ-也叫做GBN  

      发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。  

      特点：（GBN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的  

      

      选择性重传ARQ  

      发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。  

      特点：相对于GDN 复杂度高，但是不需要发送没必要的帧，所以效率高。 

     

      所以信道利用率最高的是 选择性重传ARQ > 回退n帧的GBN > 停止等待协议（stop-and-wait）  

22. 交换机工作在OSI七层的哪一层？（ ）

```
二层
```

  物理层： 

  中继器，集线器，双绞线 

  数据链路层： 

  网桥，以太网交换机，网卡（一半物理层，一半数据链路层） 

  网络层： 

  路由器，三层交换机 

  传输层： 

  四层交换机（常用作负载均衡），网关：对高层协议（包括传输层及更高层次）进行转换的网间连接器





23. What the message in NetworkLayer is called? ( )

    ```
    datagram
    ```

      应用层：	文 （message） 

      运输层：报文段 （Segment） 

      网络层：数据报  （    **datagram**  ） 

      链路层：帧（    **Frame**  ） 

      物理层：比特（**bit**） 

24. UDP使用（ B）提供可靠性

```
A.网际协议

B.应用层协议

C.网络层协议

D.传输控制
```

UDP无连接的传输层协议，可靠性由应用层来实现

25. 利用 FQDN 来查询 IP 地址的操作称为：

```
A.递归查询

B.反复查询

C.正向名称查询

D.反向查询
```

**FQDN**是完全合格域名/全程域名缩写（Fully Qualified Domain Name）：**“主机名”+“域名”+“.”** 组成。 

- ​     FQDN 来查询 IP 地址的操作称为**正向名称查询**。   
- ​    IP查询FQDN称为**反向名称查询**。   
- ​    递归查询：一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后,若[DNS服务器](https://www.baidu.com/s?wd=DNS服务器&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)本身不能解析,则会向另外的[DNS服务器](https://www.baidu.com/s?wd=DNS服务器&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)发出查询请求，得到结果后转交给客户机。   
- ​    反复查询：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。

26. 星形结构的网络采用的是广播式的传播方式。（    ）

```
错误
```

```
星型拓扑图：点到点式；
总线型：广播式；
环形式：点到点；
树形式：点到点；
网状：点到点和广播式
```

27. 下列有关Socket的说法，错误的是（B）

```
A.Socket用于描述IP地址和端口，是一个通信链的句柄

B.Socket通信必须建立连结

C.Socket客户端的端口是不固定的

D.Socket服务端的端口是固定的
```

socket 可以基于TCP 面向连接 也可以基于UDP无连接

28. HTTP协议中，表示请求的内容自上次请求后没有改变，服务端返回的状态码是?

```
304
```

- 301 Move Permanently 资源已经被永久改变了位置  
- 304 Not Modified 自上次未修改  
- 401 Unauthorized 未授权  
- 404 Not Found error

> ```
> 当浏览器第一次加载资源的时候，返回一般为200，意思是成功获取资源，并会在浏览器的缓存中记录下max-age，第二次访问的时候：
> 如果只是用浏览器打开，那么浏览器会去判断这个资源在缓存里有没有，如果有的话，会去判断max-age，看看过期没有，如果没有过期，则直接读缓存，根本不会和服务器进行交互，换句话说，断网都能打开，就和本地跑一样！如果已经过期了，那就去服务器请求，等待服务器响应，这是很费时间的，服务器如果发现资源没有改变过，那么就会返回304，告诉浏览器，我没变过，你去读缓存吧，于是浏览器也不用从服务器拉数据了
> ```

29. 适合于特大和大城市的本地网的网路组织是？

```
A.覆盖单汇接局结构

B.覆盖双汇接局结构

C.分区单汇接局结构

D.分区双汇接局结构
```

> ​      **根据本地网的业务覆盖范围和通信容量的不同，可以有其不同的网路组织方式。**     
>
> ​      **1、适合于特大和大城市的本地网的网路组织**   
>
>   采用分区双汇接局结构。将本地网划分成若干个汇接区，每个汇接区内设置两个大容量的汇接局，覆盖区内的每个端局；当汇接局均为端/汇合一局（用DTm/DL）时，全网的所有汇接局间为个个相连的网状网；当某一个汇接区内的两个汇接局均为纯汇接局时，这两个汇接局之间不需相连。 
>
> ​      **2、适合于中等城市的本地网的网路组织**   
>
>   采用汇接局全覆盖结构。在全网设置2～3汇接局，对全网的端局全覆盖，汇接局一般设置在本地网的中心城市，并且相互之间采用网状网结构。 
>
> ​      **3、适合于较小本地网的网路组织**   
>
>   采用一级（无汇接局）网状网结构。

30.检错码采用冗余编码技术，即在每个传输的数据块中附加足够多的冗余信息，以便在接受端能发现并自动纠正传输差错。请问这句话的说法是正确的吗？

```
错误
```

**检错码**只能检查有没有错误；**纠错码**可以发现错误并且纠正。

31.以太网的介质访问控制方式是（）。

```
CSMA/CD
```


