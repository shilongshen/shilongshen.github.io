<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>我的个人博客</title>
        <link>https://shilongshen.github.io/</link>
        <description>这是我的全新 Hugo 网站</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 22 Mar 2021 09:54:48 &#43;0800</lastBuildDate>
            <atom:link href="https://shilongshen.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>算法题记录</title>
    <link>https://shilongshen.github.io/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
    <pubDate>Mon, 22 Mar 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/%E7%AE%97%E6%B3%95%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
    <description><![CDATA[树 重建二叉树 链接
最大二叉树 链接
合并二叉树 链接
二叉搜索树中的搜索 链接
验证二叉搜索树 链接
二叉搜索树的绝对值之差 链接
二叉搜索树的众数 链接
二叉树的最近公共祖先 链接
二叉搜索树的最近公共祖先 链接
二叉搜索树的插入操作 链接
二叉搜索树的删除操作 链接
二叉搜索树的修剪 链接
将二叉树转换为累加树 链接
翻转二叉树 链接
二叉树的前序遍历 链接
二叉树的中序遍历 链接
二叉树的后序遍历 链接
二叉树的层序遍历 链接
二叉树的层序遍历2 链接
N叉树的层序遍历 链接
从上到下打印二叉树 链接
二叉搜索树中第k小的元素 链接
将有序数组转换为二叉搜索树 链接
将有序链表转换为二叉搜索树 链接
二叉树的右视图 链接
二叉树的层平均值 链接
二叉树的层最大值 链接
填充每个节点的下一个右侧节点指针 链接
树的子结构 链接
另一棵树的子树 链接
对称二叉树 链接
相同的树 链接
二叉树的最大深度 链接
N叉树的最大深度 链接
二叉树的最小深度 链接]]></description>
</item><item>
    <title>背包问题</title>
    <link>https://shilongshen.github.io/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
    <pubDate>Mon, 22 Mar 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
    <description><![CDATA[0-1背包 背包问题的关键因素：
 背包的重量 物品的重量以及物品的价值 如果物品不可以重复放入则是0-1背包问题 &ndash;&gt;背包进行倒序遍历 每个物品只有两种状态：放入背包/不放入背包 &ndash;&gt;max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])  使用二维数组进行解决
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package Dynamic;import java.util.Arrays;public class bean12 {public static void main(String[] args) {int[] weight={1,3,4};int[] value={15,20,30};int bagweight=4;int[][] dp=new int[weight.]]></description>
</item><item>
    <title>Maven</title>
    <link>https://shilongshen.github.io/maven/</link>
    <pubDate>Wed, 10 Mar 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/maven/</guid>
    <description><![CDATA[Maven的核心概念 约定的目录结果 例如在com.maven中建立Hello项目
Hello |&mdash;src |&mdash;|&mdash;main |&mdash;|&mdash;|&mdash;java |&mdash;|&mdash;|&mdash;resources |&mdash;|&mdash;test |&mdash;|&mdash;|&mdash;java |&mdash;|&mdash;|&mdash;resources |&mdash;pom.xml
POM Project Object Model,项目对象模型
pom.xml对于Maven工程是核心配置文件，与构建过程相关的一切设置都在这个文件中进行设置。
坐标 使用下面三个坐标在仓库中唯一定位一个maven工程
  group：公司或组织域名倒序+项目名
1  &lt;groupid&gt;com.maven&lt;/groupid&gt;    artifactid：模块名
1  &lt;artifactid&gt;Hello&lt;/artifactid&gt;    version：版本
1  &lt;version&gt;1.0.0&lt;/version&gt;    1 2 3 4 5 6 7  &lt;！--例--&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;对应路径C:\Users\ssl\.m2\repository\junit\junit\4.12\junit-4.12.jar  依赖   maven解析依赖信息时会到本地仓库中查找被依赖的jar包
 对于我们自己开发的maven工程，使用**mvn install **命令安装后就可以进入仓库    依赖的范围]]></description>
</item><item>
    <title>SpringBoot</title>
    <link>https://shilongshen.github.io/springboot/</link>
    <pubDate>Wed, 10 Mar 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/springboot/</guid>
    <description><![CDATA[1、Spring Boot简介 什么是Spring Boot ：
 Spring Boot用于简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案  优点：
 快速创建独立运行的Spring项目以及与主流框架集成 使用嵌入式的Servlet容器，应用无需打包WAR包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可以修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成  2、微服务 微服务是一种架构风格
一个应用应该是一组小型服务；可以通过HTTP的方式进行沟通；
每一个功能元素最终都是一个可独立替换和独立升级的软件单元；
基本介绍 HelloWorld   创建maven工程
  引入依赖
1 2 3 4 5 6 7 8 9 10 11 12  &lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.4.3&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt;    编写主程序
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  package com.]]></description>
</item><item>
    <title>SpringMVC</title>
    <link>https://shilongshen.github.io/springmvc/</link>
    <pubDate>Wed, 10 Mar 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/springmvc/</guid>
    <description><![CDATA[什么是SpringMVC Spring MVC 是 Spring 提供给 Web 应用的框架设计
MVC 参考
首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。
 M 代表 模型（Model） 模型是什么呢？ 模型就是数据，就是 dao,bean V 代表 视图（View） 视图是什么呢？ 就是网页, JSP，用来展示模型中的数据;主要负责接受Servlet传递的内容，调用JavaBean，将内容显示给用户 C 代表 控制器（controller) 控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。主要负责所有用户的请求参数，判断请求参数是否合法，根据请求的类型调用JavaBean，将最终的处理结果交给显示层显示！    传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。
 特点： 结构松散，几乎可以在 Spring MVC 中使用各类视图 松耦合，各个模块分离 与 Spring 无缝集成   从图 1 可总结出 Spring MVC 的工作流程如下：]]></description>
</item><item>
    <title>JDBC</title>
    <link>https://shilongshen.github.io/jdbc/</link>
    <pubDate>Wed, 10 Feb 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/jdbc/</guid>
    <description><![CDATA[什么是JDBC JDBC API 允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据。
JDBC(Java DataBase Connectivity, 简称JDBC)是Java中用于规范应用程序如何来访问数据库的应用程序接口(API),它提供了查询和更新数据库中数据的方法。
执行流程：
 连接数据源，如：数据库。 为数据库传递查询和更新指令。 处理数据库响应并返回的结果。  在Java程序和数据库之间的一个桥梁。
JDBC架构 两层 三层 JDBC 编程步骤 加载驱动程序：
1 2 3 4 5  Class.forName(driverClass)//加载MySql驱动Class.forName(&#34;com.mysql.jdbc.Driver&#34;)//加载Oracle驱动Class.forName(&#34;oracle.jdbc.driver.OracleDriver&#34;)  获得数据库连接：
1  DriverManager.getConnection(&#34;jdbc:mysql://127.0.0.1:3306/imooc&#34;, &#34;root&#34;, &#34;root&#34;);  创建Statement或PreparedStatement对象：
1 2  conn.createStatement();conn.prepareStatement(sql);  完整实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package com.]]></description>
</item><item>
    <title>Spring</title>
    <link>https://shilongshen.github.io/spring/</link>
    <pubDate>Wed, 10 Feb 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/spring/</guid>
    <description><![CDATA[1.Spring框架概述 是什么  是一个轻量级的开源的JavaEE框架 解决企业应用开发的复杂性 有两个核心部分：IOC和AOP  IOC:控制反转，把创建对象的过程交给Spring进行管理 AOP:面向切面，不修改源代码进行功能增强    特点  方便解耦，简化开发 AOP的支持方便程序的测试 方便和其他框架进行整合 降低Java EE API的开发难度 方便事务的操作  入门案例 1.下载地址： https://repo.spring.io/release/org/springframework/spring/ #spring-5.2.6.RELEASE-dist.zip 28-Apr-2020 08:22 82.25 MB
2.使用IDEA创建project
3.导入Spring的jar包 commons-logging-1.1.1.jar spring-beans-5.2.6.RELEASE.jar spring-context-5.2.6.RELEASE.jar spring-core-5.2.6.RELEASE.jar spring-expression-5.2.6.RELEASE.jar
4.创建普通类，在这个类创建普通方法
1 2 3 4 5 6  package com.bean1;public class User {public void add(){System.out.println(&#34;hello world!&#34;);}}  5.创建Spring配置文件，在配置文件配置创建的对象 (1)Spring配置文件使用XML格式
1 2 3 4 5 6 7 8  &lt;?]]></description>
</item><item>
    <title>SpringBoot运行时错误记录</title>
    <link>https://shilongshen.github.io/springboot%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</link>
    <pubDate>Wed, 10 Feb 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/springboot%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</guid>
    <description><![CDATA[java.sql.SQLException: The server time zone value &lsquo;�й���׼ʱ��&rsquo; is unrecognized 参考
解决方法:
1  在URL上加上：?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8  Establishing SSL connection without server‘s identity verification is not recommende 参考
解决方法
1 2 3 4 5 6 7  在你连接数据库的url后面加上参数即可jdbc:mysql://localhost:3306/testdb?useSSL=false使用上述标红的URL,即可解决该警告,标红参数前面为你数据库连接URL,如果有多个参数记得用&amp;连接,例如jdbc:mysql://localhost:3306/testdb?characterEncoding=utf-8&amp;useSSL=false  template might not exist or might not be accessible by any of the configured Template Resolvers 解决方法：
在application.yaml中设置
1 2 3  spring:thymeleaf:prefix:classpath:/templates/  注意：thymeleaf 的classpath要多一个斜杠的，漏斜杠就会有问题]]></description>
</item><item>
    <title>个人博客搭建</title>
    <link>https://shilongshen.github.io/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
    <pubDate>Wed, 10 Feb 2021 09:54:48 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
    <description><![CDATA[技术组合：
 后端：Spring Boot，JPA，thymeleaf模板 数据库:MySQL 前端UI：Semantic UI框架  工具与环境：
 IDEA Maven 3 JDK 8 Axure RP8 &ndash;&gt;页面原型设计工具  异常处理 拦截异常：自定义400，500, error异常页面
1 2 3 4 5 6 7 8 9 10  &lt;!DOCTYPEhtml&gt;&lt;html lang=&#34;en&#34;&gt;&lt;head&gt;&lt;meta charset=&#34;UTF-8&#34;&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;  1 2 3 4 5 6 7 8 9 10 11  &lt;!DOCTYPEhtml&gt;&lt;html lang=&#34;en&#34;&gt;&lt;head&gt;&lt;meta charset=&#34;UTF-8&#34;&gt;&lt;title&gt;500&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;500&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  &lt;!]]></description>
</item><item>
    <title>回溯算法</title>
    <link>https://shilongshen.github.io/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
    <pubDate>Thu, 04 Feb 2021 09:17:30 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://shilongshen.github.io/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
    <description><![CDATA[参考
 「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。
 递归之后需要做和递归之前相同的逆向操作   问题1 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
我们尝试在纸上写 333 个数字、444 个数字、555 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。
先写以 111 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）； 再写以 222 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列； 最后写以 333 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。  总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。
  每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」； 使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；]]></description>
</item></channel>
</rss>
