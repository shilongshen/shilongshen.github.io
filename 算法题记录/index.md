# 算法题记录


# 树

## 重建二叉树

[链接](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/zhong-jian-er-cha-shu-by-shilongshen-kgmh/)

## 最大二叉树

[链接](https://leetcode-cn.com/problems/maximum-binary-tree/solution/zui-da-er-cha-shu-by-shilongshen-f33h/)

## 合并二叉树

[链接](https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-shilongshen-r2gz/)

## 二叉搜索树中的搜索

[链接](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-sou-suo-by-s-ja6k/)

## 验证二叉搜索树

[链接](https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-shilongs-zi62/)

## 二叉搜索树的绝对值之差

[链接](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/solution/er-cha-sou-suo-shu-de-jue-dui-zhi-zhi-ch-c5j1/)

## 二叉搜索树的众数

[链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-qqz2/)

## 二叉树的最近公共祖先

[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zui-xian-vct9/)

## 二叉搜索树的最近公共祖先

[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zui-xian-vct9/)

## 二叉搜索树的插入操作

[链接](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-cha-ru-cao-zuo-by-qclrw/)

## 二叉搜索树的删除操作

[链接](https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/er-cha-sou-suo-shu-de-cha-ru-cao-zuo-by-oquz3/)

## 二叉搜索树的修剪

[链接](https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-shilongsh-yqvs/)

## 将二叉树转换为累加树

[链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/ba-er-cha-sou-suo-shu-zhuan-huan-wei-lei-ffxa/)

## 翻转二叉树

[链接](https://leetcode-cn.com/problems/invert-binary-tree/solution/fan-zhuan-er-cha-shu-by-shilongshen-aduf/)

## 二叉树的前序遍历

[链接](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

## 二叉树的中序遍历

[链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/)

## 二叉树的后序遍历

[链接](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)

## 二叉树的层序遍历

[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-shilong-n5v0/)

## 二叉树的层序遍历2

[链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/solution/er-cha-shu-de-ceng-xu-bian-li-2-by-shilo-5258/)

## N叉树的层序遍历

[链接](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/solution/ncha-shu-de-ceng-xu-bian-li-by-shilongsh-wz6o/)

## 从上到下打印二叉树

[链接](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/cong-shang-dao-xia-da-yin-er-cha-shu-by-vvh0e/)

## 二叉搜索树中第k小的元素

[链接](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/submissions/)

## 将有序数组转换为二叉搜索树

[链接](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

## 将有序链表转换为二叉搜索树

[链接](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/submissions/)

## 二叉树的右视图

[链接](https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/er-cha-shu-de-you-shi-tu-by-shilongshen-ikk3/)

## 二叉树的层平均值

[链接](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/solution/er-cha-shu-de-ceng-ping-jun-zhi-by-shilo-i24a/)

## 二叉树的层最大值

[链接](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/solution/zai-mei-ge-shu-xing-zhong-zhao-zui-da-zh-cs7f/)

## 填充每个节点的下一个右侧节点指针

[链接](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-v1egb/)

## 树的子结构

[链接](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/shu-de-zi-jie-gou-by-shilongshen-4i34/)

## 另一棵树的子树

[链接](https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ke-shu-de-zi-shu-by-shilongshen-5dhp/)

## 对称二叉树

[链接](https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-shilongshen-ptox/)

## 相同的树

[链接](https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-shilongshen-s1qn/)

## 二叉树的最大深度

[链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-shilongs-7e1s/)

## N叉树的最大深度

[链接](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/solution/ncha-shu-de-shen-du-by-shilongshen-jaq0/)

## 二叉树的最小深度

[链接](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-shilon-evjf/)

## 完全二叉树的节点个数

[链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-b-ylvw/)

## 平衡二叉树

[链接](https://leetcode-cn.com/problems/balanced-binary-tree/submissions/)

## 左叶子之和

[链接](https://leetcode-cn.com/problems/sum-of-left-leaves/solution/zuo-xie-zi-zhi-he-by-shilongshen-ze0q/)

## 找树左下角的值

[链接](https://leetcode-cn.com/problems/find-bottom-left-tree-value/solution/zhao-shu-zuo-xia-jiao-de-zhi-by-shilongs-zw8f/)

## 路径总和

[链接](https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-shilongshen-p67v/)



# 回溯算法

## 全排列

[链接](https://shilongshen.github.io/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/)

## 全排列2

[链接](https://shilongshen.github.io/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/)

## 子集

[链接](https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-shilongshen-lr2r/)

## 子集2

[链接](https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-shilongshen-lr2r/)

## 组合

[链接](https://leetcode-cn.com/problems/combinations/solution/zu-he-zu-he-2-by-shilongshen-dh1g/)

## 组合总和

[链接](https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-shilongshen-c7mq/)

## 小结

1.

全排列：结果是有序的，即[1,2,3]和[2,1,3]是两个**不同**的结果

组合：结果是无序的，即[1,2,3]和[2,1,3]是**相同**的结果

那么这两者的处理方式分别是什么呢：

<u>针对组合问题</u>，具体的做法是：**每一次搜索的时候设置 下一轮搜索的起点 begin**

```java
#对于全排列问题
    class  Solution {
    public List<List<Integer>>  permute(int[] nums){
        int len= nums.length;
        List<List<Integer>> res=new ArrayList<>();
        if (len==0) return res;

        Deque<Integer> path=new ArrayDeque<>(len);
        boolean[] used=new boolean[len];
        dfs(nums,len,0,path,used,res);
        return res;
    }
   
    private void dfs(int[] nums, int len, int depth, Deque<Integer> path, boolean[] used, List<List<Integer>> res) {
        if (depth==len) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i=0;i<len;i++){//注意这里是i=0,表示每一次遍历都是遍历整个数组中的元素
            if (!used[i]){
                path.add(nums[i]);
                used[i]=true;

                dfs(nums, len, depth+1, path, used, res);

                used[i]=false;
                path.removeLast();
            }
        }
    }
}

```

```java
#组合问题
    class Solution {
    public List<List<Integer>> combine(int n, int k) {

        List<List<Integer>> res = new ArrayList<>();
        if (n == 0) return res;
        int[] nums = new int[n];//先将其转换为数组
        for (int i = 1; i <= n; i++) {
            nums[i - 1] = i;
        }


        Deque<Integer> path = new ArrayDeque<>();
//采用深度优先遍历的方式，begin表示从剩下的元素中挑选元素，例如在[1,2,3,4]中先选1后，只能够在[2,3,4]中挑选元素
        dfs(nums, 0, k, 0, path, res);
        return res;

    }

    private void dfs(int[] nums, int depth, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
        if (depth == k) {//depth表示path中的元素个数
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i < nums.length; i++) {//使用begin设置下一轮的搜索起点，这样能保证解是无序的

            path.add(nums[i]);

            dfs(nums, depth + 1, k, i + 1, path, res);//因为使用过的元素是不能够再次使用的，所以是i+1；
            //如果使用过的元素是能够再次使用的，则为i

            path.removeLast();

        }
    }
}

```

2.

对于子集中

可以对每一层选与不选元素进行分类，最后的叶子节点即为所求结果



3.

对于全排列2中，因为数组存在重复元素，为了删除重复的结果集，所以需要采用剪枝操作。

大体的思想就是

> 通过 `i>0&&nums[i]==nums[i-1]&&!used[i-1]`
> 可以让同一层级，不出现相同的元素。即
>                   1
>                  / \
>                 2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：
>                /     \
>               5       5
>                 例2
>                   1
>                  /
>                 2      这种情况确是允许的
>                /
>               2  

对于子集2中，数组中的元素存在重复元素，同样的通过`i>begin&&nums[i]==nums[i-1]`来保证同一层中不出现重复元素

对于组合总和问题2，其实最大的不同也就是元素存在重复元素，解决方式同样是`i > begin && candidates[i] == candidates[i - 1]`来保证同一层不出现重复元素。

这里可以看出

- 如果**解的无序**的，就使用`begin`变量来设置下一轮搜索起点
- 如果**数组中存在重复元素**，就利用类似`i > begin && candidates[i] == candidates[i - 1]`的方式来保证同一层不出现重复元素。以此进行剪枝操作。

## 排列序列

[链接](https://leetcode-cn.com/problems/permutation-sequence/solution/pai-lie-xu-lie-by-shilongshen-x3wh/)

## 二叉树的所有路径

[链接](https://leetcode-cn.com/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-shilong-4pk9/)

## 二叉树中和为某一值的路径

[链接](https://shilongshen.github.io/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/)

## 递增子序列

[链接](https://leetcode-cn.com/problems/increasing-subsequences/submissions/)

## 划分为k个相等的子集

[链接](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/submissions/)

# 动态规划

## 零钱兑换

[链接](https://leetcode-cn.com/problems/coin-change/solution/ling-qian-dui-huan-by-shilongshen-1gcj/)

## 爬楼梯

[链接](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-shilongshen-rehs/)

## 使用最小花费爬楼梯

[链接](https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-s-lakv/)

## 将数字翻译成字符串

[链接](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/solution/jiang-shu-zi-zhuan-huan-wei-zi-fu-chuan-ck53w/)

## 解码方法

[链接](https://leetcode-cn.com/problems/decode-ways/solution/jie-ma-fang-fa-by-shilongshen-wal1/)

## 完全平方数

[链接](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-shilongshen-n5wl/)

## 整数拆分

[链接](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-shilongshen-e7o4/)

## 单词拆分

[链接](https://leetcode-cn.com/problems/word-break/submissions/)

## 组合总和4

[链接](https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-shilongshen-c7mq/)

## 零钱兑换2

[链接](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-2-by-shilongshen-0vuu/)

## 分割等和子集

[链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-shilongshen-ctj7/)

## 最后一块石头的重量

[链接](https://leetcode-cn.com/problems/last-stone-weight-ii/solution/zui-hou-yi-kuai-shi-tou-de-zhong-liang-b-n691/)

## 目标和

[链接](https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-shilongshen-uz0y/)

## 一和零

[链接](https://leetcode-cn.com/problems/ones-and-zeroes/solution/yi-he-ling-by-shilongshen-1iva/)

## 连续子数组的最大和

[链接](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/lian-xu-zi-shu-zu-de-zui-da-he-by-shilon-w3cs/)

## 连续子数组的最大乘积

[链接](https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-shilongshen-rndm/)

## 最长连续递增子序列

[链接](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/solution/zui-chang-lian-xu-di-zeng-zi-xu-lie-by-s-4zdh/)

## 最长递增子序列

[链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-by-shilongsh-llx9/)

## 最长递增子序列的个数

[链接](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-4kcg/)

## 无重叠区间

[链接](https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-shilongshen-i2ka/)

## 最长数对链

[链接](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/zui-chang-shu-dui-lian-by-shilongshen-i9zt/)

## 礼物的最大价值

[链接](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/li-wu-de-zui-da-jie-zhi-by-shilongshen-yms9/)

## 打家劫舍

[链接](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-shilongshen-i9d0/)

## 打家劫舍2

[链接](https://leetcode-cn.com/problems/house-robber-ii/solution/da-jia-jie-she-2-by-shilongshen-apdm/)

## 打家劫舍3

[链接](https://leetcode-cn.com/problems/house-robber-iii/solution/shu-xing-dp-ru-men-wen-ti-by-liweiwei1419/)

## 不同路径

[链接](https://leetcode-cn.com/problems/unique-paths/solution/bu-tong-lu-jing-by-shilongshen-qacu/)

## 不同路径2

[链接](https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-2-by-shilongshen-qce8/)

## 买卖股票的最佳时机

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-by-shi-0nld/)

## 买卖股票的最佳时机2

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-h99l6/)

## 买卖股票的最佳时机含冷冻期

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-wci7v/)

## 买卖股票的最佳时机含手续费

[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-5mxg/)

## 最长公共子序列

[链接](https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-shilong-8h0k/)

## 回文子串

[链接](https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-shilongshen-2b4o/)
