<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>排序算法 - 我的个人博客</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="排序算法" />
<meta property="og:description" content="排序的稳定性 稳定性指的是对于序列中相同元素，经过排序后， 其前后位置并没有发生改变，则为稳定排序，否则不稳定。
冒泡排序  两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
 初级版本 每一个位置的数字，都与比它的下标大的数字进行比较（从前往后比较）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class bean2 {public static void main(String[] args) {int[] nums={9,1,5,8,3,7,4,6,2};Solution solution=new Solution();System.out.println(Arrays.toString(solution.sort(nums)));}}class Solution{public int[] sort(int[] nums){for (int i=0;i&lt;nums.length;i&#43;&#43;){for(int j=i&#43;1;j&lt; nums.length;j&#43;&#43;){if (nums[i]&gt;nums[j]){swap(i,j,nums);}}}return nums;}private void swap(int a,int b,int[] nums){//交换数组下标为a,b的两个数 int temp=nums[a];nums[a]=nums[b];nums[b]=temp;}}  冒泡排序 将最小值依次从底端交换到顶端，这一过程形象的称为冒泡排序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
<meta property="og:image" content="https://shilongshen.github.io/logo.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://shilongshen.github.io/logo.png"/>

<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="排序的稳定性 稳定性指的是对于序列中相同元素，经过排序后， 其前后位置并没有发生改变，则为稳定排序，否则不稳定。
冒泡排序  两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
 初级版本 每一个位置的数字，都与比它的下标大的数字进行比较（从前往后比较）。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class bean2 {public static void main(String[] args) {int[] nums={9,1,5,8,3,7,4,6,2};Solution solution=new Solution();System.out.println(Arrays.toString(solution.sort(nums)));}}class Solution{public int[] sort(int[] nums){for (int i=0;i&lt;nums.length;i&#43;&#43;){for(int j=i&#43;1;j&lt; nums.length;j&#43;&#43;){if (nums[i]&gt;nums[j]){swap(i,j,nums);}}}return nums;}private void swap(int a,int b,int[] nums){//交换数组下标为a,b的两个数 int temp=nums[a];nums[a]=nums[b];nums[b]=temp;}}  冒泡排序 将最小值依次从底端交换到顶端，这一过程形象的称为冒泡排序"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><link rel="prev" href="https://shilongshen.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" /><link rel="next" href="https://shilongshen.github.io/mysql/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "排序算法",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/shilongshen.github.io\/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\/"
        },"genre": "posts","wordcount":  922 ,
        "url": "https:\/\/shilongshen.github.io\/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\/","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "shilongshen"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="我的个人博客">首页</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="我的个人博客">首页</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">排序算法</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>shilongshen</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="0001-01-01">0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;922 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;5 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#排序的稳定性">排序的稳定性</a></li>
    <li><a href="#冒泡排序">冒泡排序</a>
      <ul>
        <li><a href="#初级版本">初级版本</a></li>
        <li><a href="#冒泡排序-1">冒泡排序</a></li>
        <li><a href="#冒泡排序的优化">冒泡排序的优化</a></li>
        <li><a href="#冒泡排序复杂度分析">冒泡排序复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#简单选择排序">简单选择排序</a>
      <ul>
        <li><a href="#简单选择排序复杂度分析">简单选择排序复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#直接插入排序法">直接插入排序法</a>
      <ul>
        <li><a href="#复杂度分析">复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#希尔排序">希尔排序</a>
      <ul>
        <li><a href="#复杂度分析-1">复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#堆排序">堆排序</a>
      <ul>
        <li><a href="#复杂度分析-2">复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#归并排序">归并排序</a>
      <ul>
        <li><a href="#复杂度分析-3">复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#快速排序">快速排序</a>
      <ul>
        <li><a href="#复杂度分析-4">复杂度分析</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a>
      <ul>
        <li><a href="#常用排序算法的分类">常用排序算法的分类</a></li>
        <li><a href="#复杂度比较">复杂度比较</a></li>
        <li><a href="#动画演示">动画演示</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="排序的稳定性">排序的稳定性</h1>
<p><strong>稳定性</strong>指的是对于序列中相同元素，经过排序后， 其前后位置并没有发生改变，则为稳定排序，否则不稳定。</p>
<p><img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210330153655.png" style="zoom:80%;" /></p>
<h1 id="冒泡排序">冒泡排序</h1>
<blockquote>
<p>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
</blockquote>
<h2 id="初级版本">初级版本</h2>
<p>每一个位置的数字，都与比它的下标大的数字进行比较（从前往后比较）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">bean2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">=</span><span class="o">{</span><span class="n">9</span><span class="o">,</span><span class="n">1</span><span class="o">,</span><span class="n">5</span><span class="o">,</span><span class="n">8</span><span class="o">,</span><span class="n">3</span><span class="o">,</span><span class="n">7</span><span class="o">,</span><span class="n">4</span><span class="o">,</span><span class="n">6</span><span class="o">,</span><span class="n">2</span><span class="o">}</span><span class="o">;</span>
        <span class="n">Solution</span> <span class="n">solution</span><span class="o">=</span><span class="k">new</span> <span class="n">Solution</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">solution</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                    <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span><span class="c1">//交换数组下标为a,b的两个数
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="冒泡排序-1">冒泡排序</h2>
<p>将最小值依次从底端交换到顶端，这一过程形象的称为冒泡排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">2</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">-</span><span class="o">-</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                    <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210322224825.png" /></p>
<h2 id="冒泡排序的优化">冒泡排序的优化</h2>
<p>如果数组为[2,1,3,4,5,6,7,8,9],那么我们只需要进行一次排序(i==0)，将1，2进行交换，就可以得到排序的数组；不需要再进行<code>i==1,i==2,...,i==nums.length-1</code>这些循环了。</p>
<p>为了达到这一个目的，可以设置一个flag.。</p>
<p>例如[2,1,3,4,5,6,7,8,9]，当<code>i==0</code>时，flag==true，会进行循环，当<code>i==1</code>,flag==true，会进行循环，但是由于没有交换，flag设置为false了，所以<code>i==2,i==3,...i=nums.length-1</code>这些都不用执行了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">flag</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span><span class="c1">//通过设置flag，可以避免无意义的交换运算。
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">flag</span><span class="o">=</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span><span class="c1">//只有当flag==true时才进行遍历
</span><span class="c1"></span>            <span class="n">flag</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span><span class="c1">//将其设置为false
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">2</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">-</span><span class="o">-</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                    <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">j</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
                    <span class="n">flag</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span><span class="c1">//如果进行交换了才将flag设为true
</span><span class="c1"></span>                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="冒泡排序复杂度分析">冒泡排序复杂度分析</h2>
<p>根据优化的冒泡排序，当待排序数组的数组本身就是有序的，只需要进行n-1次比较，时间复杂度为$O(n)$;当待排序数组的数组是逆序的时候，需要进行$1+2+3+&hellip;+(n-1)$次比较，总的比较次数为$\frac{n(n-1)}{2}$，时间复杂度为$O(n^2)$。</p>
<h1 id="简单选择排序">简单选择排序</h1>
<blockquote>
<p>通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution4</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">min</span><span class="o">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                   <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">!</span><span class="o">=</span><span class="n">min</span><span class="o">)</span><span class="o">{</span>
                <span class="n">swap</span><span class="o">(</span><span class="n">min</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323085018.png" /></p>
<h2 id="简单选择排序复杂度分析">简单选择排序复杂度分析</h2>
<p>简单选择排序的特点是交换的次数少。分析复杂度可以发现，无论最好或最坏的情况，其比较次数都是一样多的，第i趟排序需要进行n-i次比较，因此总共需要进行$\frac{n(n-1)}{2}$次比较，时间复杂度为$O(n^2)$。</p>
<p>常见问题：对含有31个元素的序列采用直接选择排序算法排序，在最坏情况下需要进行多少次<strong>移动</strong>才能完成排序？回答：90次，一次交换，三次移动，因为交换需要借助辅助变量；最坏的情况是数组是倒序排列的，这时需要进行n-1次交换，因为每一次交换需要借助辅助变量，所以移动的次数为3(n-1)</p>
<h1 id="直接插入排序法">直接插入排序法</h1>
<blockquote>
<p>将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数+1的有序表&ndash;维护一个有序表</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="o">)</span><span class="o">{</span><span class="c1">//如果nums[i]小于有序表的最后一个元素，此时就需要将nums[i]插入到有序表中，即将nums[i]放在有序表的上方。
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>  <span class="c1">//使用temp中间存储变量nums[i]
</span><span class="c1"></span>                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span><span class="c1">//依次将temp与有序表中的元素进行比较
</span><span class="c1"></span>                    <span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">0</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="o">&gt;</span><span class="n">temp</span><span class="o">)</span><span class="o">{</span><span class="c1">//如果temp小于有序表的最后一个元素，就将有序表的最后一个元素下移一位
</span><span class="c1"></span>                        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">else</span><span class="o">{</span>
                        <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>                
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>          
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323094448.png" /></p>
<p>另一种写法(<a href="https://www.runoob.com/data-structures/insertion-sort.html" target="_blank" rel="noopener noreffer">参考</a>)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution6</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span><span class="c1">//i从1开始，表示假设初始时nums[0]是一个有序表
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">-</span><span class="o">-</span><span class="o">)</span><span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="o">)</span><span class="o">{</span><span class="c1">//如果前一个数nums[j-1]比nums[j]，就将两者进行交换
</span><span class="c1"></span>                    <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">j</span><span class="o">-</span><span class="n">1</span> <span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="复杂度分析">复杂度分析</h2>
<p>最坏的情况，即数组为逆序，例如[9,8,7,6,5,4,3,2,1]，此时需要比较$2+3+4+&hellip;+n=\frac{(n+2)(n-1)}{2}$，时间复杂度为$O(n^2)$</p>
<h1 id="希尔排序">希尔排序</h1>
<p><a href="https://www.runoob.com/data-structures/shell-sort.html" target="_blank" rel="noopener noreffer">参考</a></p>
<p>希尔排序是插入排序的一种，它是针对直接插入排序算法的改进。</p>
<p>它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，<strong>直到只比较相邻元素</strong>（这就是直接插入排序）的最后一趟排序为止。</p>
<p>图例：</p>
<p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>在此我们选择增量 <strong>gap=length/2</strong>，缩小增量以 <strong>gap = gap/2</strong> 的方式，用序列 <strong>{n/2,(n/2)/2&hellip;1}</strong> 来表示。</p>
<p><img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145736.png" style="zoom:80%;" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323145808.png" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution7</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">gap</span><span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="n">2</span><span class="o">;</span><span class="n">gap</span><span class="o">&gt;</span><span class="n">0</span><span class="o">;</span><span class="n">gap</span><span class="o">/</span><span class="o">=</span><span class="n">2</span><span class="o">)</span><span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">gap</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span><span class="c1">//内层就是一个直接插入排序
</span><span class="c1"></span>                 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">gap</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">-</span><span class="o">=</span><span class="n">gap</span><span class="o">)</span><span class="o">{</span>
                     <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                         <span class="n">swap</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">j</span><span class="o">+</span><span class="n">gap</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span>
                     <span class="o">}</span>
                 <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>说明：</p>
<ul>
<li>最后一个增量必须为1</li>
</ul>
<h2 id="复杂度分析-1">复杂度分析</h2>
<p><a href="https://www.jianshu.com/p/d730ae586cf3" target="_blank" rel="noopener noreffer">参考</a></p>
<p>**希尔排序的执行时间依赖于增量序列。    **
希尔排序耗时的操作有：比较 + 后移赋值。</p>
<p><strong>时间复杂度情况如下：</strong>（n指待排序序列长度）
**1) 最好情况：**序列是正序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)
**2) 最坏情况：**O(nlog2n)。
**3) 渐进时间复杂度（平均时间复杂度）：**O(nlog2n)</p>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，<strong>希尔排序的时间复杂度会比O(n²)好一些。</strong>
希尔算法的性能与所选取的增量（分组长度）序列有很大关系。只对特定的待排序记录序列，可以准确地估算比较次数和移动次数。想要弄清比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，至今仍然是数学难题。</p>
<p>希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序在最坏的情况下执行的效率会非常差。希尔排序没有快速排序算法快，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。
（**注：**专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。）</p>
<h1 id="堆排序">堆排序</h1>
<p><a href="https://blog.csdn.net/qq_36186690/article/details/82505569" target="_blank" rel="noopener noreffer">参考</a></p>
<blockquote>
<p>堆（优先队列）：堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大项堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小项堆。</p>
</blockquote>
<p>堆的一些特性，假设大顶堆为：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162651.png" /></p>
<p>将其转换为数组形式为:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323162732.png" /></p>
<p>通过数学表达式进行描述为：
$$
arr[i]&gt;=arr[2i+1] \ arr[i]&gt;=arr[2i+2] 
$$</p>
<blockquote>
<p>因为堆是一棵完全二叉树，对于一个节点i，其左孩子一定为2i+1,右孩子一定为2i+2</p>
<p>可以理解为：堆是建立再数组上的树结构</p>
</blockquote>
<p>堆排序的思想：（假设利用大项堆）将待排序的数列构造成一个大项堆。此时，整个数列的最大值就是堆顶元素。将它移走，然后将剩余的n-1个序列重新够造成一个堆，这样就会得到n个元素中的次大元素。如此反复进行，就能够得到一个有序序列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution8</span><span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">/</span><span class="n">2</span><span class="o">-</span><span class="n">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">-</span><span class="o">-</span><span class="o">)</span><span class="o">{</span><span class="c1">//将无序数组调整为大顶堆
</span><span class="c1"></span>            <span class="n">HeapAdjust</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">i</span><span class="o">,</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">)</span><span class="o">;</span><span class="c1">//从第一个非叶子节点开始，从下到上，从右到左进行调整;就是将每一个非叶子节点是为根节点，将其和其子树调整为大顶堆
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">0</span><span class="o">;</span><span class="n">j</span><span class="o">-</span><span class="o">-</span><span class="o">)</span><span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">0</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span><span class="c1">//将堆顶元素与末尾元素进行交换
</span><span class="c1"></span>            <span class="n">HeapAdjust</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">j</span><span class="o">)</span><span class="o">;</span><span class="c1">//将数组中剩余元素调整为大顶堆   --&gt;注意因为其余的子树已经分别是大顶堆了，所以子需要对根节点进行调整即可
</span><span class="c1"></span>        <span class="o">}</span>

        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">HeapAdjust</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">,</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="n">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span><span class="n">i</span><span class="o">=</span><span class="n">2</span><span class="o">*</span><span class="n">s</span><span class="o">+</span><span class="n">1</span><span class="o">)</span><span class="o">{</span><span class="c1">//当前节点为s，它的左孩子为2*s+1,右孩子为2*s+2;它们的孩子也是以2*s+1进行增长
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">&lt;</span><span class="n">len</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="o">)</span><span class="o">{</span><span class="c1">//如果左孩子的值小于右孩子的值，将i指向右孩子
</span><span class="c1"></span>                <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">&gt;</span><span class="n">temp</span><span class="o">)</span><span class="o">{</span><span class="c1">//如果孩子节点大于父节点，将孩子节点的值赋值给父节点
</span><span class="c1"></span>                <span class="n">nums</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">;</span>
                <span class="n">s</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="c1">//将父节点的值赋值给孩子节点
</span><span class="c1"></span>            <span class="o">}</span><span class="k">else</span> <span class="o">{</span><span class="c1">//如果孩子节点小于父节点，直接退出
</span><span class="c1"></span>                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">s</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="复杂度分析-2">复杂度分析</h2>
<p>在正式排序时，第i次取堆顶元素重建堆需要用$O(\log i)$的时间，（完全二叉树的某个节点到根节点的距离为$[\log_2 i]+1$），并且需要取n-1次堆顶记录，所以堆排序的时间复杂度为$O(n\log n)$</p>
<h1 id="归并排序">归并排序</h1>
<p><a href="https://blog.csdn.net/engineerhe/article/details/104065282" target="_blank" rel="noopener noreffer">参考</a></p>
<p>原理：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列，再两两归并，如此反复，直到得到一个长度为n的有序序列为止。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323204438.png" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution9</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">&lt;</span><span class="n">2</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
        <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="o">)</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">,</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">&gt;</span><span class="o">=</span><span class="n">right</span><span class="o">)</span><span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="n">left</span><span class="o">+</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">)</span><span class="o">/</span><span class="n">2</span><span class="o">;</span> <span class="c1">// 计算中间位置
</span><span class="c1"></span>        <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">left</span><span class="o">,</span><span class="n">mid</span><span class="o">)</span><span class="o">;</span> <span class="c1">// 左侧子数组
</span><span class="c1"></span>        <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">mid</span><span class="o">+</span><span class="n">1</span><span class="o">,</span><span class="n">right</span><span class="o">)</span><span class="o">;</span> <span class="c1">// 右侧子数组  
</span><span class="c1"></span>        <span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">left</span><span class="o">,</span><span class="n">mid</span><span class="o">,</span><span class="n">right</span><span class="o">)</span><span class="o">;</span>  <span class="c1">// 合并子数组
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">temp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">+</span><span class="n">1</span><span class="o">]</span><span class="o">;</span><span class="c1">//定义辅助数组
</span><span class="c1"></span>        <span class="c1">// 定义两个指针，分别指向第一个子数组和第二个子数组的开始（这里mid+1就相等于第二个子数组开始）
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">p1</span><span class="o">=</span><span class="n">left</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">p2</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="n">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="c1">// 定义辅助数组移动的下标
</span><span class="c1"></span>
        <span class="c1">// 向temp中添加数字，任何一个子数组指向末尾的时候结束此while
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">p1</span><span class="o">&lt;</span><span class="o">=</span><span class="n">mid</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">p2</span><span class="o">&lt;</span><span class="o">=</span><span class="n">right</span><span class="o">)</span><span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">]</span><span class="o">)</span><span class="o">{</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span><span class="o">;</span>
                <span class="n">index</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
                <span class="n">p1</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">]</span><span class="o">;</span>
                <span class="n">index</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
                <span class="n">p2</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 这里的两个while是为了把剩下的一个子数组中的数字添加到temp中
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">p1</span><span class="o">&lt;</span><span class="o">=</span><span class="n">mid</span><span class="o">)</span><span class="o">{</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">p1</span><span class="o">]</span><span class="o">;</span>
            <span class="n">index</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="n">p1</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p2</span><span class="o">&lt;</span><span class="o">=</span><span class="n">right</span><span class="o">)</span><span class="o">{</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">p2</span><span class="o">]</span><span class="o">;</span>
            <span class="n">index</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="n">p2</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
        <span class="o">}</span>

         <span class="c1">// 把辅助数组中的数更新到目标数组中，这里需要注意目标数组更新的位置是left开始不是0开始。
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="o">)</span><span class="o">{</span>
            <span class="n">nums</span><span class="o">[</span><span class="n">left</span><span class="o">+</span><span class="n">i</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>假设待排序的数组为[8,4,5,7,1,3,6,2],则具体的执行步骤如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">left</span><span class="o">=</span><span class="n">0</span><span class="o">,</span><span class="n">right</span><span class="o">=</span><span class="n">7</span><span class="o">,</span><span class="n">mid</span><span class="o">=</span><span class="n">3</span>
    <span class="nf">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">3</span><span class="o">)</span> <span class="c1">//--&gt;处理|8|4|5|7|
</span><span class="c1"></span>    	<span class="n">left</span><span class="o">=</span><span class="n">0</span><span class="o">,</span><span class="n">right</span><span class="o">=</span><span class="n">3</span><span class="o">,</span><span class="n">mid</span><span class="o">=</span><span class="n">1</span>
    	<span class="nf">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">1</span><span class="o">)</span>  <span class="c1">//--&gt;处理|8|4|
</span><span class="c1"></span>    		<span class="n">left</span><span class="o">=</span><span class="n">0</span><span class="o">,</span><span class="n">right</span><span class="o">=</span><span class="n">1</span><span class="o">,</span><span class="n">mid</span><span class="o">=</span><span class="n">0</span>
    		<span class="nf">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">0</span><span class="o">)</span>
    			<span class="k">return</span>
    		<span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">1</span><span class="o">,</span><span class="n">1</span><span class="o">)</span>
    			<span class="k">return</span>
    		<span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">1</span><span class="o">)</span>
    	<span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">2</span><span class="o">,</span><span class="n">3</span><span class="o">)</span>  <span class="c1">//--&gt;处理|5|7|
</span><span class="c1"></span>    		<span class="n">left</span><span class="o">=</span><span class="n">2</span><span class="o">,</span><span class="n">right</span><span class="o">=</span><span class="n">3</span><span class="o">,</span><span class="n">mid</span><span class="o">=</span><span class="n">2</span>
    		<span class="nf">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">2</span><span class="o">,</span><span class="n">2</span><span class="o">)</span>
    			<span class="k">return</span>
    		<span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">3</span><span class="o">,</span><span class="n">3</span><span class="o">)</span>
    			<span class="k">return</span>
    		<span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">1</span><span class="o">,</span><span class="n">3</span><span class="o">)</span>
    <span class="n">mergeSort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">4</span><span class="o">,</span><span class="n">7</span><span class="o">)</span> <span class="c1">//--&gt;处理|1|2|6|2|
</span><span class="c1"></span>    	<span class="c1">//......
</span><span class="c1"></span>    <span class="n">merge</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">7</span><span class="o">,</span><span class="n">3</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="复杂度分析-3">复杂度分析</h2>
<p>时间复杂度为 $O(n \times log(n))$，但是需要损耗空间，其空间复杂度为$ O ( n )$，即需要一个额外的数组进行对子数组进行排序；</p>
<h1 id="快速排序">快速排序</h1>
<p>基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序的目的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution10</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="n">Qsort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">0</span><span class="o">,</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">1</span><span class="o">)</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">nums</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">Qsort</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">)</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">pivot</span><span class="o">=</span><span class="n">Partition</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">)</span><span class="o">;</span><span class="c1">//求出中枢值
</span><span class="c1"></span>            <span class="n">Qsort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">low</span><span class="o">,</span> <span class="n">pivot</span><span class="o">-</span><span class="n">1</span><span class="o">)</span><span class="o">;</span><span class="c1">//对中枢值左边的数组进行排序
</span><span class="c1"></span>            <span class="n">Qsort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">pivot</span><span class="o">+</span><span class="n">1</span><span class="o">,</span> <span class="n">high</span><span class="o">)</span><span class="o">;</span><span class="c1">//对中枢值右边的数组进行排序
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">Partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">low</span><span class="o">,</span> <span class="kt">int</span> <span class="n">high</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pivotKey</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">]</span><span class="o">;</span><span class="c1">//设置中枢值pivotKey为nums[low]，目标为pivotKey左边的数都小于它，右边的数都大于它
</span><span class="c1"></span>        <span class="k">while</span><span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">)</span><span class="o">{</span><span class="c1">//从左右分别进行比较
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">nums</span><span class="o">[</span><span class="n">high</span><span class="o">]</span><span class="o">&gt;</span><span class="o">=</span><span class="n">pivotKey</span><span class="o">)</span><span class="o">{</span><span class="c1">//从右边进行比较
</span><span class="c1"></span>                <span class="n">high</span><span class="o">-</span><span class="o">-</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span><span class="c1">//当nums[high]&lt;pivotKey,就将pivotKey与nums[high]交换
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;</span><span class="o">&amp;</span><span class="n">nums</span><span class="o">[</span><span class="n">low</span><span class="o">]</span><span class="o">&lt;</span><span class="o">=</span><span class="n">pivotKey</span><span class="o">)</span><span class="o">{</span><span class="c1">//从左边进行比较
</span><span class="c1"></span>                <span class="n">low</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">low</span><span class="o">,</span><span class="n">high</span><span class="o">,</span><span class="n">nums</span><span class="o">)</span><span class="o">;</span><span class="c1">//当nums[low]&gt;pivotKey,就将pivotKey与nums[low]交换
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="k">return</span> <span class="n">low</span><span class="o">;</span><span class="c1">//返回最终的中枢值的位置
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">,</span><span class="kt">int</span><span class="o">[</span><span class="o">]</span> <span class="n">nums</span><span class="o">)</span><span class="o">{</span>
        <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">;</span>
        <span class="n">nums</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="复杂度分析-4">复杂度分析</h2>
<p>最优的时间复杂度为$O(n\log n)$，最差的时间复杂度为$O(n^2)$，,空间复杂度为$O(\log n)$</p>
<p>因为关键字的比较和交换是跳跃进行的，所以快速排序是不稳定的。</p>
<h1 id="小结">小结</h1>
<h2 id="常用排序算法的分类">常用排序算法的分类</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png"
        data-srcset="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png 1.5x, https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png 2x"
        data-sizes="auto"
        alt="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png"
        title="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210323222105.png" /></p>
<h2 id="复杂度比较">复杂度比较</h2>
<p><img src="https://gitee.com/shilongshen/xiaoxingimagebad/raw/master/img/20210324101629.png" style="zoom:150%;" /></p>
<blockquote>
<p>简单排序：冒泡排序，简单选择排序，直接插入排序</p>
<p>改进算法：希尔排序，堆排序，归并排序，快速排序</p>
<p>从待排序记录的个数上来说，待排序的个数n越小，采用简单排序方法越合适。</p>
<p>只要是存在跳跃交换元素的排序算法都是不稳定的，例如简单选择排序，希尔排序，堆排序，快速排序</p>
</blockquote>
<h2 id="动画演示">动画演示</h2>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener noreffer">链接</a></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 0001-01-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="Share on WhatsApp" data-sharer="whatsapp" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="Share on Myspace" data-sharer="myspace" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="Share on Blogger" data-sharer="blogger" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="Share on Evernote" data-sharer="evernote" data-url="https://shilongshen.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-title="排序算法"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="prev" rel="prev" title="设计模式"><i class="fas fa-angle-left fa-fw"></i>设计模式</a>
            <a href="/mysql/" class="next" rel="next" title="MySQL">MySQL<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.63.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">shilongshen</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
